import LayerRenderer from 'ol/renderer/Layer';
import ImageLayer from 'ol/layer/Image';
import { transformExtent } from 'ol/proj';
import { Shader, Program, Uniform, Texture, Attribute } from '../../webgl/engine.core';
import { createTextCanvas } from '../../webgl/engine.helpers';
import { bindProgram } from '../../webgl/webgl';
import { rectangleA } from '../../webgl/engine.shapes';
import { flattenRecursive } from '../../webgl/utils';
export class DtmLayer extends ImageLayer {
    constructor(options) {
        super(options);
    }
    createRenderer() {
        this.renderer = new DtmImageRenderer(this);
        return this.renderer;
    }
    updateSunAngle(angle) {
        this.renderer.updateSunAngle(angle);
    }
}
/**
 * This renderer serves as a illustration of a very common technique in WebGL: normal-maps.
 * Here we use a texture from NASA's SRTM mission as our base-DTM.
 * Based on this, we calculate surface-normals. For each pixel in the DTM, we check how the surface-normal
 * is aligned with an incoming sun-ray.
 *
 * In real-world applications, many more such techniques are employed. Alongside normal-maps there are:
 *  - specular maps,
 *  - occlusion maps,
 *  - ...
 */
export class DtmImageRenderer extends LayerRenderer {
    constructor(layer) {
        super(layer);
        this.state = 'loading';
        // Step 1: setting up canvas
        const canvas = document.createElement('canvas');
        canvas.width = 1200;
        canvas.height = 800;
        canvas.style.position = 'absolute';
        // Step 2: setting up webgl
        const gl = canvas.getContext('webgl');
        // Step 3: setting up variables for program
        const source = layer.getSource();
        const currentProjection = source.getProjection();
        const bbox = source.getImageExtent();
        const rectangleInWorldPosition = this.bboxOntoRectangle(2, 2, bbox);
        const image = createTextCanvas('test', 2048, 2048, 'red');
        // Step 4: setting up program
        const program = new Program(gl, `
            attribute vec3 a_position;
            attribute vec2 a_texturePosition;
            uniform mat3 u_world2pix;
            uniform mat3 u_pix2canv;
            varying vec2 v_texturePosition;
            void main() {
                vec3 pixelPosition = u_world2pix * vec3(a_position.x, a_position.y, 1.);
                vec3 canvasPosition = u_pix2canv * pixelPosition;
                gl_Position = vec4(canvasPosition.x, canvasPosition.y, 0., 1.);
                v_texturePosition = a_texturePosition;
            }
        `, `
            precision mediump float;
            uniform sampler2D u_srtm;
            uniform float u_imageSize;
            uniform vec3 u_sun;
            varying vec2 v_texturePosition;
            void main() {
                float delta = 4. / u_imageSize;
                float top = texture2D(u_srtm, vec2(v_texturePosition.x,         1. - v_texturePosition.y + delta)).r;
                float bot = texture2D(u_srtm, vec2(v_texturePosition.x,         1. - v_texturePosition.y - delta)).r;
                float lft = texture2D(u_srtm, vec2(v_texturePosition.x + delta, 1. - v_texturePosition.y        )).r;
                float rgt = texture2D(u_srtm, vec2(v_texturePosition.x - delta, 1. - v_texturePosition.y        )).r;

                vec3 surfaceNormal = vec3(
                    lft - rgt,
                    bot - top,
                    2. * delta
                );
                surfaceNormal = normalize(surfaceNormal);
                vec3 sunNormal = normalize(u_sun);
                float alignment = abs(dot(sunNormal, surfaceNormal));

                gl_FragColor = vec4(0., 0., 0., 0.5 * alignment);
            }
        `);
        bindProgram(gl, program.program); // todo: is this required?
        const shader = new Shader(program, [
            new Attribute(gl, program, 'a_position', rectangleInWorldPosition.vertices),
            new Attribute(gl, program, 'a_texturePosition', rectangleInWorldPosition.texturePositions)
        ], [
            new Uniform(gl, program, 'u_imageSize', 'float', [2048.]),
            new Uniform(gl, program, 'u_sun', 'vec3', [0., 0., 1.]),
            new Uniform(gl, program, 'u_world2pix', 'mat3', flattenRecursive([
                [1., 0., 0.],
                [0., 1., 0.],
                [0., 0., 1.]
            ])),
            new Uniform(gl, program, 'u_pix2canv', 'mat3', flattenRecursive([
                [1. / (canvas.width / 2), 0., 0.],
                [0, -1. / (canvas.height / 2), 0.],
                [-1., 1., 1.]
            ]))
        ], [
            new Texture(gl, program, 'u_srtm', image, 0)
        ]);
        shader.bind(gl);
        // binding data for later use
        this.shader = shader;
        this.canvas = canvas;
        this.gl = gl;
        this.projection = currentProjection;
        // step 5: loading actual image
        const imageWrapper = source.getImage(bbox, 0.02197265625, 2.440000295639038, currentProjection);
        imageWrapper.addEventListener('change', (evt) => {
            const newImage = imageWrapper.getImage();
            this.shader.updateTextureData(this.gl, 'u_srtm', newImage);
            this.shader.bind(this.gl);
            this.state = 'ready';
            super.getLayer().changed();
        });
        imageWrapper.load();
    }
    prepareFrame(frameState) {
        if (this.state === 'ready') {
            const c2pT = frameState.coordinateToPixelTransform;
            const worldToPixelTransform = [
                [c2pT[0], c2pT[1], 0.],
                [c2pT[2], c2pT[3], 0.],
                [c2pT[4], c2pT[5], 1.]
            ];
            this.shader.updateUniformData(this.gl, 'u_world2pix', flattenRecursive(worldToPixelTransform));
            this.shader.bind(this.gl); // <--- @TODO: inefficient! Only re-bind world2pix matrix.
            if (frameState.viewState.projection !== this.projection) {
                this.reprojectImage(frameState.viewState.projection);
            }
        }
        return true;
    }
    renderFrame(frameState, target) {
        if (this.state === 'ready') {
            this.shader.render(this.gl);
            this.transformCanvas(frameState);
        }
        return this.canvas;
    }
    renderDeclutter(frameState) {
    }
    updateSunAngle(angle) {
        this.shader.updateUniformData(this.gl, 'u_sun', [angle[0], angle[1], 1.0]);
        this.shader.bind(this.gl);
        this.shader.render(this.gl);
    }
    bboxOntoRectangle(width, height, bbox) {
        const rect = rectangleA(width, height);
        for (const vertex of rect.vertices) {
            const x = vertex[0];
            const y = vertex[1];
            vertex[0] = (x === width / 2) ? bbox[2] : bbox[0];
            vertex[1] = (y === height / 2) ? bbox[3] : bbox[1];
        }
        return rect;
    }
    reprojectImage(targetProjection) {
        const source = super.getLayer().getSource();
        const sourceProjection = source.getProjection();
        const bbox = source.getImageExtent();
        const bboxInTargetProj = transformExtent(bbox, sourceProjection, targetProjection);
        const newRectangleInWorldPosition = this.bboxOntoRectangle(2, 2, bboxInTargetProj);
        this.shader.updateAttributeData(this.gl, 'a_position', newRectangleInWorldPosition.vertices);
        this.shader.bind(this.gl);
    }
    transformCanvas(frameState) {
        const layerState = frameState.layerStatesArray[frameState.layerIndex];
        const pixelRatio = frameState.pixelRatio;
        const size = frameState.size;
        const width = Math.round(size[0] * pixelRatio);
        const height = Math.round(size[1] * pixelRatio);
        const opacity = layerState.opacity;
        this.canvas.width = width;
        this.canvas.height = height;
        this.canvas.style.opacity = `${opacity}`;
        const pix2canv = [
            [1. / (this.canvas.width / 2), 0., 0.],
            [0, -1. / (this.canvas.height / 2), 0.],
            [-1., 1., 1.]
        ];
        this.shader.updateUniformData(this.gl, 'u_pix2canv', flattenRecursive(pix2canv));
        // this.interpolationShader.bind(this.gl); <-- not required: already happens in `prepareFrame`
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHRtX3JlbmRlcmVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvdXRpbHMtbWFwcy9zcmMvbGliL29sL2N1c3RvbVJlbmRlcmVycy9kdG1fcmVuZGVyZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxhQUFhLE1BQU0sbUJBQW1CLENBQUM7QUFDOUMsT0FBTyxVQUFVLE1BQU0sZ0JBQWdCLENBQUM7QUFHeEMsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLFNBQVMsQ0FBQztBQUUxQyxPQUFPLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQ3ZGLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQzlELE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNoRCxPQUFPLEVBQVUsVUFBVSxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDL0QsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFJckQsTUFBTSxPQUFPLFFBQVMsU0FBUSxVQUF1QjtJQUdqRCxZQUFZLE9BQU87UUFDZixLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDbkIsQ0FBQztJQUVELGNBQWM7UUFDVixJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDM0MsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDO0lBQ3pCLENBQUM7SUFFRCxjQUFjLENBQUMsS0FBZTtRQUMxQixJQUFJLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN4QyxDQUFDO0NBQ0o7QUFHRDs7Ozs7Ozs7OztHQVVHO0FBQ0gsTUFBTSxPQUFPLGdCQUFpQixTQUFRLGFBQXNDO0lBUXhFLFlBQVksS0FBOEI7UUFDdEMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBSFQsVUFBSyxHQUF3QixTQUFTLENBQUM7UUFLM0MsNEJBQTRCO1FBQzVCLE1BQU0sTUFBTSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDaEQsTUFBTSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7UUFDcEIsTUFBTSxDQUFDLE1BQU0sR0FBRyxHQUFHLENBQUM7UUFDcEIsTUFBTSxDQUFDLEtBQUssQ0FBQyxRQUFRLEdBQUcsVUFBVSxDQUFDO1FBRW5DLDJCQUEyQjtRQUMzQixNQUFNLEVBQUUsR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRXRDLDJDQUEyQztRQUMzQyxNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsU0FBUyxFQUFZLENBQUM7UUFDM0MsTUFBTSxpQkFBaUIsR0FBRyxNQUFNLENBQUMsYUFBYSxFQUFFLENBQUM7UUFDakQsTUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLGNBQWMsRUFBRSxDQUFDO1FBQ3JDLE1BQU0sd0JBQXdCLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDcEUsTUFBTSxLQUFLLEdBQUcsZ0JBQWdCLENBQUMsTUFBTSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFFMUQsNkJBQTZCO1FBQzdCLE1BQU0sT0FBTyxHQUFHLElBQUksT0FBTyxDQUFDLEVBQUUsRUFBRTs7Ozs7Ozs7Ozs7O1NBWS9CLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztTQXdCRixDQUFDLENBQUM7UUFDSCxXQUFXLENBQUMsRUFBRSxFQUFFLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLDBCQUEwQjtRQUU1RCxNQUFNLE1BQU0sR0FBRyxJQUFJLE1BQU0sQ0FDckIsT0FBTyxFQUNQO1lBQ0ksSUFBSSxTQUFTLENBQUMsRUFBRSxFQUFFLE9BQU8sRUFBRSxZQUFZLEVBQUUsd0JBQXdCLENBQUMsUUFBUSxDQUFDO1lBQzNFLElBQUksU0FBUyxDQUFDLEVBQUUsRUFBRSxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsd0JBQXdCLENBQUMsZ0JBQWdCLENBQUM7U0FDN0YsRUFBRTtZQUNDLElBQUksT0FBTyxDQUFDLEVBQUUsRUFBRSxPQUFPLEVBQUUsYUFBYSxFQUFFLE9BQU8sRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3pELElBQUksT0FBTyxDQUFDLEVBQUUsRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDdkQsSUFBSSxPQUFPLENBQUMsRUFBRSxFQUFFLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxFQUFFLGdCQUFnQixDQUFDO2dCQUM3RCxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDO2dCQUNaLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUM7Z0JBQ1osQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQzthQUNmLENBQUMsQ0FBQztZQUNILElBQUksT0FBTyxDQUFDLEVBQUUsRUFBRSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sRUFBRSxnQkFBZ0IsQ0FBQztnQkFDNUQsQ0FBQyxFQUFFLEdBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxFQUFHLEVBQUUsRUFBeUIsRUFBRSxDQUFFO2dCQUMzRCxDQUFDLENBQUMsRUFBeUIsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxFQUFHLEVBQUUsQ0FBRTtnQkFDM0QsQ0FBQyxDQUFDLEVBQUUsRUFBdUIsRUFBRSxFQUEwQixFQUFFLENBQUU7YUFDOUQsQ0FBQyxDQUFDO1NBQ04sRUFBRTtZQUNDLElBQUksT0FBTyxDQUFDLEVBQUUsRUFBRSxPQUFPLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7U0FDL0MsQ0FDSixDQUFDO1FBQ0YsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUVoQiw2QkFBNkI7UUFDN0IsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFDckIsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFDckIsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUM7UUFDYixJQUFJLENBQUMsVUFBVSxHQUFHLGlCQUFpQixDQUFDO1FBRXBDLCtCQUErQjtRQUMvQixNQUFNLFlBQVksR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxhQUFhLEVBQUUsaUJBQWlCLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztRQUNoRyxZQUFZLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxFQUFFLENBQUMsR0FBVSxFQUFFLEVBQUU7WUFDbkQsTUFBTSxRQUFRLEdBQUcsWUFBWSxDQUFDLFFBQVEsRUFBMEMsQ0FBQztZQUNqRixJQUFJLENBQUMsTUFBTSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1lBQzNELElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUMxQixJQUFJLENBQUMsS0FBSyxHQUFHLE9BQU8sQ0FBQztZQUNyQixLQUFLLENBQUMsUUFBUSxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDL0IsQ0FBQyxDQUFDLENBQUM7UUFDSCxZQUFZLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDeEIsQ0FBQztJQUdELFlBQVksQ0FBQyxVQUFzQjtRQUMvQixJQUFJLElBQUksQ0FBQyxLQUFLLEtBQUssT0FBTyxFQUFFO1lBQ3hCLE1BQU0sSUFBSSxHQUFHLFVBQVUsQ0FBQywwQkFBMEIsQ0FBQztZQUNuRCxNQUFNLHFCQUFxQixHQUFHO2dCQUMxQixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUssRUFBRSxDQUFFO2dCQUM1QixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUssRUFBRSxDQUFFO2dCQUM1QixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUssRUFBRSxDQUFFO2FBQy9CLENBQUM7WUFDRixJQUFJLENBQUMsTUFBTSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsYUFBYSxFQUFFLGdCQUFnQixDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQztZQUMvRixJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQywwREFBMEQ7WUFFckYsSUFBSSxVQUFVLENBQUMsU0FBUyxDQUFDLFVBQVUsS0FBSyxJQUFJLENBQUMsVUFBVSxFQUFFO2dCQUNyRCxJQUFJLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLENBQUM7YUFDeEQ7U0FDSjtRQUVELE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFHRCxXQUFXLENBQUMsVUFBc0IsRUFBRSxNQUFtQjtRQUNuRCxJQUFJLElBQUksQ0FBQyxLQUFLLEtBQUssT0FBTyxFQUFFO1lBQ3hCLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUM1QixJQUFJLENBQUMsZUFBZSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1NBQ3BDO1FBQ0QsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDO0lBQ3ZCLENBQUM7SUFFRCxlQUFlLENBQUMsVUFBc0I7SUFDdEMsQ0FBQztJQUdELGNBQWMsQ0FBQyxLQUFlO1FBQzFCLElBQUksQ0FBQyxNQUFNLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxPQUFPLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDM0UsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQzFCLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNoQyxDQUFDO0lBR08saUJBQWlCLENBQUMsS0FBYSxFQUFFLE1BQWMsRUFBRSxJQUFjO1FBQ25FLE1BQU0sSUFBSSxHQUFHLFVBQVUsQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDdkMsS0FBSyxNQUFNLE1BQU0sSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ2hDLE1BQU0sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNwQixNQUFNLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDcEIsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDbEQsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDdEQ7UUFDRCxPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0lBRU8sY0FBYyxDQUFDLGdCQUFnQjtRQUNuQyxNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUMsU0FBUyxFQUFZLENBQUM7UUFDdEQsTUFBTSxnQkFBZ0IsR0FBRyxNQUFNLENBQUMsYUFBYSxFQUFFLENBQUM7UUFDaEQsTUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLGNBQWMsRUFBRSxDQUFDO1FBQ3JDLE1BQU0sZ0JBQWdCLEdBQUcsZUFBZSxDQUFDLElBQUksRUFBRSxnQkFBZ0IsRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDO1FBQ25GLE1BQU0sMkJBQTJCLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztRQUNuRixJQUFJLENBQUMsTUFBTSxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsWUFBWSxFQUFFLDJCQUEyQixDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQzdGLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUM5QixDQUFDO0lBRU8sZUFBZSxDQUFDLFVBQXNCO1FBQzFDLE1BQU0sVUFBVSxHQUFHLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDdEUsTUFBTSxVQUFVLEdBQUcsVUFBVSxDQUFDLFVBQVUsQ0FBQztRQUN6QyxNQUFNLElBQUksR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDO1FBQzdCLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxDQUFDO1FBQy9DLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxDQUFDO1FBQ2hELE1BQU0sT0FBTyxHQUFHLFVBQVUsQ0FBQyxPQUFPLENBQUM7UUFFbkMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBQzFCLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUM1QixJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsR0FBRyxPQUFPLEVBQUUsQ0FBQztRQUV6QyxNQUFNLFFBQVEsR0FBRztZQUNiLENBQUMsRUFBRSxHQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLEVBQUcsRUFBRSxFQUErQixFQUFFLENBQUU7WUFDdEUsQ0FBQyxDQUFDLEVBQStCLENBQUMsRUFBRSxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLEVBQUcsRUFBRSxDQUFFO1lBQ3RFLENBQUMsQ0FBQyxFQUFFLEVBQTZCLEVBQUUsRUFBK0IsRUFBRSxDQUFFO1NBQ3pFLENBQUM7UUFDRixJQUFJLENBQUMsTUFBTSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsWUFBWSxFQUFFLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7UUFDakYsOEZBQThGO0lBQ2xHLENBQUM7Q0FDSiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBMYXllclJlbmRlcmVyIGZyb20gJ29sL3JlbmRlcmVyL0xheWVyJztcbmltcG9ydCBJbWFnZUxheWVyIGZyb20gJ29sL2xheWVyL0ltYWdlJztcbmltcG9ydCBJbWFnZVNvdXJjZSBmcm9tICdvbC9zb3VyY2UvSW1hZ2UnO1xuaW1wb3J0IHsgRnJhbWVTdGF0ZSB9IGZyb20gJ29sL1BsdWdnYWJsZU1hcCc7XG5pbXBvcnQgeyB0cmFuc2Zvcm1FeHRlbnQgfSBmcm9tICdvbC9wcm9qJztcbmltcG9ydCBTdGF0aWMgZnJvbSAnb2wvc291cmNlL0ltYWdlU3RhdGljJztcbmltcG9ydCB7IFNoYWRlciwgUHJvZ3JhbSwgVW5pZm9ybSwgVGV4dHVyZSwgQXR0cmlidXRlIH0gZnJvbSAnLi4vLi4vd2ViZ2wvZW5naW5lLmNvcmUnO1xuaW1wb3J0IHsgY3JlYXRlVGV4dENhbnZhcyB9IGZyb20gJy4uLy4uL3dlYmdsL2VuZ2luZS5oZWxwZXJzJztcbmltcG9ydCB7IGJpbmRQcm9ncmFtIH0gZnJvbSAnLi4vLi4vd2ViZ2wvd2ViZ2wnO1xuaW1wb3J0IHsgU2hhcGVBLCByZWN0YW5nbGVBIH0gZnJvbSAnLi4vLi4vd2ViZ2wvZW5naW5lLnNoYXBlcyc7XG5pbXBvcnQgeyBmbGF0dGVuUmVjdXJzaXZlIH0gZnJvbSAnLi4vLi4vd2ViZ2wvdXRpbHMnO1xuXG5cblxuZXhwb3J0IGNsYXNzIER0bUxheWVyIGV4dGVuZHMgSW1hZ2VMYXllcjxJbWFnZVNvdXJjZT4ge1xuICAgIHByaXZhdGUgcmVuZGVyZXI6IER0bUltYWdlUmVuZGVyZXI7XG5cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGNyZWF0ZVJlbmRlcmVyKCk6IER0bUltYWdlUmVuZGVyZXIge1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gbmV3IER0bUltYWdlUmVuZGVyZXIodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyO1xuICAgIH1cblxuICAgIHVwZGF0ZVN1bkFuZ2xlKGFuZ2xlOiBudW1iZXJbXSk6IHZvaWQge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZVN1bkFuZ2xlKGFuZ2xlKTtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBUaGlzIHJlbmRlcmVyIHNlcnZlcyBhcyBhIGlsbHVzdHJhdGlvbiBvZiBhIHZlcnkgY29tbW9uIHRlY2huaXF1ZSBpbiBXZWJHTDogbm9ybWFsLW1hcHMuXG4gKiBIZXJlIHdlIHVzZSBhIHRleHR1cmUgZnJvbSBOQVNBJ3MgU1JUTSBtaXNzaW9uIGFzIG91ciBiYXNlLURUTS5cbiAqIEJhc2VkIG9uIHRoaXMsIHdlIGNhbGN1bGF0ZSBzdXJmYWNlLW5vcm1hbHMuIEZvciBlYWNoIHBpeGVsIGluIHRoZSBEVE0sIHdlIGNoZWNrIGhvdyB0aGUgc3VyZmFjZS1ub3JtYWxcbiAqIGlzIGFsaWduZWQgd2l0aCBhbiBpbmNvbWluZyBzdW4tcmF5LlxuICpcbiAqIEluIHJlYWwtd29ybGQgYXBwbGljYXRpb25zLCBtYW55IG1vcmUgc3VjaCB0ZWNobmlxdWVzIGFyZSBlbXBsb3llZC4gQWxvbmdzaWRlIG5vcm1hbC1tYXBzIHRoZXJlIGFyZTpcbiAqICAtIHNwZWN1bGFyIG1hcHMsXG4gKiAgLSBvY2NsdXNpb24gbWFwcyxcbiAqICAtIC4uLlxuICovXG5leHBvcnQgY2xhc3MgRHRtSW1hZ2VSZW5kZXJlciBleHRlbmRzIExheWVyUmVuZGVyZXI8SW1hZ2VMYXllcjxJbWFnZVNvdXJjZT4+IHtcblxuICAgIHJlYWRvbmx5IGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQ7XG4gICAgcmVhZG9ubHkgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dDtcbiAgICByZWFkb25seSBzaGFkZXI6IFNoYWRlcjtcbiAgICByZWFkb25seSBwcm9qZWN0aW9uO1xuICAgIHByaXZhdGUgc3RhdGU6ICdsb2FkaW5nJyB8ICdyZWFkeScgPSAnbG9hZGluZyc7XG5cbiAgICBjb25zdHJ1Y3RvcihsYXllcjogSW1hZ2VMYXllcjxJbWFnZVNvdXJjZT4pIHtcbiAgICAgICAgc3VwZXIobGF5ZXIpO1xuXG4gICAgICAgIC8vIFN0ZXAgMTogc2V0dGluZyB1cCBjYW52YXNcbiAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IDEyMDA7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSA4MDA7XG4gICAgICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cbiAgICAgICAgLy8gU3RlcCAyOiBzZXR0aW5nIHVwIHdlYmdsXG4gICAgICAgIGNvbnN0IGdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJyk7XG5cbiAgICAgICAgLy8gU3RlcCAzOiBzZXR0aW5nIHVwIHZhcmlhYmxlcyBmb3IgcHJvZ3JhbVxuICAgICAgICBjb25zdCBzb3VyY2UgPSBsYXllci5nZXRTb3VyY2UoKSBhcyBTdGF0aWM7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQcm9qZWN0aW9uID0gc291cmNlLmdldFByb2plY3Rpb24oKTtcbiAgICAgICAgY29uc3QgYmJveCA9IHNvdXJjZS5nZXRJbWFnZUV4dGVudCgpO1xuICAgICAgICBjb25zdCByZWN0YW5nbGVJbldvcmxkUG9zaXRpb24gPSB0aGlzLmJib3hPbnRvUmVjdGFuZ2xlKDIsIDIsIGJib3gpO1xuICAgICAgICBjb25zdCBpbWFnZSA9IGNyZWF0ZVRleHRDYW52YXMoJ3Rlc3QnLCAyMDQ4LCAyMDQ4LCAncmVkJyk7XG5cbiAgICAgICAgLy8gU3RlcCA0OiBzZXR0aW5nIHVwIHByb2dyYW1cbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGdsLCBgXG4gICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMyBhX3Bvc2l0aW9uO1xuICAgICAgICAgICAgYXR0cmlidXRlIHZlYzIgYV90ZXh0dXJlUG9zaXRpb247XG4gICAgICAgICAgICB1bmlmb3JtIG1hdDMgdV93b3JsZDJwaXg7XG4gICAgICAgICAgICB1bmlmb3JtIG1hdDMgdV9waXgyY2FudjtcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMiB2X3RleHR1cmVQb3NpdGlvbjtcbiAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgICAgICB2ZWMzIHBpeGVsUG9zaXRpb24gPSB1X3dvcmxkMnBpeCAqIHZlYzMoYV9wb3NpdGlvbi54LCBhX3Bvc2l0aW9uLnksIDEuKTtcbiAgICAgICAgICAgICAgICB2ZWMzIGNhbnZhc1Bvc2l0aW9uID0gdV9waXgyY2FudiAqIHBpeGVsUG9zaXRpb247XG4gICAgICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGNhbnZhc1Bvc2l0aW9uLngsIGNhbnZhc1Bvc2l0aW9uLnksIDAuLCAxLik7XG4gICAgICAgICAgICAgICAgdl90ZXh0dXJlUG9zaXRpb24gPSBhX3RleHR1cmVQb3NpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYCwgYFxuICAgICAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X3NydG07XG4gICAgICAgICAgICB1bmlmb3JtIGZsb2F0IHVfaW1hZ2VTaXplO1xuICAgICAgICAgICAgdW5pZm9ybSB2ZWMzIHVfc3VuO1xuICAgICAgICAgICAgdmFyeWluZyB2ZWMyIHZfdGV4dHVyZVBvc2l0aW9uO1xuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgIGZsb2F0IGRlbHRhID0gNC4gLyB1X2ltYWdlU2l6ZTtcbiAgICAgICAgICAgICAgICBmbG9hdCB0b3AgPSB0ZXh0dXJlMkQodV9zcnRtLCB2ZWMyKHZfdGV4dHVyZVBvc2l0aW9uLngsICAgICAgICAgMS4gLSB2X3RleHR1cmVQb3NpdGlvbi55ICsgZGVsdGEpKS5yO1xuICAgICAgICAgICAgICAgIGZsb2F0IGJvdCA9IHRleHR1cmUyRCh1X3NydG0sIHZlYzIodl90ZXh0dXJlUG9zaXRpb24ueCwgICAgICAgICAxLiAtIHZfdGV4dHVyZVBvc2l0aW9uLnkgLSBkZWx0YSkpLnI7XG4gICAgICAgICAgICAgICAgZmxvYXQgbGZ0ID0gdGV4dHVyZTJEKHVfc3J0bSwgdmVjMih2X3RleHR1cmVQb3NpdGlvbi54ICsgZGVsdGEsIDEuIC0gdl90ZXh0dXJlUG9zaXRpb24ueSAgICAgICAgKSkucjtcbiAgICAgICAgICAgICAgICBmbG9hdCByZ3QgPSB0ZXh0dXJlMkQodV9zcnRtLCB2ZWMyKHZfdGV4dHVyZVBvc2l0aW9uLnggLSBkZWx0YSwgMS4gLSB2X3RleHR1cmVQb3NpdGlvbi55ICAgICAgICApKS5yO1xuXG4gICAgICAgICAgICAgICAgdmVjMyBzdXJmYWNlTm9ybWFsID0gdmVjMyhcbiAgICAgICAgICAgICAgICAgICAgbGZ0IC0gcmd0LFxuICAgICAgICAgICAgICAgICAgICBib3QgLSB0b3AsXG4gICAgICAgICAgICAgICAgICAgIDIuICogZGVsdGFcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHN1cmZhY2VOb3JtYWwgPSBub3JtYWxpemUoc3VyZmFjZU5vcm1hbCk7XG4gICAgICAgICAgICAgICAgdmVjMyBzdW5Ob3JtYWwgPSBub3JtYWxpemUodV9zdW4pO1xuICAgICAgICAgICAgICAgIGZsb2F0IGFsaWdubWVudCA9IGFicyhkb3Qoc3VuTm9ybWFsLCBzdXJmYWNlTm9ybWFsKSk7XG5cbiAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuLCAwLiwgMC4sIDAuNSAqIGFsaWdubWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGApO1xuICAgICAgICBiaW5kUHJvZ3JhbShnbCwgcHJvZ3JhbS5wcm9ncmFtKTsgLy8gdG9kbzogaXMgdGhpcyByZXF1aXJlZD9cblxuICAgICAgICBjb25zdCBzaGFkZXIgPSBuZXcgU2hhZGVyKFxuICAgICAgICAgICAgcHJvZ3JhbSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBuZXcgQXR0cmlidXRlKGdsLCBwcm9ncmFtLCAnYV9wb3NpdGlvbicsIHJlY3RhbmdsZUluV29ybGRQb3NpdGlvbi52ZXJ0aWNlcyksXG4gICAgICAgICAgICAgICAgbmV3IEF0dHJpYnV0ZShnbCwgcHJvZ3JhbSwgJ2FfdGV4dHVyZVBvc2l0aW9uJywgcmVjdGFuZ2xlSW5Xb3JsZFBvc2l0aW9uLnRleHR1cmVQb3NpdGlvbnMpXG4gICAgICAgICAgICBdLCBbXG4gICAgICAgICAgICAgICAgbmV3IFVuaWZvcm0oZ2wsIHByb2dyYW0sICd1X2ltYWdlU2l6ZScsICdmbG9hdCcsIFsyMDQ4Ll0pLFxuICAgICAgICAgICAgICAgIG5ldyBVbmlmb3JtKGdsLCBwcm9ncmFtLCAndV9zdW4nLCAndmVjMycsIFswLiwgMC4sIDEuXSksICAvLyBhcnJheSwgcG9pbnRpbmcgdG8gc3VuIGZyb20gbWlkZGxlIG9mIG1hcC5cbiAgICAgICAgICAgICAgICBuZXcgVW5pZm9ybShnbCwgcHJvZ3JhbSwgJ3Vfd29ybGQycGl4JywgJ21hdDMnLCBmbGF0dGVuUmVjdXJzaXZlKFtcbiAgICAgICAgICAgICAgICAgICAgWzEuLCAwLiwgMC5dLFxuICAgICAgICAgICAgICAgICAgICBbMC4sIDEuLCAwLl0sXG4gICAgICAgICAgICAgICAgICAgIFswLiwgMC4sIDEuXVxuICAgICAgICAgICAgICAgIF0pKSxcbiAgICAgICAgICAgICAgICBuZXcgVW5pZm9ybShnbCwgcHJvZ3JhbSwgJ3VfcGl4MmNhbnYnLCAnbWF0MycsIGZsYXR0ZW5SZWN1cnNpdmUoW1xuICAgICAgICAgICAgICAgICAgICBbMS4gLyAgKGNhbnZhcy53aWR0aCAvIDIpLCAgMC4sICAgICAgICAgICAgICAgICAgICAgICAgMC4gXSxcbiAgICAgICAgICAgICAgICAgICAgWzAsICAgICAgICAgICAgICAgICAgICAgICAgLTEuIC8gKGNhbnZhcy5oZWlnaHQgLyAyKSwgIDAuIF0sXG4gICAgICAgICAgICAgICAgICAgIFstMS4sICAgICAgICAgICAgICAgICAgICAgIDEuLCAgICAgICAgICAgICAgICAgICAgICAgICAxLiBdXG4gICAgICAgICAgICAgICAgXSkpXG4gICAgICAgICAgICBdLCBbXG4gICAgICAgICAgICAgICAgbmV3IFRleHR1cmUoZ2wsIHByb2dyYW0sICd1X3NydG0nLCBpbWFnZSwgMClcbiAgICAgICAgICAgIF1cbiAgICAgICAgKTtcbiAgICAgICAgc2hhZGVyLmJpbmQoZ2wpO1xuXG4gICAgICAgIC8vIGJpbmRpbmcgZGF0YSBmb3IgbGF0ZXIgdXNlXG4gICAgICAgIHRoaXMuc2hhZGVyID0gc2hhZGVyO1xuICAgICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgICAgdGhpcy5nbCA9IGdsO1xuICAgICAgICB0aGlzLnByb2plY3Rpb24gPSBjdXJyZW50UHJvamVjdGlvbjtcblxuICAgICAgICAvLyBzdGVwIDU6IGxvYWRpbmcgYWN0dWFsIGltYWdlXG4gICAgICAgIGNvbnN0IGltYWdlV3JhcHBlciA9IHNvdXJjZS5nZXRJbWFnZShiYm94LCAwLjAyMTk3MjY1NjI1LCAyLjQ0MDAwMDI5NTYzOTAzOCwgY3VycmVudFByb2plY3Rpb24pO1xuICAgICAgICBpbWFnZVdyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGV2dDogRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0ltYWdlID0gaW1hZ2VXcmFwcGVyLmdldEltYWdlKCkgYXMgSFRNTEltYWdlRWxlbWVudCB8IEhUTUxDYW52YXNFbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5zaGFkZXIudXBkYXRlVGV4dHVyZURhdGEodGhpcy5nbCwgJ3Vfc3J0bScsIG5ld0ltYWdlKTtcbiAgICAgICAgICAgIHRoaXMuc2hhZGVyLmJpbmQodGhpcy5nbCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gJ3JlYWR5JztcbiAgICAgICAgICAgIHN1cGVyLmdldExheWVyKCkuY2hhbmdlZCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgaW1hZ2VXcmFwcGVyLmxvYWQoKTtcbiAgICB9XG5cblxuICAgIHByZXBhcmVGcmFtZShmcmFtZVN0YXRlOiBGcmFtZVN0YXRlKTogYm9vbGVhbiB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAncmVhZHknKSB7XG4gICAgICAgICAgICBjb25zdCBjMnBUID0gZnJhbWVTdGF0ZS5jb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybTtcbiAgICAgICAgICAgIGNvbnN0IHdvcmxkVG9QaXhlbFRyYW5zZm9ybSA9IFtcbiAgICAgICAgICAgICAgICBbYzJwVFswXSwgICBjMnBUWzFdLCAgICAwLiBdLFxuICAgICAgICAgICAgICAgIFtjMnBUWzJdLCAgIGMycFRbM10sICAgIDAuIF0sXG4gICAgICAgICAgICAgICAgW2MycFRbNF0sICAgYzJwVFs1XSwgICAgMS4gXVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHRoaXMuc2hhZGVyLnVwZGF0ZVVuaWZvcm1EYXRhKHRoaXMuZ2wsICd1X3dvcmxkMnBpeCcsIGZsYXR0ZW5SZWN1cnNpdmUod29ybGRUb1BpeGVsVHJhbnNmb3JtKSk7XG4gICAgICAgICAgICB0aGlzLnNoYWRlci5iaW5kKHRoaXMuZ2wpOyAvLyA8LS0tIEBUT0RPOiBpbmVmZmljaWVudCEgT25seSByZS1iaW5kIHdvcmxkMnBpeCBtYXRyaXguXG5cbiAgICAgICAgICAgIGlmIChmcmFtZVN0YXRlLnZpZXdTdGF0ZS5wcm9qZWN0aW9uICE9PSB0aGlzLnByb2plY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcHJvamVjdEltYWdlKGZyYW1lU3RhdGUudmlld1N0YXRlLnByb2plY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG5cbiAgICByZW5kZXJGcmFtZShmcmFtZVN0YXRlOiBGcmFtZVN0YXRlLCB0YXJnZXQ6IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnQge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ3JlYWR5Jykge1xuICAgICAgICAgICAgdGhpcy5zaGFkZXIucmVuZGVyKHRoaXMuZ2wpO1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMoZnJhbWVTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzO1xuICAgIH1cblxuICAgIHJlbmRlckRlY2x1dHRlcihmcmFtZVN0YXRlOiBGcmFtZVN0YXRlKSB7XG4gICAgfVxuXG5cbiAgICB1cGRhdGVTdW5BbmdsZShhbmdsZTogbnVtYmVyW10pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zaGFkZXIudXBkYXRlVW5pZm9ybURhdGEodGhpcy5nbCwgJ3Vfc3VuJywgW2FuZ2xlWzBdLCBhbmdsZVsxXSwgMS4wXSk7XG4gICAgICAgIHRoaXMuc2hhZGVyLmJpbmQodGhpcy5nbCk7XG4gICAgICAgIHRoaXMuc2hhZGVyLnJlbmRlcih0aGlzLmdsKTtcbiAgICB9XG5cblxuICAgIHByaXZhdGUgYmJveE9udG9SZWN0YW5nbGUod2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIsIGJib3g6IG51bWJlcltdKTogU2hhcGVBIHtcbiAgICAgICAgY29uc3QgcmVjdCA9IHJlY3RhbmdsZUEod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGZvciAoY29uc3QgdmVydGV4IG9mIHJlY3QudmVydGljZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSB2ZXJ0ZXhbMF07XG4gICAgICAgICAgICBjb25zdCB5ID0gdmVydGV4WzFdO1xuICAgICAgICAgICAgdmVydGV4WzBdID0gKHggPT09IHdpZHRoIC8gMikgPyBiYm94WzJdIDogYmJveFswXTtcbiAgICAgICAgICAgIHZlcnRleFsxXSA9ICh5ID09PSBoZWlnaHQgLyAyKSA/IGJib3hbM10gOiBiYm94WzFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIH1cblxuICAgIHByaXZhdGUgcmVwcm9qZWN0SW1hZ2UodGFyZ2V0UHJvamVjdGlvbik6IHZvaWQge1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBzdXBlci5nZXRMYXllcigpLmdldFNvdXJjZSgpIGFzIFN0YXRpYztcbiAgICAgICAgY29uc3Qgc291cmNlUHJvamVjdGlvbiA9IHNvdXJjZS5nZXRQcm9qZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IGJib3ggPSBzb3VyY2UuZ2V0SW1hZ2VFeHRlbnQoKTtcbiAgICAgICAgY29uc3QgYmJveEluVGFyZ2V0UHJvaiA9IHRyYW5zZm9ybUV4dGVudChiYm94LCBzb3VyY2VQcm9qZWN0aW9uLCB0YXJnZXRQcm9qZWN0aW9uKTtcbiAgICAgICAgY29uc3QgbmV3UmVjdGFuZ2xlSW5Xb3JsZFBvc2l0aW9uID0gdGhpcy5iYm94T250b1JlY3RhbmdsZSgyLCAyLCBiYm94SW5UYXJnZXRQcm9qKTtcbiAgICAgICAgdGhpcy5zaGFkZXIudXBkYXRlQXR0cmlidXRlRGF0YSh0aGlzLmdsLCAnYV9wb3NpdGlvbicsIG5ld1JlY3RhbmdsZUluV29ybGRQb3NpdGlvbi52ZXJ0aWNlcyk7XG4gICAgICAgIHRoaXMuc2hhZGVyLmJpbmQodGhpcy5nbCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB0cmFuc2Zvcm1DYW52YXMoZnJhbWVTdGF0ZTogRnJhbWVTdGF0ZSk6IHZvaWQge1xuICAgICAgICBjb25zdCBsYXllclN0YXRlID0gZnJhbWVTdGF0ZS5sYXllclN0YXRlc0FycmF5W2ZyYW1lU3RhdGUubGF5ZXJJbmRleF07XG4gICAgICAgIGNvbnN0IHBpeGVsUmF0aW8gPSBmcmFtZVN0YXRlLnBpeGVsUmF0aW87XG4gICAgICAgIGNvbnN0IHNpemUgPSBmcmFtZVN0YXRlLnNpemU7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5yb3VuZChzaXplWzBdICogcGl4ZWxSYXRpbyk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGgucm91bmQoc2l6ZVsxXSAqIHBpeGVsUmF0aW8pO1xuICAgICAgICBjb25zdCBvcGFjaXR5ID0gbGF5ZXJTdGF0ZS5vcGFjaXR5O1xuXG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUub3BhY2l0eSA9IGAke29wYWNpdHl9YDtcblxuICAgICAgICBjb25zdCBwaXgyY2FudiA9IFtcbiAgICAgICAgICAgIFsxLiAvICAodGhpcy5jYW52YXMud2lkdGggLyAyKSwgIDAuLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAuIF0sXG4gICAgICAgICAgICBbMCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtMS4gLyAodGhpcy5jYW52YXMuaGVpZ2h0IC8gMiksICAwLiBdLFxuICAgICAgICAgICAgWy0xLiwgICAgICAgICAgICAgICAgICAgICAgICAgICAgMS4sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMS4gXVxuICAgICAgICBdO1xuICAgICAgICB0aGlzLnNoYWRlci51cGRhdGVVbmlmb3JtRGF0YSh0aGlzLmdsLCAndV9waXgyY2FudicsIGZsYXR0ZW5SZWN1cnNpdmUocGl4MmNhbnYpKTtcbiAgICAgICAgLy8gdGhpcy5pbnRlcnBvbGF0aW9uU2hhZGVyLmJpbmQodGhpcy5nbCk7IDwtLSBub3QgcmVxdWlyZWQ6IGFscmVhZHkgaGFwcGVucyBpbiBgcHJlcGFyZUZyYW1lYFxuICAgIH1cbn1cbiJdfQ==