import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { Layer, RasterLayer } from './types/Layers';
import { LayerGroup } from './types/LayerGroup';
import * as i0 from "@angular/core";
export class LayersService {
    constructor() {
        this.store = new BehaviorSubject(Array());
        this.baseLayers = new BehaviorSubject(Array());
        this.overlays = new BehaviorSubject(Array());
        this.layers = new BehaviorSubject(Array());
    }
    // ----------------------------------------------------------------------------------------------------------------
    /**
     * Adds a ukis Layer to the Layerservice Store
     * filtertype: TFiltertypes
     * if filtertype is not provided the filtertype of the Layer is used!
     *
     * if toGroup is true the layer is not added to the list of Layers and storeItems. Only used  internally.
     */
    addLayer(layer, filtertype, toGroup) {
        if (!this.isInLayergroups(layer)) {
            if (!filtertype) {
                filtertype = layer.filtertype;
            }
            else {
                // set filtertype of Layer!!
                layer.filtertype = filtertype;
            }
            const storeItems = this.store.getValue();
            if (toGroup) {
                this.filterFiltertype(filtertype);
            }
            else {
                storeItems.push(layer);
                this.store.next(storeItems);
                this.filterFiltertype(filtertype);
            }
        }
        else {
            console.error(`layer or Group with id: ${layer.id} already exists!`);
        }
    }
    /**
     * Removes a ukis Layer from the Layerservice Store
     * filtertype: TFiltertypes
     * if filtertype is not provided the filtertype of the Layer is used!
     *
     * force = true - removes a LayerGroup even it is not removable
     */
    removeLayer(layer, filtertype, force) {
        if (this.isInLayergroups(layer)) {
            if (force) {
                console.log(`layer: ${layer.id} is removed with force!`);
                this._removeLayer(layer, filtertype);
            }
            else {
                if (layer.removable) {
                    this._removeLayer(layer, filtertype);
                }
                else if (!layer.removable) {
                    console.log(`layer: ${layer.id} is not removable!`);
                }
            }
        }
        else {
            console.error(`layer with id: ${layer.id} not in storeItems!`);
        }
    }
    _removeLayer(layer, filtertype) {
        if (!filtertype) {
            filtertype = layer.filtertype;
        }
        else {
            if (filtertype !== layer.filtertype) {
                console.error(`the layer with id: ${layer.id} you want to remove from ${filtertype} is from filtertype: ${layer.filtertype}`);
            }
        }
        // console.log('remove single layer from storeItems!!!!!');
        const storeItems = this.store.getValue().filter((lg) => {
            if (lg instanceof Layer) {
                return lg.id !== layer.id;
            }
            else {
                return lg;
            }
        });
        this.store.next(storeItems);
        this.filterFiltertype(filtertype);
    }
    /**
     * Updates a ukis Layer in the Layerservice Store
     * filtertype: TFiltertypes
     * if filtertype is not provided the filtertype of the Layer is used!
     */
    updateLayer(layer, filtertype) {
        if (this.isInLayergroups(layer)) {
            if (!filtertype) {
                filtertype = layer.filtertype;
            }
            else {
                if (filtertype !== layer.filtertype) {
                    console.error(`the layer with id: ${layer.id} you want to update is from filtertype: ${layer.filtertype} and not from ${filtertype} `);
                }
            }
            if (layer.filtertype === 'Overlays') {
                this.updateLayerOrGroupInStore(layer);
                this.filterFiltertype(layer.filtertype);
            }
            if (layer.filtertype === 'Layers') {
                this.updateLayerOrGroupInStore(layer);
                this.filterFiltertype(layer.filtertype);
            }
            if (layer.filtertype === 'Baselayers') {
                this.updateLayerOrGroupInStore(layer);
                this.filterFiltertype(layer.filtertype);
            }
        }
        else {
            console.error(`layer with id: ${layer.id} you want to update not in storeItems!`);
        }
    }
    updateLayerOrGroupInStore(layerOrGroup) {
        this.store.getValue().filter((lg, index, array) => {
            // check if both from the same type then check same id
            if (lg instanceof Layer && layerOrGroup instanceof Layer) {
                if (lg.id === layerOrGroup.id) {
                    array[index] = layerOrGroup;
                    this.store.next(array);
                }
            }
            else if (lg instanceof LayerGroup && layerOrGroup instanceof LayerGroup) {
                if (lg.id === layerOrGroup.id) {
                    array[index] = layerOrGroup;
                    this.store.next(array);
                }
            }
        });
    }
    /**
     * Removes a ukis Layer or a LayerGroup from the Layerservice Store by the Layer.id or LayerGroup.id
     * if removeNullGroup is set, then it removes the LayerGroup if no layer is in there
     *
     * force = true - removes a LayerGroup even it is not removable
     */
    removeLayerOrGroupById(id, removeNullGroup, force) {
        this.store.getValue().filter((lg) => {
            if (lg instanceof Layer) {
                if (lg.id === id) {
                    this.removeLayer(lg, lg.filtertype || 'Layers', force);
                }
            }
            else if (lg instanceof LayerGroup) {
                // console.log('LayerGroup: ', lg);
                // console.log('id', id);
                if (lg.id === id) {
                    this.removeLayerGroup(lg, force);
                }
                else {
                    // this.removeLayerFromGroup
                    lg.layers.forEach((layer) => {
                        if (layer.id === id) {
                            this.removeLayerFromGroup(layer, lg, removeNullGroup, force);
                        }
                    });
                }
            }
        });
    }
    /**
     * Adds a ukis Layer to a LayerGroup in the Layerservice Store by providing the Layer and LayerGroup
     */
    addLayerToGroup(layer, layerGroup) {
        if (!this.isInLayergroups(layer)) {
            // convert filtertyle of layer to the same as the group
            if (layer.filtertype !== layerGroup.filtertype) {
                layer.filtertype = layerGroup.filtertype;
            }
            if (!this.isInLayergroups(layer, [layerGroup])) {
                layerGroup.layers.push(layer);
                this.updateLayerGroup(layerGroup);
            }
            else {
                // throw new Error(`layer or Group with id: ${id} already exists!`);
                console.error(`layer with id: ${layer.id} already exists in ${layerGroup.id}!`, layerGroup);
            }
        }
        else {
            // throw new Error(`layer or Group with id: ${id} already exists!`);
            console.error(`layer with id: ${layer.id} already exists!`);
        }
    }
    /**
     * Adds a ukis Layer to a LayerGroup in the Layerservice Store by providing the Layer and LayerGroup.id
     */
    addLayerToGroupById(layer, GroupId) {
        this.store.getValue().forEach((lg) => {
            if (lg instanceof LayerGroup && lg.id === GroupId) {
                this.addLayerToGroup(layer, lg);
            }
        });
    }
    /**
     * Removes a Layer from a LayerGroup in the Layerservice Store
     * By default if no layers on the group it will remove it - change this through set removeNullGroup to false
     *
     * force = true - removes the Layer even it is not removable
     */
    removeLayerFromGroup(layer, layergroup, removeNullGroup = true, force) {
        layergroup.layers = layergroup.layers.filter(l => l.id !== layer.id);
        this.updateLayerGroup(layergroup);
        this.filterFiltertype(layer.filtertype);
        // if no layers on the group remove it
        if (layergroup.layers.length === 0 && removeNullGroup) {
            this.removeLayerGroup(layergroup, force);
        }
    }
    /**
     * Set the Layer Index in the Array of Layers in a LayerGroup
     * down == + 1 and up == - 1
     */
    setLayerIndexInGroup(layer, dir, layerGroup) {
        // console.log("move layer in group " + dir);
        // console.log(layerGroup);
        const groupIndex = layerGroup.layers.indexOf(layer);
        switch (dir) {
            case 'up': {
                if (groupIndex === 0) {
                    break;
                }
                else {
                    this.arrayMove(layerGroup.layers, groupIndex, groupIndex - 1);
                }
                break;
            }
            case 'down': {
                if (groupIndex === layerGroup.layers.length - 1) {
                    break;
                }
                else {
                    this.arrayMove(layerGroup.layers, groupIndex, groupIndex + 1);
                }
                break;
            }
        }
        this.updateLayer(layer, layerGroup.filtertype || 'Layers');
    }
    // ----------------------------------------------------------------------------------------------------------------
    /**
     * Adds a ukis LayerGroup to the Layerservice Store
     * filtertype: TFiltertypes
     * if filtertype is not provided the filtertype of the LayerGroup is used
     * All the Layers of the Group are set to filtertype of the Group
     */
    addLayerGroup(layergroup, filtertype) {
        if (!this.isInLayergroups(layergroup)) {
            if (!filtertype) {
                filtertype = layergroup.filtertype;
            }
            else {
                // set filtertype of Group!!
                layergroup.filtertype = filtertype;
            }
            const storeItems = this.store.getValue();
            // remove layers from group with the same id as the group!
            if (this.isInLayergroups(layergroup, layergroup.layers)) {
                layergroup.layers = layergroup.layers.filter(l => l.id !== layergroup.id);
            }
            // set filtertype of group to layers
            layergroup.layers = layergroup.layers.map(l => { l.filtertype = layergroup.filtertype; return l; });
            storeItems.push(layergroup);
            this.store.next(storeItems);
            // update to set visible
            this.updateLayerGroup(layergroup);
        }
    }
    /**
     * Removes a ukis LayerGroup to the Layerservice Store
     * force = true - removes a LayerGroup even it is not removable
     */
    removeLayerGroup(layergroup, force) {
        if (this.isInLayergroups(layergroup)) {
            if (force) {
                console.log(`layerGroup: ${layergroup.id} is removed with force!`);
                this._removeLayerGroup(layergroup);
            }
            else {
                if (layergroup.removable) {
                    this._removeLayerGroup(layergroup);
                }
                else if (!layergroup.removable) {
                    console.log(`layerGroup: ${layergroup.id} is not removable!`);
                }
            }
        }
        else {
            console.error(`layer or Group with id: ${layergroup.id} not in storeItems!`);
        }
    }
    _removeLayerGroup(layergroup) {
        for (const layer of layergroup.layers) {
            this.removeLayerFromGroup(layer, layergroup);
        }
        const storeItems = this.store.getValue();
        const filteredGroups = storeItems.filter(function (layer, index) {
            return layer.id !== layergroup.id;
        });
        this.store.next(filteredGroups);
    }
    /**
     * Updates a ukis LayerGroup to the Layerservice Store
     * if sort is set to true the layers of the Group are sort so vectors are above the rasterlayers
     */
    updateLayerGroup(layerGroup, sort = false) {
        if (sort) {
            layerGroup = this.sortLayerGroup(layerGroup);
        }
        this.updateLayerOrGroupInStore(layerGroup);
        for (const layer of layerGroup.layers) {
            /** TODO: this triggers a change for every layer efen if no attributes of the layer are changed!!
             * To check if layer is changed we have to check all attributes, also objects e.g. CustomLayer... this is complicated??
             */
            this.updateLayer(layer, layerGroup.filtertype || 'Layers');
        }
    }
    /**
     * Moves a Item in an Array to another Index
     */
    arrayMove(array, fromIndex, toIndex) {
        array.splice((toIndex < 0 ? array.length + toIndex : toIndex), 0, array.splice(fromIndex, 1)[0]);
    }
    /**
     * Set Group Or Layer Index in the Layerservice Store
     * down == index + 1 and up == index - 1
     */
    setGroupLayerIndex(group, dir) {
        let groupsCount;
        if (group instanceof Layer && group.filtertype) {
            groupsCount = this.getNumOfGroups(group.filtertype);
        }
        else if (group instanceof LayerGroup) {
            groupsCount = this.getNumOfGroups(group.filtertype);
        }
        if (groupsCount > 1) {
            const storeItems = this.store.getValue();
            const groupIndex = storeItems.indexOf(group);
            if (!this.isGroupFirst(group) || !this.isGroupLast(group)) {
                if (typeof dir === 'number') {
                    this.arrayMove(storeItems, groupIndex, dir);
                }
                else if (dir === 'up') {
                    this.arrayMove(storeItems, groupIndex, groupIndex - 1);
                }
                else if (dir === 'down') {
                    this.arrayMove(storeItems, groupIndex, groupIndex + 1);
                }
            }
            // console.log('groupIndex after', group.name, lgroups.indexOf(group));
            this.store.next(storeItems);
            this.baseLayers.next(this.filterBaseLayers());
            this.layers.next(this.filterLayers());
            this.overlays.next(this.filterOverlays());
        }
    }
    /**
     * Get the Number of Items from Layerservice Store filtered by filtertype
     * filtertype: TFiltertypes
     */
    getNumOfGroups(filtertype) {
        let num = 0;
        const storeItems = this.store.getValue();
        for (const lg of storeItems) {
            if (lg.filtertype === filtertype) {
                // console.log(lg.type, type)
                num++;
            }
        }
        return num;
    }
    /**
     * Check if a Layer or LayerGroup is on index 0 of the Layerservice Store or the provided Array
     * if filtertype is set it only uses the items with this type
     * filtertype?: TFiltertypes
     */
    isGroupFirst(group, lgroups, filtertype) {
        let value = false;
        let storeItems = this.store.getValue();
        if (lgroups) {
            storeItems = lgroups;
        }
        if (filtertype) {
            storeItems = storeItems.filter(l => l.filtertype === filtertype);
        }
        if (storeItems.indexOf(group) === 0) {
            // console.log(group.name, 'isFirst')
            value = true;
        }
        return value;
    }
    /**
     * Check if a Layer or LayerGroup is on index (length - 1) of the Layerservice Store or the provided Array
     * if filtertype is set it only uses the items with this type
     * filtertype?: TFiltertypes
     */
    isGroupLast(group, lgroups, filtertype) {
        let value = false;
        let storeItems = this.store.getValue();
        if (lgroups) {
            storeItems = lgroups;
        }
        if (filtertype) {
            storeItems = storeItems.filter(l => l.filtertype === filtertype);
        }
        if (storeItems.indexOf(group) === storeItems.length - 1) {
            value = true;
        }
        return value;
    }
    // ----------------------------------------------------------------------------------------------------------------
    /**
     * Check if a Layer or LayerGroup is in the Layerservice Store (or the provided Array) by their ID
     */
    isInLayergroups(layergroup, groups) {
        let value = false;
        let id;
        if (layergroup instanceof Layer || layergroup instanceof LayerGroup) {
            id = layergroup.id;
        }
        else {
            id = layergroup;
        }
        const items = this.getLayerOrGroupById(id, groups);
        if (items && items instanceof Layer || items instanceof LayerGroup) {
            value = true;
        }
        return value;
    }
    /**
     * Get a Layer or LayerGroup by ID from the Layerservice Store (or the provided Array)
     * normal there should only be returned one or zero items in the array otherwise there is a duplicate ID in the Layer Groups!!
     */
    getLayerOrGroupById(id, groups) {
        const items = [];
        let storeItems = this.store.getValue();
        if (groups) {
            storeItems = groups;
        }
        storeItems.map(group => {
            if (group instanceof LayerGroup) {
                if (group.id === id) {
                    items.push(group);
                }
                else {
                    group.layers.map(layer => {
                        if (layer.id === id) {
                            items.push(layer);
                        }
                    });
                }
            }
            else if (group instanceof Layer) {
                if (group.id === id) {
                    items.push(group);
                }
            }
        });
        if (!items.length) {
            return null;
        }
        else if (items.length === 1) {
            return items[0];
        }
        else if (items.length > 1) {
            console.log('there is a duplicate ID in the Layer Groups!');
        }
    }
    /**
     * Get a Layer by ID from the Layerservice Store (or the provided Array)
     */
    getLayerById(id, layers) {
        let value;
        let flatlayers = this.flattenDeepArray(this.store.getValue());
        if (layers) {
            flatlayers = layers;
        }
        flatlayers.map(layer => {
            if (layer.id === id) {
                value = layer;
            }
        });
        return value;
    }
    /**
     * Get all Layers with filterrype 'Baselayers' from the Layerservice Store
     */
    getBaseLayers() {
        return this.baseLayers.asObservable();
    }
    /**
     * Removes Layers with filtertype 'Baselayers' from the Layerservice Store
     * Filter is a function to exclude layers
     */
    removeBaseLayers(filter) {
        let baselayers = this.filterBaseLayers();
        if (filter) {
            baselayers = baselayers.filter(filter);
        }
        baselayers.forEach((ol) => {
            this.removeLayerOrGroupById(ol.id);
        });
        return this.baseLayers.asObservable();
    }
    getBaseLayersCount() {
        return this.baseLayers.getValue().length;
    }
    /**
     * Get all Layers with filterrype 'Overlays' from the Layerservice Store
     */
    getOverlays() {
        return this.overlays.asObservable();
    }
    /**
     * Removes Layers with filtertype 'Overlays' from the Layerservice Store
     * Filter is a function to exclude layers
     */
    removeOverlays(filter) {
        let overlays = this.filterOverlays();
        if (filter) {
            overlays = overlays.filter(filter);
        }
        overlays.forEach((ol) => {
            this.removeLayerOrGroupById(ol.id);
        });
        return this.overlays.asObservable();
    }
    getOverlaysCount() {
        return this.overlays.getValue().length;
    }
    /**
     * Get all Layers with filterrype 'Layers' from the Layerservice Store
     *
     * #### to filter the Observable only on some layer property changes use rxjs filter e.g. see below:
     * this.layersSub = this.layerSvc.getLayers().pipe(filter(layers => {
     *   const newVisible = layers.map(l => l.visible).filter(v => v === true).length;
     *  // subscribe if visible of a layer has changed
     *  if (newVisible !== this.oldVisibleLayers) {
     *     return true;
     *  } else {
     *     // subscribe only to remove, add layers
     *     if (this.layers && this.layers.length !== layers.length) {
     *       return true;
     *    } else {
     *       return false;
     *    }
     *  }
     * })).subscribe(layers => {
     *   this.layers = layers;
     *   this.oldVisibleLayers = this.layers.map(l => l.visible).filter(v => v === true).length;
     * });
     */
    getLayers() {
        return this.layers.asObservable();
    }
    /**
     * Removes Layers with filtertype 'Layers' from the Layerservice Store
     * Filter is a function to exclude layers
     */
    removeLayers(filter) {
        let layers = this.filterLayers();
        if (filter) {
            layers = layers.filter(filter);
        }
        layers.forEach((ol) => {
            this.removeLayerOrGroupById(ol.id);
        });
        return this.layers.asObservable();
    }
    getLayersCount() {
        return this.layers.getValue().length;
    }
    /**
     * Get all storeItems from the Layerservice
     */
    getLayerGroups() {
        return this.store.asObservable();
    }
    /**
     * Set (Reset) all storeItems from the Layerservice
     * if filtertype is set then only the slot is used
     */
    setLayerGroups(items, filtertype) {
        // set filtertype of group to layers
        if (items.length > 0) {
            items.map(group => {
                if (group instanceof LayerGroup && group.layers.length > 0) {
                    group.layers = group.layers.map(l => { l.filtertype = group.filtertype; return l; });
                }
            });
        }
        if (!filtertype) {
            this.store.next(items);
            this.baseLayers.next(this.filterBaseLayers());
            this.layers.next(this.filterLayers());
            this.overlays.next(this.filterOverlays());
        }
        else {
            if (filtertype === 'Baselayers') {
                this.removeBaseLayers();
            }
            else if (filtertype === 'Layers') {
                this.removeLayers();
            }
            else if (filtertype === 'Overlays') {
                this.removeOverlays();
            }
            items.map(lg => {
                if (lg instanceof Layer) {
                    this.addLayer(lg, filtertype);
                }
                else if (lg instanceof LayerGroup) {
                    this.addLayerGroup(lg, filtertype);
                }
            });
        }
        return this.store.asObservable();
    }
    /**
     * Get the Count of all storeItems
     */
    getLayerGroupsCount() {
        return this.store.getValue().length;
    }
    // ----------------------------------------------------------------------------------------------------------------
    /**
     * flatten array with Layers and LayerGroups.layers (so you can get the zIndex)
     */
    flattenDeepArray(arr) {
        return arr.reduce((acc, val) => (val instanceof LayerGroup && Array.isArray(val.layers)) ? acc.concat(this.flattenDeepArray(val.layers)) : acc.concat(val), []);
    }
    /*
    getZIndexForLayer(layer: Layer): number {
      let zIndex = null;
      const baselayers = this.baseLayers.getValue();
      const layers = this.layers.getValue();
      const overlays = this.overlays.getValue();
      let arr = [];
  
      if (layer.filtertype === 'Overlays') {
        arr = arr.concat(baselayers).concat(layers).concat(overlays);
        zIndex = arr.indexOf(layer);
      } else if (layer.filtertype === 'Layers') {
        arr = arr.concat(baselayers).concat(layers);
        zIndex = arr.indexOf(layer);
      } else if (layer.filtertype === 'Baselayers') {
        arr = arr.concat(baselayers);
        zIndex = arr.indexOf(layer);
      }
      return zIndex;
    }
    */
    filterOverlays() {
        const storeItems = this.store.getValue();
        const overlays = this.flattenDeepArray(storeItems.filter((layer) => layer.filtertype === 'Overlays'));
        return overlays;
    }
    filterBaseLayers() {
        const storeItems = this.store.getValue();
        const baselayers = this.flattenDeepArray(storeItems.filter((layer) => layer.filtertype === 'Baselayers'));
        return baselayers;
    }
    filterLayers() {
        const storeItems = this.store.getValue();
        const baselayers = this.flattenDeepArray(storeItems.filter((layer) => layer.filtertype === 'Layers'));
        return baselayers;
    }
    filterFiltertype(filtertype) {
        if (filtertype === 'Baselayers') {
            this.baseLayers.next(this.filterBaseLayers());
        }
        else if (filtertype === 'Overlays') {
            this.overlays.next(this.filterOverlays());
        }
        else if (filtertype === 'Layers') {
            this.layers.next(this.filterLayers());
        }
    }
    // ----------------------------------------------------------------------
    sortLayerGroup(layerGroup) {
        // fisrt sort in order to put vectors first and then rasterlayers
        layerGroup.layers.sort((a, b) => {
            let comparison = 0;
            if (a instanceof RasterLayer) {
                comparison = 1;
            }
            else if (b instanceof RasterLayer) {
                comparison = -1;
            }
            return comparison;
        });
        return layerGroup;
    }
}
LayersService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: LayersService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
LayersService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: LayersService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: LayersService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return []; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGF5ZXJzLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9zZXJ2aWNlcy1sYXllcnMvc3JjL2xpYi9sYXllcnMuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBRSxlQUFlLEVBQWMsTUFBTSxNQUFNLENBQUM7QUFDbkQsT0FBTyxFQUFFLEtBQUssRUFBRSxXQUFXLEVBQWdCLE1BQU0sZ0JBQWdCLENBQUM7QUFDbEUsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLG9CQUFvQixDQUFDOztBQUtoRCxNQUFNLE9BQU8sYUFBYTtJQVN4QjtRQVJRLFVBQUssR0FBRyxJQUFJLGVBQWUsQ0FBQyxLQUFLLEVBQXNCLENBQUMsQ0FBQztRQUV6RCxlQUFVLEdBQUcsSUFBSSxlQUFlLENBQUMsS0FBSyxFQUFTLENBQUMsQ0FBQztRQUVqRCxhQUFRLEdBQUcsSUFBSSxlQUFlLENBQUMsS0FBSyxFQUFTLENBQUMsQ0FBQztRQUUvQyxXQUFNLEdBQUcsSUFBSSxlQUFlLENBQUMsS0FBSyxFQUFTLENBQUMsQ0FBQztJQUlyRCxDQUFDO0lBR0QsbUhBQW1IO0lBQ25IOzs7Ozs7T0FNRztJQUNJLFFBQVEsQ0FBQyxLQUFZLEVBQUUsVUFBeUIsRUFBRSxPQUFpQjtRQUN4RSxJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUVoQyxJQUFJLENBQUMsVUFBVSxFQUFFO2dCQUNmLFVBQVUsR0FBRyxLQUFLLENBQUMsVUFBVSxDQUFDO2FBQy9CO2lCQUFNO2dCQUNMLDRCQUE0QjtnQkFDNUIsS0FBSyxDQUFDLFVBQVUsR0FBRyxVQUFVLENBQUM7YUFDL0I7WUFFRCxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBRXpDLElBQUksT0FBTyxF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WSxXQUFXLEVBQUU7Z0JBQzVCLFVBQVUsR0FBRyxDQUFDLENBQUM7YUFDaEI7aUJBQU0sSUFBSSxDQUFDLFlBQVksV0FBVyxFQUFFO2dCQUNuQyxVQUFVLEdBQUcsQ0FBQyxDQUFDLENBQUM7YUFDakI7WUFDRCxPQUFPLFVBQVUsQ0FBQztRQUNwQixDQUFDLENBQUMsQ0FBQztRQUNILE9BQU8sVUFBVSxDQUFDO0lBQ3BCLENBQUM7OzBHQWx1QlUsYUFBYTs4R0FBYixhQUFhLGNBRlosTUFBTTsyRkFFUCxhQUFhO2tCQUh6QixVQUFVO21CQUFDO29CQUNWLFVBQVUsRUFBRSxNQUFNO2lCQUNuQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCwgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgTGF5ZXIsIFJhc3RlckxheWVyLCBURmlsdGVydHlwZXMgfSBmcm9tICcuL3R5cGVzL0xheWVycyc7XG5pbXBvcnQgeyBMYXllckdyb3VwIH0gZnJvbSAnLi90eXBlcy9MYXllckdyb3VwJztcblxuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCdcbn0pXG5leHBvcnQgY2xhc3MgTGF5ZXJzU2VydmljZSB7XG4gIHByaXZhdGUgc3RvcmUgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KEFycmF5PExheWVyIHwgTGF5ZXJHcm91cD4oKSk7XG5cbiAgcHJpdmF0ZSBiYXNlTGF5ZXJzID0gbmV3IEJlaGF2aW9yU3ViamVjdChBcnJheTxMYXllcj4oKSk7XG5cbiAgcHJpdmF0ZSBvdmVybGF5cyA9IG5ldyBCZWhhdmlvclN1YmplY3QoQXJyYXk8TGF5ZXI+KCkpO1xuXG4gIHByaXZhdGUgbGF5ZXJzID0gbmV3IEJlaGF2aW9yU3ViamVjdChBcnJheTxMYXllcj4oKSk7XG5cbiAgY29uc3RydWN0b3IoKSB7XG5cbiAgfVxuXG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvKipcbiAgICogQWRkcyBhIHVraXMgTGF5ZXIgdG8gdGhlIExheWVyc2VydmljZSBTdG9yZVxuICAgKiBmaWx0ZXJ0eXBlOiBURmlsdGVydHlwZXNcbiAgICogaWYgZmlsdGVydHlwZSBpcyBub3QgcHJvdmlkZWQgdGhlIGZpbHRlcnR5cGUgb2YgdGhlIExheWVyIGlzIHVzZWQhXG4gICAqXG4gICAqIGlmIHRvR3JvdXAgaXMgdHJ1ZSB0aGUgbGF5ZXIgaXMgbm90IGFkZGVkIHRvIHRoZSBsaXN0IG9mIExheWVycyBhbmQgc3RvcmVJdGVtcy4gT25seSB1c2VkICBpbnRlcm5hbGx5LlxuICAgKi9cbiAgcHVibGljIGFkZExheWVyKGxheWVyOiBMYXllciwgZmlsdGVydHlwZT86IFRGaWx0ZXJ0eXBlcywgdG9Hcm91cD86IGJvb2xlYW4pIHtcbiAgICBpZiAoIXRoaXMuaXNJbkxheWVyZ3JvdXBzKGxheWVyKSkge1xuXG4gICAgICBpZiAoIWZpbHRlcnR5cGUpIHtcbiAgICAgICAgZmlsdGVydHlwZSA9IGxheWVyLmZpbHRlcnR5cGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzZXQgZmlsdGVydHlwZSBvZiBMYXllciEhXG4gICAgICAgIGxheWVyLmZpbHRlcnR5cGUgPSBmaWx0ZXJ0eXBlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzdG9yZUl0ZW1zID0gdGhpcy5zdG9yZS5nZXRWYWx1ZSgpO1xuXG4gICAgICBpZiAodG9Hcm91cCkge1xuICAgICAgICB0aGlzLmZpbHRlckZpbHRlcnR5cGUoZmlsdGVydHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdG9yZUl0ZW1zLnB1c2gobGF5ZXIpO1xuXG4gICAgICAgIHRoaXMuc3RvcmUubmV4dChzdG9yZUl0ZW1zKTtcbiAgICAgICAgdGhpcy5maWx0ZXJGaWx0ZXJ0eXBlKGZpbHRlcnR5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBsYXllciBvciBHcm91cCB3aXRoIGlkOiAke2xheWVyLmlkfSBhbHJlYWR5IGV4aXN0cyFgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIHVraXMgTGF5ZXIgZnJvbSB0aGUgTGF5ZXJzZXJ2aWNlIFN0b3JlXG4gICAqIGZpbHRlcnR5cGU6IFRGaWx0ZXJ0eXBlc1xuICAgKiBpZiBmaWx0ZXJ0eXBlIGlzIG5vdCBwcm92aWRlZCB0aGUgZmlsdGVydHlwZSBvZiB0aGUgTGF5ZXIgaXMgdXNlZCFcbiAgICpcbiAgICogZm9yY2UgPSB0cnVlIC0gcmVtb3ZlcyBhIExheWVyR3JvdXAgZXZlbiBpdCBpcyBub3QgcmVtb3ZhYmxlXG4gICAqL1xuICBwdWJsaWMgcmVtb3ZlTGF5ZXIobGF5ZXI6IExheWVyLCBmaWx0ZXJ0eXBlPzogVEZpbHRlcnR5cGVzLCBmb3JjZT86IGJvb2xlYW4pIHtcbiAgICBpZiAodGhpcy5pc0luTGF5ZXJncm91cHMobGF5ZXIpKSB7XG4gICAgICBpZiAoZm9yY2UpIHtcbiAgICAgICAgY29uc29sZS5sb2coYGxheWVyOiAke2xheWVyLmlkfSBpcyByZW1vdmVkIHdpdGggZm9yY2UhYCk7XG4gICAgICAgIHRoaXMuX3JlbW92ZUxheWVyKGxheWVyLCBmaWx0ZXJ0eXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChsYXllci5yZW1vdmFibGUpIHtcbiAgICAgICAgICB0aGlzLl9yZW1vdmVMYXllcihsYXllciwgZmlsdGVydHlwZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWxheWVyLnJlbW92YWJsZSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBsYXllcjogJHtsYXllci5pZH0gaXMgbm90IHJlbW92YWJsZSFgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBsYXllciB3aXRoIGlkOiAke2xheWVyLmlkfSBub3QgaW4gc3RvcmVJdGVtcyFgKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9yZW1vdmVMYXllcihsYXllcjogTGF5ZXIsIGZpbHRlcnR5cGU/OiBURmlsdGVydHlwZXMpIHtcbiAgICBpZiAoIWZpbHRlcnR5cGUpIHtcbiAgICAgIGZpbHRlcnR5cGUgPSBsYXllci5maWx0ZXJ0eXBlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZmlsdGVydHlwZSAhPT0gbGF5ZXIuZmlsdGVydHlwZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGB0aGUgbGF5ZXIgd2l0aCBpZDogJHtsYXllci5pZH0geW91IHdhbnQgdG8gcmVtb3ZlIGZyb20gJHtmaWx0ZXJ0eXBlfSBpcyBmcm9tIGZpbHRlcnR5cGU6ICR7bGF5ZXIuZmlsdGVydHlwZX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb25zb2xlLmxvZygncmVtb3ZlIHNpbmdsZSBsYXllciBmcm9tIHN0b3JlSXRlbXMhISEhIScpO1xuICAgIGNvbnN0IHN0b3JlSXRlbXMgPSB0aGlzLnN0b3JlLmdldFZhbHVlKCkuZmlsdGVyKChsZykgPT4ge1xuICAgICAgaWYgKGxnIGluc3RhbmNlb2YgTGF5ZXIpIHtcbiAgICAgICAgcmV0dXJuIGxnLmlkICE9PSBsYXllci5pZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBsZztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnN0b3JlLm5leHQoc3RvcmVJdGVtcyk7XG4gICAgdGhpcy5maWx0ZXJGaWx0ZXJ0eXBlKGZpbHRlcnR5cGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSB1a2lzIExheWVyIGluIHRoZSBMYXllcnNlcnZpY2UgU3RvcmVcbiAgICogZmlsdGVydHlwZTogVEZpbHRlcnR5cGVzXG4gICAqIGlmIGZpbHRlcnR5cGUgaXMgbm90IHByb3ZpZGVkIHRoZSBmaWx0ZXJ0eXBlIG9mIHRoZSBMYXllciBpcyB1c2VkIVxuICAgKi9cbiAgcHVibGljIHVwZGF0ZUxheWVyKGxheWVyOiBMYXllciwgZmlsdGVydHlwZT86IFRGaWx0ZXJ0eXBlcykge1xuICAgIGlmICh0aGlzLmlzSW5MYXllcmdyb3VwcyhsYXllcikpIHtcblxuICAgICAgaWYgKCFmaWx0ZXJ0eXBlKSB7XG4gICAgICAgIGZpbHRlcnR5cGUgPSBsYXllci5maWx0ZXJ0eXBlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZpbHRlcnR5cGUgIT09IGxheWVyLmZpbHRlcnR5cGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGB0aGUgbGF5ZXIgd2l0aCBpZDogJHtsYXllci5pZH0geW91IHdhbnQgdG8gdXBkYXRlIGlzIGZyb20gZmlsdGVydHlwZTogJHtsYXllci5maWx0ZXJ0eXBlfSBhbmQgbm90IGZyb20gJHtmaWx0ZXJ0eXBlfSBgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobGF5ZXIuZmlsdGVydHlwZSA9PT0gJ092ZXJsYXlzJykge1xuICAgICAgICB0aGlzLnVwZGF0ZUxheWVyT3JHcm91cEluU3RvcmUobGF5ZXIpO1xuICAgICAgICB0aGlzLmZpbHRlckZpbHRlcnR5cGUobGF5ZXIuZmlsdGVydHlwZSk7XG4gICAgICB9XG4gICAgICBpZiAobGF5ZXIuZmlsdGVydHlwZSA9PT0gJ0xheWVycycpIHtcbiAgICAgICAgdGhpcy51cGRhdGVMYXllck9yR3JvdXBJblN0b3JlKGxheWVyKTtcbiAgICAgICAgdGhpcy5maWx0ZXJGaWx0ZXJ0eXBlKGxheWVyLmZpbHRlcnR5cGUpO1xuICAgICAgfVxuICAgICAgaWYgKGxheWVyLmZpbHRlcnR5cGUgPT09ICdCYXNlbGF5ZXJzJykge1xuICAgICAgICB0aGlzLnVwZGF0ZUxheWVyT3JHcm91cEluU3RvcmUobGF5ZXIpO1xuICAgICAgICB0aGlzLmZpbHRlckZpbHRlcnR5cGUobGF5ZXIuZmlsdGVydHlwZSk7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcihgbGF5ZXIgd2l0aCBpZDogJHtsYXllci5pZH0geW91IHdhbnQgdG8gdXBkYXRlIG5vdCBpbiBzdG9yZUl0ZW1zIWApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlTGF5ZXJPckdyb3VwSW5TdG9yZShsYXllck9yR3JvdXA6IExheWVyIHwgTGF5ZXJHcm91cCkge1xuICAgIHRoaXMuc3RvcmUuZ2V0VmFsdWUoKS5maWx0ZXIoKGxnLCBpbmRleCwgYXJyYXkpID0+IHtcbiAgICAgIC8vIGNoZWNrIGlmIGJvdGggZnJvbSB0aGUgc2FtZSB0eXBlIHRoZW4gY2hlY2sgc2FtZSBpZFxuICAgICAgaWYgKGxnIGluc3RhbmNlb2YgTGF5ZXIgJiYgbGF5ZXJPckdyb3VwIGluc3RhbmNlb2YgTGF5ZXIpIHtcbiAgICAgICAgaWYgKGxnLmlkID09PSBsYXllck9yR3JvdXAuaWQpIHtcbiAgICAgICAgICBhcnJheVtpbmRleF0gPSBsYXllck9yR3JvdXA7XG4gICAgICAgICAgdGhpcy5zdG9yZS5uZXh0KGFycmF5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsZyBpbnN0YW5jZW9mIExheWVyR3JvdXAgJiYgbGF5ZXJPckdyb3VwIGluc3RhbmNlb2YgTGF5ZXJHcm91cCkge1xuICAgICAgICBpZiAobGcuaWQgPT09IGxheWVyT3JHcm91cC5pZCkge1xuICAgICAgICAgIGFycmF5W2luZGV4XSA9IGxheWVyT3JHcm91cDtcbiAgICAgICAgICB0aGlzLnN0b3JlLm5leHQoYXJyYXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIHVraXMgTGF5ZXIgb3IgYSBMYXllckdyb3VwIGZyb20gdGhlIExheWVyc2VydmljZSBTdG9yZSBieSB0aGUgTGF5ZXIuaWQgb3IgTGF5ZXJHcm91cC5pZFxuICAgKiBpZiByZW1vdmVOdWxsR3JvdXAgaXMgc2V0LCB0aGVuIGl0IHJlbW92ZXMgdGhlIExheWVyR3JvdXAgaWYgbm8gbGF5ZXIgaXMgaW4gdGhlcmVcbiAgICpcbiAgICogZm9yY2UgPSB0cnVlIC0gcmVtb3ZlcyBhIExheWVyR3JvdXAgZXZlbiBpdCBpcyBub3QgcmVtb3ZhYmxlXG4gICAqL1xuICBwdWJsaWMgcmVtb3ZlTGF5ZXJPckdyb3VwQnlJZChpZDogc3RyaW5nLCByZW1vdmVOdWxsR3JvdXA/OiBib29sZWFuLCBmb3JjZT86IGJvb2xlYW4pIHtcbiAgICB0aGlzLnN0b3JlLmdldFZhbHVlKCkuZmlsdGVyKChsZykgPT4ge1xuICAgICAgaWYgKGxnIGluc3RhbmNlb2YgTGF5ZXIpIHtcbiAgICAgICAgaWYgKGxnLmlkID09PSBpZCkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGF5ZXIobGcsIGxnLmZpbHRlcnR5cGUgfHwgJ0xheWVycycsIGZvcmNlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsZyBpbnN0YW5jZW9mIExheWVyR3JvdXApIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0xheWVyR3JvdXA6ICcsIGxnKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2lkJywgaWQpO1xuICAgICAgICBpZiAobGcuaWQgPT09IGlkKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMYXllckdyb3VwKGxnLCBmb3JjZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdGhpcy5yZW1vdmVMYXllckZyb21Hcm91cFxuICAgICAgICAgIGxnLmxheWVycy5mb3JFYWNoKChsYXllcikgPT4ge1xuICAgICAgICAgICAgaWYgKGxheWVyLmlkID09PSBpZCkge1xuICAgICAgICAgICAgICB0aGlzLnJlbW92ZUxheWVyRnJvbUdyb3VwKGxheWVyLCBsZywgcmVtb3ZlTnVsbEdyb3VwLCBmb3JjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgdWtpcyBMYXllciB0byBhIExheWVyR3JvdXAgaW4gdGhlIExheWVyc2VydmljZSBTdG9yZSBieSBwcm92aWRpbmcgdGhlIExheWVyIGFuZCBMYXllckdyb3VwXG4gICAqL1xuICBwdWJsaWMgYWRkTGF5ZXJUb0dyb3VwKGxheWVyOiBMYXllciwgbGF5ZXJHcm91cDogTGF5ZXJHcm91cCkge1xuICAgIGlmICghdGhpcy5pc0luTGF5ZXJncm91cHMobGF5ZXIpKSB7XG4gICAgICAvLyBjb252ZXJ0IGZpbHRlcnR5bGUgb2YgbGF5ZXIgdG8gdGhlIHNhbWUgYXMgdGhlIGdyb3VwXG4gICAgICBpZiAobGF5ZXIuZmlsdGVydHlwZSAhPT0gbGF5ZXJHcm91cC5maWx0ZXJ0eXBlKSB7XG4gICAgICAgIGxheWVyLmZpbHRlcnR5cGUgPSBsYXllckdyb3VwLmZpbHRlcnR5cGU7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuaXNJbkxheWVyZ3JvdXBzKGxheWVyLCBbbGF5ZXJHcm91cF0pKSB7XG4gICAgICAgIGxheWVyR3JvdXAubGF5ZXJzLnB1c2gobGF5ZXIpO1xuICAgICAgICB0aGlzLnVwZGF0ZUxheWVyR3JvdXAobGF5ZXJHcm91cCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoYGxheWVyIG9yIEdyb3VwIHdpdGggaWQ6ICR7aWR9IGFscmVhZHkgZXhpc3RzIWApO1xuICAgICAgICBjb25zb2xlLmVycm9yKGBsYXllciB3aXRoIGlkOiAke2xheWVyLmlkfSBhbHJlYWR5IGV4aXN0cyBpbiAke2xheWVyR3JvdXAuaWR9IWAsIGxheWVyR3JvdXApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoYGxheWVyIG9yIEdyb3VwIHdpdGggaWQ6ICR7aWR9IGFscmVhZHkgZXhpc3RzIWApO1xuICAgICAgY29uc29sZS5lcnJvcihgbGF5ZXIgd2l0aCBpZDogJHtsYXllci5pZH0gYWxyZWFkeSBleGlzdHMhYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSB1a2lzIExheWVyIHRvIGEgTGF5ZXJHcm91cCBpbiB0aGUgTGF5ZXJzZXJ2aWNlIFN0b3JlIGJ5IHByb3ZpZGluZyB0aGUgTGF5ZXIgYW5kIExheWVyR3JvdXAuaWRcbiAgICovXG4gIHB1YmxpYyBhZGRMYXllclRvR3JvdXBCeUlkKGxheWVyOiBMYXllciwgR3JvdXBJZDogc3RyaW5nKSB7XG4gICAgdGhpcy5zdG9yZS5nZXRWYWx1ZSgpLmZvckVhY2goKGxnKSA9PiB7XG4gICAgICBpZiAobGcgaW5zdGFuY2VvZiBMYXllckdyb3VwICYmIGxnLmlkID09PSBHcm91cElkKSB7XG4gICAgICAgIHRoaXMuYWRkTGF5ZXJUb0dyb3VwKGxheWVyLCBsZyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIExheWVyIGZyb20gYSBMYXllckdyb3VwIGluIHRoZSBMYXllcnNlcnZpY2UgU3RvcmVcbiAgICogQnkgZGVmYXVsdCBpZiBubyBsYXllcnMgb24gdGhlIGdyb3VwIGl0IHdpbGwgcmVtb3ZlIGl0IC0gY2hhbmdlIHRoaXMgdGhyb3VnaCBzZXQgcmVtb3ZlTnVsbEdyb3VwIHRvIGZhbHNlXG4gICAqXG4gICAqIGZvcmNlID0gdHJ1ZSAtIHJlbW92ZXMgdGhlIExheWVyIGV2ZW4gaXQgaXMgbm90IHJlbW92YWJsZVxuICAgKi9cbiAgcHVibGljIHJlbW92ZUxheWVyRnJvbUdyb3VwKGxheWVyOiBMYXllciwgbGF5ZXJncm91cDogTGF5ZXJHcm91cCwgcmVtb3ZlTnVsbEdyb3VwOiBib29sZWFuID0gdHJ1ZSwgZm9yY2U/OiBib29sZWFuKSB7XG4gICAgbGF5ZXJncm91cC5sYXllcnMgPSBsYXllcmdyb3VwLmxheWVycy5maWx0ZXIobCA9PiBsLmlkICE9PSBsYXllci5pZCk7XG4gICAgdGhpcy51cGRhdGVMYXllckdyb3VwKGxheWVyZ3JvdXApO1xuICAgIHRoaXMuZmlsdGVyRmlsdGVydHlwZShsYXllci5maWx0ZXJ0eXBlKTtcblxuICAgIC8vIGlmIG5vIGxheWVycyBvbiB0aGUgZ3JvdXAgcmVtb3ZlIGl0XG4gICAgaWYgKGxheWVyZ3JvdXAubGF5ZXJzLmxlbmd0aCA9PT0gMCAmJiByZW1vdmVOdWxsR3JvdXApIHtcbiAgICAgIHRoaXMucmVtb3ZlTGF5ZXJHcm91cChsYXllcmdyb3VwLCBmb3JjZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgTGF5ZXIgSW5kZXggaW4gdGhlIEFycmF5IG9mIExheWVycyBpbiBhIExheWVyR3JvdXBcbiAgICogZG93biA9PSArIDEgYW5kIHVwID09IC0gMVxuICAgKi9cbiAgcHVibGljIHNldExheWVySW5kZXhJbkdyb3VwKGxheWVyOiBMYXllciwgZGlyOiAndXAnIHwgJ2Rvd24nLCBsYXllckdyb3VwOiBMYXllckdyb3VwKSB7XG4gICAgLy8gY29uc29sZS5sb2coXCJtb3ZlIGxheWVyIGluIGdyb3VwIFwiICsgZGlyKTtcbiAgICAvLyBjb25zb2xlLmxvZyhsYXllckdyb3VwKTtcbiAgICBjb25zdCBncm91cEluZGV4ID0gbGF5ZXJHcm91cC5sYXllcnMuaW5kZXhPZihsYXllcik7XG5cbiAgICBzd2l0Y2ggKGRpcikge1xuICAgICAgY2FzZSAndXAnOiB7XG4gICAgICAgIGlmIChncm91cEluZGV4ID09PSAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5hcnJheU1vdmUobGF5ZXJHcm91cC5sYXllcnMsIGdyb3VwSW5kZXgsIGdyb3VwSW5kZXggLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2Rvd24nOiB7XG4gICAgICAgIGlmIChncm91cEluZGV4ID09PSBsYXllckdyb3VwLmxheWVycy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5hcnJheU1vdmUobGF5ZXJHcm91cC5sYXllcnMsIGdyb3VwSW5kZXgsIGdyb3VwSW5kZXggKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy51cGRhdGVMYXllcihsYXllciwgbGF5ZXJHcm91cC5maWx0ZXJ0eXBlIHx8ICdMYXllcnMnKTtcbiAgfVxuXG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvKipcbiAgICogQWRkcyBhIHVraXMgTGF5ZXJHcm91cCB0byB0aGUgTGF5ZXJzZXJ2aWNlIFN0b3JlXG4gICAqIGZpbHRlcnR5cGU6IFRGaWx0ZXJ0eXBlc1xuICAgKiBpZiBmaWx0ZXJ0eXBlIGlzIG5vdCBwcm92aWRlZCB0aGUgZmlsdGVydHlwZSBvZiB0aGUgTGF5ZXJHcm91cCBpcyB1c2VkXG4gICAqIEFsbCB0aGUgTGF5ZXJzIG9mIHRoZSBHcm91cCBhcmUgc2V0IHRvIGZpbHRlcnR5cGUgb2YgdGhlIEdyb3VwXG4gICAqL1xuICBwdWJsaWMgYWRkTGF5ZXJHcm91cChsYXllcmdyb3VwOiBMYXllckdyb3VwLCBmaWx0ZXJ0eXBlPzogVEZpbHRlcnR5cGVzKSB7XG4gICAgaWYgKCF0aGlzLmlzSW5MYXllcmdyb3VwcyhsYXllcmdyb3VwKSkge1xuXG4gICAgICBpZiAoIWZpbHRlcnR5cGUpIHtcbiAgICAgICAgZmlsdGVydHlwZSA9IGxheWVyZ3JvdXAuZmlsdGVydHlwZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHNldCBmaWx0ZXJ0eXBlIG9mIEdyb3VwISFcbiAgICAgICAgbGF5ZXJncm91cC5maWx0ZXJ0eXBlID0gZmlsdGVydHlwZTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3RvcmVJdGVtcyA9IHRoaXMuc3RvcmUuZ2V0VmFsdWUoKTtcbiAgICAgIC8vIHJlbW92ZSBsYXllcnMgZnJvbSBncm91cCB3aXRoIHRoZSBzYW1lIGlkIGFzIHRoZSBncm91cCFcbiAgICAgIGlmICh0aGlzLmlzSW5MYXllcmdyb3VwcyhsYXllcmdyb3VwLCBsYXllcmdyb3VwLmxheWVycykpIHtcbiAgICAgICAgbGF5ZXJncm91cC5sYXllcnMgPSBsYXllcmdyb3VwLmxheWVycy5maWx0ZXIobCA9PiBsLmlkICE9PSBsYXllcmdyb3VwLmlkKTtcbiAgICAgIH1cbiAgICAgIC8vIHNldCBmaWx0ZXJ0eXBlIG9mIGdyb3VwIHRvIGxheWVyc1xuICAgICAgbGF5ZXJncm91cC5sYXllcnMgPSBsYXllcmdyb3VwLmxheWVycy5tYXAobCA9PiB7IGwuZmlsdGVydHlwZSA9IGxheWVyZ3JvdXAuZmlsdGVydHlwZTsgcmV0dXJuIGw7IH0pO1xuXG4gICAgICBzdG9yZUl0ZW1zLnB1c2gobGF5ZXJncm91cCk7XG4gICAgICB0aGlzLnN0b3JlLm5leHQoc3RvcmVJdGVtcyk7XG5cbiAgICAgIC8vIHVwZGF0ZSB0byBzZXQgdmlzaWJsZVxuICAgICAgdGhpcy51cGRhdGVMYXllckdyb3VwKGxheWVyZ3JvdXApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgdWtpcyBMYXllckdyb3VwIHRvIHRoZSBMYXllcnNlcnZpY2UgU3RvcmVcbiAgICogZm9yY2UgPSB0cnVlIC0gcmVtb3ZlcyBhIExheWVyR3JvdXAgZXZlbiBpdCBpcyBub3QgcmVtb3ZhYmxlXG4gICAqL1xuICBwdWJsaWMgcmVtb3ZlTGF5ZXJHcm91cChsYXllcmdyb3VwOiBMYXllckdyb3VwLCBmb3JjZT86IGJvb2xlYW4pIHtcbiAgICBpZiAodGhpcy5pc0luTGF5ZXJncm91cHMobGF5ZXJncm91cCkpIHtcbiAgICAgIGlmIChmb3JjZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhgbGF5ZXJHcm91cDogJHtsYXllcmdyb3VwLmlkfSBpcyByZW1vdmVkIHdpdGggZm9yY2UhYCk7XG4gICAgICAgIHRoaXMuX3JlbW92ZUxheWVyR3JvdXAobGF5ZXJncm91cCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobGF5ZXJncm91cC5yZW1vdmFibGUpIHtcbiAgICAgICAgICB0aGlzLl9yZW1vdmVMYXllckdyb3VwKGxheWVyZ3JvdXApO1xuICAgICAgICB9IGVsc2UgaWYgKCFsYXllcmdyb3VwLnJlbW92YWJsZSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBsYXllckdyb3VwOiAke2xheWVyZ3JvdXAuaWR9IGlzIG5vdCByZW1vdmFibGUhYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcihgbGF5ZXIgb3IgR3JvdXAgd2l0aCBpZDogJHtsYXllcmdyb3VwLmlkfSBub3QgaW4gc3RvcmVJdGVtcyFgKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9yZW1vdmVMYXllckdyb3VwKGxheWVyZ3JvdXA6IExheWVyR3JvdXApIHtcbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIGxheWVyZ3JvdXAubGF5ZXJzKSB7XG4gICAgICB0aGlzLnJlbW92ZUxheWVyRnJvbUdyb3VwKGxheWVyLCBsYXllcmdyb3VwKTtcbiAgICB9XG4gICAgY29uc3Qgc3RvcmVJdGVtcyA9IHRoaXMuc3RvcmUuZ2V0VmFsdWUoKTtcblxuICAgIGNvbnN0IGZpbHRlcmVkR3JvdXBzID0gc3RvcmVJdGVtcy5maWx0ZXIoZnVuY3Rpb24gKGxheWVyLCBpbmRleCkge1xuICAgICAgcmV0dXJuIGxheWVyLmlkICE9PSBsYXllcmdyb3VwLmlkO1xuICAgIH0pO1xuXG4gICAgdGhpcy5zdG9yZS5uZXh0KGZpbHRlcmVkR3JvdXBzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgdWtpcyBMYXllckdyb3VwIHRvIHRoZSBMYXllcnNlcnZpY2UgU3RvcmVcbiAgICogaWYgc29ydCBpcyBzZXQgdG8gdHJ1ZSB0aGUgbGF5ZXJzIG9mIHRoZSBHcm91cCBhcmUgc29ydCBzbyB2ZWN0b3JzIGFyZSBhYm92ZSB0aGUgcmFzdGVybGF5ZXJzXG4gICAqL1xuICBwdWJsaWMgdXBkYXRlTGF5ZXJHcm91cChsYXllckdyb3VwOiBMYXllckdyb3VwLCBzb3J0OiBib29sZWFuID0gZmFsc2UpIHtcbiAgICBpZiAoc29ydCkge1xuICAgICAgbGF5ZXJHcm91cCA9IHRoaXMuc29ydExheWVyR3JvdXAobGF5ZXJHcm91cCk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlTGF5ZXJPckdyb3VwSW5TdG9yZShsYXllckdyb3VwKTtcbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIGxheWVyR3JvdXAubGF5ZXJzKSB7XG4gICAgICAvKiogVE9ETzogdGhpcyB0cmlnZ2VycyBhIGNoYW5nZSBmb3IgZXZlcnkgbGF5ZXIgZWZlbiBpZiBubyBhdHRyaWJ1dGVzIG9mIHRoZSBsYXllciBhcmUgY2hhbmdlZCEhXG4gICAgICAgKiBUbyBjaGVjayBpZiBsYXllciBpcyBjaGFuZ2VkIHdlIGhhdmUgdG8gY2hlY2sgYWxsIGF0dHJpYnV0ZXMsIGFsc28gb2JqZWN0cyBlLmcuIEN1c3RvbUxheWVyLi4uIHRoaXMgaXMgY29tcGxpY2F0ZWQ/P1xuICAgICAgICovXG4gICAgICB0aGlzLnVwZGF0ZUxheWVyKGxheWVyLCBsYXllckdyb3VwLmZpbHRlcnR5cGUgfHwgJ0xheWVycycpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlcyBhIEl0ZW0gaW4gYW4gQXJyYXkgdG8gYW5vdGhlciBJbmRleFxuICAgKi9cbiAgcHVibGljIGFycmF5TW92ZShhcnJheTogQXJyYXk8YW55PiwgZnJvbUluZGV4OiBudW1iZXIsIHRvSW5kZXg6IG51bWJlcikge1xuICAgIGFycmF5LnNwbGljZSgodG9JbmRleCA8IDAgPyBhcnJheS5sZW5ndGggKyB0b0luZGV4IDogdG9JbmRleCksIDAsIGFycmF5LnNwbGljZShmcm9tSW5kZXgsIDEpWzBdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgR3JvdXAgT3IgTGF5ZXIgSW5kZXggaW4gdGhlIExheWVyc2VydmljZSBTdG9yZVxuICAgKiBkb3duID09IGluZGV4ICsgMSBhbmQgdXAgPT0gaW5kZXggLSAxXG4gICAqL1xuICBwdWJsaWMgc2V0R3JvdXBMYXllckluZGV4KGdyb3VwOiBMYXllciB8IExheWVyR3JvdXAsIGRpcjogbnVtYmVyIHwgJ3VwJyB8ICdkb3duJykge1xuICAgIGxldCBncm91cHNDb3VudDtcbiAgICBpZiAoZ3JvdXAgaW5zdGFuY2VvZiBMYXllciAmJiBncm91cC5maWx0ZXJ0eXBlKSB7XG4gICAgICBncm91cHNDb3VudCA9IHRoaXMuZ2V0TnVtT2ZHcm91cHMoZ3JvdXAuZmlsdGVydHlwZSk7XG4gICAgfSBlbHNlIGlmIChncm91cCBpbnN0YW5jZW9mIExheWVyR3JvdXApIHtcbiAgICAgIGdyb3Vwc0NvdW50ID0gdGhpcy5nZXROdW1PZkdyb3Vwcyhncm91cC5maWx0ZXJ0eXBlKTtcbiAgICB9XG5cbiAgICBpZiAoZ3JvdXBzQ291bnQgPiAxKSB7XG4gICAgICBjb25zdCBzdG9yZUl0ZW1zID0gdGhpcy5zdG9yZS5nZXRWYWx1ZSgpO1xuXG4gICAgICBjb25zdCBncm91cEluZGV4ID0gc3RvcmVJdGVtcy5pbmRleE9mKGdyb3VwKTtcblxuICAgICAgaWYgKCF0aGlzLmlzR3JvdXBGaXJzdChncm91cCkgfHwgIXRoaXMuaXNHcm91cExhc3QoZ3JvdXApKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGlyID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRoaXMuYXJyYXlNb3ZlKHN0b3JlSXRlbXMsIGdyb3VwSW5kZXgsIGRpcik7XG4gICAgICAgIH0gZWxzZSBpZiAoZGlyID09PSAndXAnKSB7XG4gICAgICAgICAgdGhpcy5hcnJheU1vdmUoc3RvcmVJdGVtcywgZ3JvdXBJbmRleCwgZ3JvdXBJbmRleCAtIDEpO1xuICAgICAgICB9IGVsc2UgaWYgKGRpciA9PT0gJ2Rvd24nKSB7XG4gICAgICAgICAgdGhpcy5hcnJheU1vdmUoc3RvcmVJdGVtcywgZ3JvdXBJbmRleCwgZ3JvdXBJbmRleCArIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBjb25zb2xlLmxvZygnZ3JvdXBJbmRleCBhZnRlcicsIGdyb3VwLm5hbWUsIGxncm91cHMuaW5kZXhPZihncm91cCkpO1xuICAgICAgdGhpcy5zdG9yZS5uZXh0KHN0b3JlSXRlbXMpO1xuICAgICAgdGhpcy5iYXNlTGF5ZXJzLm5leHQodGhpcy5maWx0ZXJCYXNlTGF5ZXJzKCkpO1xuICAgICAgdGhpcy5sYXllcnMubmV4dCh0aGlzLmZpbHRlckxheWVycygpKTtcbiAgICAgIHRoaXMub3ZlcmxheXMubmV4dCh0aGlzLmZpbHRlck92ZXJsYXlzKCkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIE51bWJlciBvZiBJdGVtcyBmcm9tIExheWVyc2VydmljZSBTdG9yZSBmaWx0ZXJlZCBieSBmaWx0ZXJ0eXBlXG4gICAqIGZpbHRlcnR5cGU6IFRGaWx0ZXJ0eXBlc1xuICAgKi9cbiAgZ2V0TnVtT2ZHcm91cHMoZmlsdGVydHlwZTogVEZpbHRlcnR5cGVzKTogbnVtYmVyIHtcbiAgICBsZXQgbnVtID0gMDtcbiAgICBjb25zdCBzdG9yZUl0ZW1zID0gdGhpcy5zdG9yZS5nZXRWYWx1ZSgpO1xuICAgIGZvciAoY29uc3QgbGcgb2Ygc3RvcmVJdGVtcykge1xuICAgICAgaWYgKGxnLmZpbHRlcnR5cGUgPT09IGZpbHRlcnR5cGUpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2cobGcudHlwZSwgdHlwZSlcbiAgICAgICAgbnVtKys7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudW07XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBMYXllciBvciBMYXllckdyb3VwIGlzIG9uIGluZGV4IDAgb2YgdGhlIExheWVyc2VydmljZSBTdG9yZSBvciB0aGUgcHJvdmlkZWQgQXJyYXlcbiAgICogaWYgZmlsdGVydHlwZSBpcyBzZXQgaXQgb25seSB1c2VzIHRoZSBpdGVtcyB3aXRoIHRoaXMgdHlwZVxuICAgKiBmaWx0ZXJ0eXBlPzogVEZpbHRlcnR5cGVzXG4gICAqL1xuICBpc0dyb3VwRmlyc3QoZ3JvdXA6IExheWVyIHwgTGF5ZXJHcm91cCwgbGdyb3Vwcz86IEFycmF5PExheWVyIHwgTGF5ZXJHcm91cD4sIGZpbHRlcnR5cGU/OiBURmlsdGVydHlwZXMpOiBib29sZWFuIHtcbiAgICBsZXQgdmFsdWUgPSBmYWxzZTtcblxuICAgIGxldCBzdG9yZUl0ZW1zID0gdGhpcy5zdG9yZS5nZXRWYWx1ZSgpO1xuICAgIGlmIChsZ3JvdXBzKSB7XG4gICAgICBzdG9yZUl0ZW1zID0gbGdyb3VwcztcbiAgICB9XG4gICAgaWYgKGZpbHRlcnR5cGUpIHtcbiAgICAgIHN0b3JlSXRlbXMgPSBzdG9yZUl0ZW1zLmZpbHRlcihsID0+IGwuZmlsdGVydHlwZSA9PT0gZmlsdGVydHlwZSk7XG4gICAgfVxuICAgIGlmIChzdG9yZUl0ZW1zLmluZGV4T2YoZ3JvdXApID09PSAwKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhncm91cC5uYW1lLCAnaXNGaXJzdCcpXG4gICAgICB2YWx1ZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIExheWVyIG9yIExheWVyR3JvdXAgaXMgb24gaW5kZXggKGxlbmd0aCAtIDEpIG9mIHRoZSBMYXllcnNlcnZpY2UgU3RvcmUgb3IgdGhlIHByb3ZpZGVkIEFycmF5XG4gICAqIGlmIGZpbHRlcnR5cGUgaXMgc2V0IGl0IG9ubHkgdXNlcyB0aGUgaXRlbXMgd2l0aCB0aGlzIHR5cGVcbiAgICogZmlsdGVydHlwZT86IFRGaWx0ZXJ0eXBlc1xuICAgKi9cbiAgaXNHcm91cExhc3QoZ3JvdXA6IExheWVyIHwgTGF5ZXJHcm91cCwgbGdyb3Vwcz86IEFycmF5PExheWVyIHwgTGF5ZXJHcm91cD4sIGZpbHRlcnR5cGU/OiBURmlsdGVydHlwZXMpOiBib29sZWFuIHtcbiAgICBsZXQgdmFsdWUgPSBmYWxzZTtcblxuICAgIGxldCBzdG9yZUl0ZW1zID0gdGhpcy5zdG9yZS5nZXRWYWx1ZSgpO1xuICAgIGlmIChsZ3JvdXBzKSB7XG4gICAgICBzdG9yZUl0ZW1zID0gbGdyb3VwcztcbiAgICB9XG4gICAgaWYgKGZpbHRlcnR5cGUpIHtcbiAgICAgIHN0b3JlSXRlbXMgPSBzdG9yZUl0ZW1zLmZpbHRlcihsID0+IGwuZmlsdGVydHlwZSA9PT0gZmlsdGVydHlwZSk7XG4gICAgfVxuICAgIGlmIChzdG9yZUl0ZW1zLmluZGV4T2YoZ3JvdXApID09PSBzdG9yZUl0ZW1zLmxlbmd0aCAtIDEpIHtcbiAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIExheWVyIG9yIExheWVyR3JvdXAgaXMgaW4gdGhlIExheWVyc2VydmljZSBTdG9yZSAob3IgdGhlIHByb3ZpZGVkIEFycmF5KSBieSB0aGVpciBJRFxuICAgKi9cbiAgcHVibGljIGlzSW5MYXllcmdyb3VwcyhsYXllcmdyb3VwOiBMYXllciB8IExheWVyR3JvdXAgfCBzdHJpbmcsIGdyb3Vwcz86IEFycmF5PExheWVyIHwgTGF5ZXJHcm91cD4pOiBib29sZWFuIHtcbiAgICBsZXQgdmFsdWUgPSBmYWxzZTtcbiAgICBsZXQgaWQ7XG4gICAgaWYgKGxheWVyZ3JvdXAgaW5zdGFuY2VvZiBMYXllciB8fCBsYXllcmdyb3VwIGluc3RhbmNlb2YgTGF5ZXJHcm91cCkge1xuICAgICAgaWQgPSBsYXllcmdyb3VwLmlkO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZCA9IGxheWVyZ3JvdXA7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5nZXRMYXllck9yR3JvdXBCeUlkKGlkLCBncm91cHMpO1xuICAgIGlmIChpdGVtcyAmJiBpdGVtcyBpbnN0YW5jZW9mIExheWVyIHx8IGl0ZW1zIGluc3RhbmNlb2YgTGF5ZXJHcm91cCkge1xuICAgICAgdmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgTGF5ZXIgb3IgTGF5ZXJHcm91cCBieSBJRCBmcm9tIHRoZSBMYXllcnNlcnZpY2UgU3RvcmUgKG9yIHRoZSBwcm92aWRlZCBBcnJheSlcbiAgICogbm9ybWFsIHRoZXJlIHNob3VsZCBvbmx5IGJlIHJldHVybmVkIG9uZSBvciB6ZXJvIGl0ZW1zIGluIHRoZSBhcnJheSBvdGhlcndpc2UgdGhlcmUgaXMgYSBkdXBsaWNhdGUgSUQgaW4gdGhlIExheWVyIEdyb3VwcyEhXG4gICAqL1xuICBwdWJsaWMgZ2V0TGF5ZXJPckdyb3VwQnlJZChpZDogc3RyaW5nLCBncm91cHM/OiBBcnJheTxMYXllciB8IExheWVyR3JvdXA+KSB7XG4gICAgY29uc3QgaXRlbXM6IEFycmF5PExheWVyIHwgTGF5ZXJHcm91cD4gPSBbXTtcbiAgICBsZXQgc3RvcmVJdGVtcyA9IHRoaXMuc3RvcmUuZ2V0VmFsdWUoKTtcbiAgICBpZiAoZ3JvdXBzKSB7XG4gICAgICBzdG9yZUl0ZW1zID0gZ3JvdXBzO1xuICAgIH1cbiAgICBzdG9yZUl0ZW1zLm1hcChncm91cCA9PiB7XG4gICAgICBpZiAoZ3JvdXAgaW5zdGFuY2VvZiBMYXllckdyb3VwKSB7XG4gICAgICAgIGlmIChncm91cC5pZCA9PT0gaWQpIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKGdyb3VwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBncm91cC5sYXllcnMubWFwKGxheWVyID0+IHtcbiAgICAgICAgICAgIGlmIChsYXllci5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgaXRlbXMucHVzaChsYXllcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZ3JvdXAgaW5zdGFuY2VvZiBMYXllcikge1xuICAgICAgICBpZiAoZ3JvdXAuaWQgPT09IGlkKSB7XG4gICAgICAgICAgaXRlbXMucHVzaChncm91cCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGl0ZW1zWzBdO1xuICAgIH0gZWxzZSBpZiAoaXRlbXMubGVuZ3RoID4gMSkge1xuICAgICAgY29uc29sZS5sb2coJ3RoZXJlIGlzIGEgZHVwbGljYXRlIElEIGluIHRoZSBMYXllciBHcm91cHMhJyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBMYXllciBieSBJRCBmcm9tIHRoZSBMYXllcnNlcnZpY2UgU3RvcmUgKG9yIHRoZSBwcm92aWRlZCBBcnJheSlcbiAgICovXG4gIHB1YmxpYyBnZXRMYXllckJ5SWQoaWQ6IHN0cmluZywgbGF5ZXJzPzogQXJyYXk8TGF5ZXI+KSB7XG4gICAgbGV0IHZhbHVlOiBMYXllcjtcbiAgICBsZXQgZmxhdGxheWVycyA9IHRoaXMuZmxhdHRlbkRlZXBBcnJheSh0aGlzLnN0b3JlLmdldFZhbHVlKCkpO1xuICAgIGlmIChsYXllcnMpIHtcbiAgICAgIGZsYXRsYXllcnMgPSBsYXllcnM7XG4gICAgfVxuICAgIGZsYXRsYXllcnMubWFwKGxheWVyID0+IHtcbiAgICAgIGlmIChsYXllci5pZCA9PT0gaWQpIHtcbiAgICAgICAgdmFsdWUgPSBsYXllcjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBMYXllcnMgd2l0aCBmaWx0ZXJyeXBlICdCYXNlbGF5ZXJzJyBmcm9tIHRoZSBMYXllcnNlcnZpY2UgU3RvcmVcbiAgICovXG4gIHB1YmxpYyBnZXRCYXNlTGF5ZXJzKCk6IE9ic2VydmFibGU8TGF5ZXJbXT4ge1xuICAgIHJldHVybiB0aGlzLmJhc2VMYXllcnMuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBMYXllcnMgd2l0aCBmaWx0ZXJ0eXBlICdCYXNlbGF5ZXJzJyBmcm9tIHRoZSBMYXllcnNlcnZpY2UgU3RvcmVcbiAgICogRmlsdGVyIGlzIGEgZnVuY3Rpb24gdG8gZXhjbHVkZSBsYXllcnNcbiAgICovXG4gIHB1YmxpYyByZW1vdmVCYXNlTGF5ZXJzKGZpbHRlcj86ICh2YWx1ZTogTGF5ZXIsIGluZGV4OiBudW1iZXIsIGFycmF5OiBMYXllcltdKSA9PiBhbnkpOiBPYnNlcnZhYmxlPExheWVyW10+IHtcbiAgICBsZXQgYmFzZWxheWVycyA9IHRoaXMuZmlsdGVyQmFzZUxheWVycygpO1xuICAgIGlmIChmaWx0ZXIpIHtcbiAgICAgIGJhc2VsYXllcnMgPSBiYXNlbGF5ZXJzLmZpbHRlcihmaWx0ZXIpO1xuICAgIH1cbiAgICBiYXNlbGF5ZXJzLmZvckVhY2goKG9sKSA9PiB7XG4gICAgICB0aGlzLnJlbW92ZUxheWVyT3JHcm91cEJ5SWQob2wuaWQpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmJhc2VMYXllcnMuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0QmFzZUxheWVyc0NvdW50KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuYmFzZUxheWVycy5nZXRWYWx1ZSgpLmxlbmd0aDtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEdldCBhbGwgTGF5ZXJzIHdpdGggZmlsdGVycnlwZSAnT3ZlcmxheXMnIGZyb20gdGhlIExheWVyc2VydmljZSBTdG9yZVxuICAgKi9cbiAgcHVibGljIGdldE92ZXJsYXlzKCk6IE9ic2VydmFibGU8TGF5ZXJbXT4ge1xuICAgIHJldHVybiB0aGlzLm92ZXJsYXlzLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgTGF5ZXJzIHdpdGggZmlsdGVydHlwZSAnT3ZlcmxheXMnIGZyb20gdGhlIExheWVyc2VydmljZSBTdG9yZVxuICAgKiBGaWx0ZXIgaXMgYSBmdW5jdGlvbiB0byBleGNsdWRlIGxheWVyc1xuICAgKi9cbiAgcHVibGljIHJlbW92ZU92ZXJsYXlzKGZpbHRlcj86ICh2YWx1ZTogTGF5ZXIsIGluZGV4OiBudW1iZXIsIGFycmF5OiBMYXllcltdKSA9PiBhbnkpOiBPYnNlcnZhYmxlPExheWVyW10+IHtcbiAgICBsZXQgb3ZlcmxheXMgPSB0aGlzLmZpbHRlck92ZXJsYXlzKCk7XG4gICAgaWYgKGZpbHRlcikge1xuICAgICAgb3ZlcmxheXMgPSBvdmVybGF5cy5maWx0ZXIoZmlsdGVyKTtcbiAgICB9XG4gICAgb3ZlcmxheXMuZm9yRWFjaCgob2wpID0+IHtcbiAgICAgIHRoaXMucmVtb3ZlTGF5ZXJPckdyb3VwQnlJZChvbC5pZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMub3ZlcmxheXMuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0T3ZlcmxheXNDb3VudCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLm92ZXJsYXlzLmdldFZhbHVlKCkubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgTGF5ZXJzIHdpdGggZmlsdGVycnlwZSAnTGF5ZXJzJyBmcm9tIHRoZSBMYXllcnNlcnZpY2UgU3RvcmVcbiAgICpcbiAgICogIyMjIyB0byBmaWx0ZXIgdGhlIE9ic2VydmFibGUgb25seSBvbiBzb21lIGxheWVyIHByb3BlcnR5IGNoYW5nZXMgdXNlIHJ4anMgZmlsdGVyIGUuZy4gc2VlIGJlbG93OlxuICAgKiB0aGlzLmxheWVyc1N1YiA9IHRoaXMubGF5ZXJTdmMuZ2V0TGF5ZXJzKCkucGlwZShmaWx0ZXIobGF5ZXJzID0+IHtcbiAgICogICBjb25zdCBuZXdWaXNpYmxlID0gbGF5ZXJzLm1hcChsID0+IGwudmlzaWJsZSkuZmlsdGVyKHYgPT4gdiA9PT0gdHJ1ZSkubGVuZ3RoO1xuICAgKiAgLy8gc3Vic2NyaWJlIGlmIHZpc2libGUgb2YgYSBsYXllciBoYXMgY2hhbmdlZFxuICAgKiAgaWYgKG5ld1Zpc2libGUgIT09IHRoaXMub2xkVmlzaWJsZUxheWVycykge1xuICAgKiAgICAgcmV0dXJuIHRydWU7XG4gICAqICB9IGVsc2Uge1xuICAgKiAgICAgLy8gc3Vic2NyaWJlIG9ubHkgdG8gcmVtb3ZlLCBhZGQgbGF5ZXJzXG4gICAqICAgICBpZiAodGhpcy5sYXllcnMgJiYgdGhpcy5sYXllcnMubGVuZ3RoICE9PSBsYXllcnMubGVuZ3RoKSB7XG4gICAqICAgICAgIHJldHVybiB0cnVlO1xuICAgKiAgICB9IGVsc2Uge1xuICAgKiAgICAgICByZXR1cm4gZmFsc2U7XG4gICAqICAgIH1cbiAgICogIH1cbiAgICogfSkpLnN1YnNjcmliZShsYXllcnMgPT4ge1xuICAgKiAgIHRoaXMubGF5ZXJzID0gbGF5ZXJzO1xuICAgKiAgIHRoaXMub2xkVmlzaWJsZUxheWVycyA9IHRoaXMubGF5ZXJzLm1hcChsID0+IGwudmlzaWJsZSkuZmlsdGVyKHYgPT4gdiA9PT0gdHJ1ZSkubGVuZ3RoO1xuICAgKiB9KTtcbiAgICovXG4gIHB1YmxpYyBnZXRMYXllcnMoKTogT2JzZXJ2YWJsZTxMYXllcltdPiB7XG4gICAgcmV0dXJuIHRoaXMubGF5ZXJzLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgTGF5ZXJzIHdpdGggZmlsdGVydHlwZSAnTGF5ZXJzJyBmcm9tIHRoZSBMYXllcnNlcnZpY2UgU3RvcmVcbiAgICogRmlsdGVyIGlzIGEgZnVuY3Rpb24gdG8gZXhjbHVkZSBsYXllcnNcbiAgICovXG4gIHB1YmxpYyByZW1vdmVMYXllcnMoZmlsdGVyPzogKHZhbHVlOiBMYXllciwgaW5kZXg6IG51bWJlciwgYXJyYXk6IExheWVyW10pID0+IGFueSk6IE9ic2VydmFibGU8TGF5ZXJbXT4ge1xuICAgIGxldCBsYXllcnMgPSB0aGlzLmZpbHRlckxheWVycygpO1xuICAgIGlmIChmaWx0ZXIpIHtcbiAgICAgIGxheWVycyA9IGxheWVycy5maWx0ZXIoZmlsdGVyKTtcbiAgICB9XG4gICAgbGF5ZXJzLmZvckVhY2goKG9sKSA9PiB7XG4gICAgICB0aGlzLnJlbW92ZUxheWVyT3JHcm91cEJ5SWQob2wuaWQpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmxheWVycy5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRMYXllcnNDb3VudCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmxheWVycy5nZXRWYWx1ZSgpLmxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIHN0b3JlSXRlbXMgZnJvbSB0aGUgTGF5ZXJzZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZ2V0TGF5ZXJHcm91cHMoKTogT2JzZXJ2YWJsZTxBcnJheTxMYXllciB8IExheWVyR3JvdXA+PiB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmUuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IChSZXNldCkgYWxsIHN0b3JlSXRlbXMgZnJvbSB0aGUgTGF5ZXJzZXJ2aWNlXG4gICAqIGlmIGZpbHRlcnR5cGUgaXMgc2V0IHRoZW4gb25seSB0aGUgc2xvdCBpcyB1c2VkXG4gICAqL1xuICBwdWJsaWMgc2V0TGF5ZXJHcm91cHMoaXRlbXM6IEFycmF5PExheWVyIHwgTGF5ZXJHcm91cD4sIGZpbHRlcnR5cGU/OiBURmlsdGVydHlwZXMpOiBPYnNlcnZhYmxlPEFycmF5PExheWVyIHwgTGF5ZXJHcm91cD4+IHtcbiAgICAvLyBzZXQgZmlsdGVydHlwZSBvZiBncm91cCB0byBsYXllcnNcbiAgICBpZiAoaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgaXRlbXMubWFwKGdyb3VwID0+IHtcbiAgICAgICAgaWYgKGdyb3VwIGluc3RhbmNlb2YgTGF5ZXJHcm91cCAmJiBncm91cC5sYXllcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGdyb3VwLmxheWVycyA9IGdyb3VwLmxheWVycy5tYXAobCA9PiB7IGwuZmlsdGVydHlwZSA9IGdyb3VwLmZpbHRlcnR5cGU7IHJldHVybiBsOyB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCFmaWx0ZXJ0eXBlKSB7XG4gICAgICB0aGlzLnN0b3JlLm5leHQoaXRlbXMpO1xuICAgICAgdGhpcy5iYXNlTGF5ZXJzLm5leHQodGhpcy5maWx0ZXJCYXNlTGF5ZXJzKCkpO1xuICAgICAgdGhpcy5sYXllcnMubmV4dCh0aGlzLmZpbHRlckxheWVycygpKTtcbiAgICAgIHRoaXMub3ZlcmxheXMubmV4dCh0aGlzLmZpbHRlck92ZXJsYXlzKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZmlsdGVydHlwZSA9PT0gJ0Jhc2VsYXllcnMnKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQmFzZUxheWVycygpO1xuICAgICAgfSBlbHNlIGlmIChmaWx0ZXJ0eXBlID09PSAnTGF5ZXJzJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxheWVycygpO1xuICAgICAgfSBlbHNlIGlmIChmaWx0ZXJ0eXBlID09PSAnT3ZlcmxheXMnKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlT3ZlcmxheXMoKTtcbiAgICAgIH1cblxuICAgICAgaXRlbXMubWFwKGxnID0+IHtcbiAgICAgICAgaWYgKGxnIGluc3RhbmNlb2YgTGF5ZXIpIHtcbiAgICAgICAgICB0aGlzLmFkZExheWVyKGxnLCBmaWx0ZXJ0eXBlKTtcbiAgICAgICAgfSBlbHNlIGlmIChsZyBpbnN0YW5jZW9mIExheWVyR3JvdXApIHtcbiAgICAgICAgICB0aGlzLmFkZExheWVyR3JvdXAobGcsIGZpbHRlcnR5cGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdG9yZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIENvdW50IG9mIGFsbCBzdG9yZUl0ZW1zXG4gICAqL1xuICBwdWJsaWMgZ2V0TGF5ZXJHcm91cHNDb3VudCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnN0b3JlLmdldFZhbHVlKCkubGVuZ3RoO1xuICB9XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gIC8qKlxuICAgKiBmbGF0dGVuIGFycmF5IHdpdGggTGF5ZXJzIGFuZCBMYXllckdyb3Vwcy5sYXllcnMgKHNvIHlvdSBjYW4gZ2V0IHRoZSB6SW5kZXgpXG4gICAqL1xuICBwdWJsaWMgZmxhdHRlbkRlZXBBcnJheShhcnI6IEFycmF5PExheWVyIHwgTGF5ZXJHcm91cD4pOiBMYXllcltdIHtcbiAgICByZXR1cm4gYXJyLnJlZHVjZSgoYWNjLCB2YWwpID0+ICh2YWwgaW5zdGFuY2VvZiBMYXllckdyb3VwICYmIEFycmF5LmlzQXJyYXkodmFsLmxheWVycykpID8gYWNjLmNvbmNhdCh0aGlzLmZsYXR0ZW5EZWVwQXJyYXkodmFsLmxheWVycykpIDogYWNjLmNvbmNhdCh2YWwpLCBbXSk7XG4gIH1cblxuICAvKlxuICBnZXRaSW5kZXhGb3JMYXllcihsYXllcjogTGF5ZXIpOiBudW1iZXIge1xuICAgIGxldCB6SW5kZXggPSBudWxsO1xuICAgIGNvbnN0IGJhc2VsYXllcnMgPSB0aGlzLmJhc2VMYXllcnMuZ2V0VmFsdWUoKTtcbiAgICBjb25zdCBsYXllcnMgPSB0aGlzLmxheWVycy5nZXRWYWx1ZSgpO1xuICAgIGNvbnN0IG92ZXJsYXlzID0gdGhpcy5vdmVybGF5cy5nZXRWYWx1ZSgpO1xuICAgIGxldCBhcnIgPSBbXTtcblxuICAgIGlmIChsYXllci5maWx0ZXJ0eXBlID09PSAnT3ZlcmxheXMnKSB7XG4gICAgICBhcnIgPSBhcnIuY29uY2F0KGJhc2VsYXllcnMpLmNvbmNhdChsYXllcnMpLmNvbmNhdChvdmVybGF5cyk7XG4gICAgICB6SW5kZXggPSBhcnIuaW5kZXhPZihsYXllcik7XG4gICAgfSBlbHNlIGlmIChsYXllci5maWx0ZXJ0eXBlID09PSAnTGF5ZXJzJykge1xuICAgICAgYXJyID0gYXJyLmNvbmNhdChiYXNlbGF5ZXJzKS5jb25jYXQobGF5ZXJzKTtcbiAgICAgIHpJbmRleCA9IGFyci5pbmRleE9mKGxheWVyKTtcbiAgICB9IGVsc2UgaWYgKGxheWVyLmZpbHRlcnR5cGUgPT09ICdCYXNlbGF5ZXJzJykge1xuICAgICAgYXJyID0gYXJyLmNvbmNhdChiYXNlbGF5ZXJzKTtcbiAgICAgIHpJbmRleCA9IGFyci5pbmRleE9mKGxheWVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHpJbmRleDtcbiAgfVxuICAqL1xuXG4gIHByaXZhdGUgZmlsdGVyT3ZlcmxheXMoKSB7XG4gICAgY29uc3Qgc3RvcmVJdGVtcyA9IHRoaXMuc3RvcmUuZ2V0VmFsdWUoKTtcbiAgICBjb25zdCBvdmVybGF5cyA9IHRoaXMuZmxhdHRlbkRlZXBBcnJheShzdG9yZUl0ZW1zLmZpbHRlcigobGF5ZXIpID0+IGxheWVyLmZpbHRlcnR5cGUgPT09ICdPdmVybGF5cycpKTtcbiAgICByZXR1cm4gb3ZlcmxheXM7XG4gIH1cblxuICBwcml2YXRlIGZpbHRlckJhc2VMYXllcnMoKSB7XG4gICAgY29uc3Qgc3RvcmVJdGVtcyA9IHRoaXMuc3RvcmUuZ2V0VmFsdWUoKTtcbiAgICBjb25zdCBiYXNlbGF5ZXJzID0gdGhpcy5mbGF0dGVuRGVlcEFycmF5KHN0b3JlSXRlbXMuZmlsdGVyKChsYXllcikgPT4gbGF5ZXIuZmlsdGVydHlwZSA9PT0gJ0Jhc2VsYXllcnMnKSk7XG4gICAgcmV0dXJuIGJhc2VsYXllcnM7XG4gIH1cblxuICBwcml2YXRlIGZpbHRlckxheWVycygpIHtcbiAgICBjb25zdCBzdG9yZUl0ZW1zID0gdGhpcy5zdG9yZS5nZXRWYWx1ZSgpO1xuICAgIGNvbnN0IGJhc2VsYXllcnMgPSB0aGlzLmZsYXR0ZW5EZWVwQXJyYXkoc3RvcmVJdGVtcy5maWx0ZXIoKGxheWVyKSA9PiBsYXllci5maWx0ZXJ0eXBlID09PSAnTGF5ZXJzJykpO1xuICAgIHJldHVybiBiYXNlbGF5ZXJzO1xuICB9XG5cblxuICBwcml2YXRlIGZpbHRlckZpbHRlcnR5cGUoZmlsdGVydHlwZTogVEZpbHRlcnR5cGVzKSB7XG4gICAgaWYgKGZpbHRlcnR5cGUgPT09ICdCYXNlbGF5ZXJzJykge1xuICAgICAgdGhpcy5iYXNlTGF5ZXJzLm5leHQodGhpcy5maWx0ZXJCYXNlTGF5ZXJzKCkpO1xuICAgIH0gZWxzZSBpZiAoZmlsdGVydHlwZSA9PT0gJ092ZXJsYXlzJykge1xuICAgICAgdGhpcy5vdmVybGF5cy5uZXh0KHRoaXMuZmlsdGVyT3ZlcmxheXMoKSk7XG4gICAgfSBlbHNlIGlmIChmaWx0ZXJ0eXBlID09PSAnTGF5ZXJzJykge1xuICAgICAgdGhpcy5sYXllcnMubmV4dCh0aGlzLmZpbHRlckxheWVycygpKTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBwcml2YXRlIHNvcnRMYXllckdyb3VwKGxheWVyR3JvdXA6IExheWVyR3JvdXApOiBMYXllckdyb3VwIHtcblxuICAgIC8vIGZpc3J0IHNvcnQgaW4gb3JkZXIgdG8gcHV0IHZlY3RvcnMgZmlyc3QgYW5kIHRoZW4gcmFzdGVybGF5ZXJzXG4gICAgbGF5ZXJHcm91cC5sYXllcnMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgbGV0IGNvbXBhcmlzb24gPSAwO1xuICAgICAgaWYgKGEgaW5zdGFuY2VvZiBSYXN0ZXJMYXllcikge1xuICAgICAgICBjb21wYXJpc29uID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoYiBpbnN0YW5jZW9mIFJhc3RlckxheWVyKSB7XG4gICAgICAgIGNvbXBhcmlzb24gPSAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21wYXJpc29uO1xuICAgIH0pO1xuICAgIHJldHVybiBsYXllckdyb3VwO1xuICB9XG59XG4iXX0=