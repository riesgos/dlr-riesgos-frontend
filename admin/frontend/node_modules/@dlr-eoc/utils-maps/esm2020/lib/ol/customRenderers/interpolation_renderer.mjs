import LayerRenderer from 'ol/renderer/Layer';
import CanvasVectorLayerRenderer from 'ol/renderer/canvas/VectorLayer';
import VectorLayer from 'ol/layer/Vector';
import { Cluster as olCluster } from 'ol/source';
import { replaceChildren } from 'ol/dom';
import { Shader, Framebuffer, Program, Uniform, Index, Texture, Attribute, DataTexture } from '../../webgl/engine.core';
import { getCurrentFramebuffersPixels } from '../../webgl/webgl';
import { rectangleA, rectangleE } from '../../webgl/engine.shapes';
import { nextPowerOf, flattenRecursive, createNDimArray } from '../../webgl/utils';
export class InterpolationLayer extends VectorLayer {
    constructor(options) {
        super(options);
        this.options = options;
    }
    createRenderer() {
        return new InterpolationRenderer(this, this.options.renderSettings);
    }
    updateParas(power, smooth, showLabels) {
        const newSettings = {
            colorRamp: this.options.renderSettings.colorRamp,
            maxEdgeLength: this.options.renderSettings.maxEdgeLength,
            storeInterpolatedPixelData: this.options.renderSettings.storeInterpolatedPixelData,
            valueProperty: this.options.renderSettings.valueProperty,
            power: power,
            showLabels: showLabels,
            smooth: smooth,
        };
        super.getRenderer().updateSettings(newSettings);
        this.options.renderSettings = newSettings;
    }
}
/**
 * This renderer runs three shaders in a row.
 *  1. interpolationShader: takes every observation at every pixel and executes the interpolation. The values are stored in `valueFb`.
 *  2. colorizationShader: uses the interpolated values from valueFb to apply the colorization according to the given colorRamp and smoothing-options.
 *  3. arrangementShader: the previous shaders have moved the data in the center of the canvas. this shader now arranges the pixels to the correct position relative to the map.
 *
 * Only the third shader needs to be executed with every frame. This way, the operation-heavy interpolation does not slow down the map.
 * It generally makes sense to arrange shaders in such a way that all openlayers-perspective-operations occur in the last shader.
 *
 * valueFb is also being used to handle click events: from this structure we get the actual value at a pixel when the user clicks.
 *
 * Note a few caveats.
 * This implementation is not really intended for updating observations, maxEdgeLength or colorRamps at runtime. These parameters are rather intended for the developer to set once.
 * While you can change the color-ramp at runtime, it's length is hardcoded in the colorization shader, so you'd have to recompile it to properly reflect the new ramp.
 * In the same way, the interpolation-shader has the number of observations baked into it. When new data becomes available, you must recompile the interpolation shader.
 */
export class InterpolationRenderer extends LayerRenderer {
    constructor(layer, settings) {
        super(layer);
        this.settings = settings;
        // setting up HTML element
        this.container = document.createElement('div');
        this.container.classList.add('ol-layer');
        this.container.style.setProperty('position', 'absolute');
        this.container.style.setProperty('width', '100%');
        this.container.style.setProperty('height', '100%');
        this.webGlCanvas = document.createElement('canvas');
        this.webGlCanvas.style.setProperty('position', 'absolute');
        this.webGlCanvas.style.setProperty('left', '0px');
        this.webGlCanvas.style.setProperty('top', '0px');
        this.webGlCanvas.style.setProperty('width', '100%');
        this.webGlCanvas.style.setProperty('height', '100%');
        this.webGlCanvas.width = 1000; // <-- make smaller for better performance
        this.webGlCanvas.height = 1000; // <-- make smaller for better performance
        this.gl = this.webGlCanvas.getContext('webgl');
        this.container.appendChild(this.webGlCanvas);
        // setting up point-renderer
        this.pointRenderer = new CanvasVectorLayerRenderer(layer);
        // preparing data
        const source = layer.getSource();
        this.projection = source.getProjection();
        const { coords, values, bboxDelta, maxVal } = this.parseData(source, this.settings.valueProperty, this.settings.maxEdgeLength);
        const { observationsBbox, maxEdgeLengthBbox } = this.parseDataBbox(bboxDelta, coords, values, maxVal, this.settings.maxEdgeLength);
        this.bbox = bboxDelta;
        // setting up shaders
        const identity = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
        this.interpolationShader = createInverseDistanceInterpolationShader(this.gl, observationsBbox, maxVal, this.settings.power, maxEdgeLengthBbox);
        this.valueFb = new Framebuffer(this.gl, this.webGlCanvas.width, this.webGlCanvas.height);
        this.colorizationShader = createColorizationShader(this.gl, this.settings.colorRamp, maxVal, this.settings.smooth, this.valueFb);
        this.colorFb = new Framebuffer(this.gl, this.webGlCanvas.width, this.webGlCanvas.height);
        this.arrangementShader = createArrangementShader(this.gl, identity, identity, bboxDelta, this.colorFb);
        // running first two shaders once
        this.runInterpolationShader(this.valueFb.fbo);
        this.runColorizationShader(this.colorFb.fbo);
    }
    prepareFrame(frameState) {
        const layerState = frameState.layerStatesArray[frameState.layerIndex];
        this.webGlCanvas.style.opacity = `${layerState.opacity}`;
        if (frameState.viewState.projection !== this.projection) {
            this.projection = frameState.viewState.projection;
            const source = super.getLayer().getSource();
            const { coords, values, bboxDelta, maxVal } = this.parseData(source, this.settings.valueProperty, this.settings.maxEdgeLength);
            const { observationsBbox, maxEdgeLengthBbox } = this.parseDataBbox(bboxDelta, coords, values, maxVal, this.settings.maxEdgeLength);
            this.updateInterpolationShader(this.settings.power, observationsBbox, maxEdgeLengthBbox);
            this.runInterpolationShader(this.valueFb.fbo);
            this.runColorizationShader(this.colorFb.fbo);
            this.bbox = bboxDelta;
        }
        const c2pT = frameState.coordinateToPixelTransform;
        // using frameState.size instead of this.webGlCanvas.clientWidth because the latter is null when layer invisible.
        this.updateArrangementShader(c2pT, frameState.size[0], frameState.size[1], this.bbox);
        this.pointRenderer.prepareFrame(frameState);
        return true;
    }
    renderFrame(frameState, target) {
        this.runArrangementShader(); // @todo: arrangement shader could be replaced with a simple css-transformation-matrix.
        if (this.settings.showLabels) {
            const pointCanvas = this.pointRenderer.renderFrame(frameState, this.container);
            replaceChildren(this.container, [this.webGlCanvas, pointCanvas]);
        }
        else {
            replaceChildren(this.container, [this.webGlCanvas]);
        }
        return this.container;
    }
    renderDeclutter(frameState) {
    }
    updateSettings(newSettings) {
        const oldSettings = this.settings;
        this.settings = newSettings;
        if (newSettings.power !== oldSettings.power) {
            this.updateInterpolationShader(newSettings.power);
            this.runInterpolationShader(this.valueFb.fbo);
            this.updateColorizationShader(newSettings.smooth);
            this.runColorizationShader(this.colorFb.fbo);
        }
        else if (newSettings.smooth !== oldSettings.smooth) {
            this.updateColorizationShader(newSettings.smooth);
            this.runColorizationShader(this.colorFb.fbo);
        }
        super.getLayer().changed();
    }
    /**
     * Called at every renderFrame. Fast.
     */
    updateArrangementShader(coordinateToPixelTransform, canvasWidth, canvasHeight, bbox) {
        const world2pix = [
            [coordinateToPixelTransform[0], coordinateToPixelTransform[1], 0.],
            [coordinateToPixelTransform[2], coordinateToPixelTransform[3], 0.],
            [coordinateToPixelTransform[4], coordinateToPixelTransform[5], 1.]
        ];
        const pix2clip = [
            [1. / (canvasWidth / 2), 0., 0.],
            [0, -1. / (canvasHeight / 2), 0.],
            [-1., 1., 1.]
        ];
        this.arrangementShader.updateUniformData(this.gl, 'u_world2pix', flattenRecursive(world2pix));
        this.arrangementShader.updateUniformData(this.gl, 'u_pix2clip', flattenRecursive(pix2clip));
        this.arrangementShader.updateUniformData(this.gl, 'u_bbox', bbox);
    }
    /**
     * Called at every renderFrame. Fast.
     */
    runArrangementShader(target) {
        this.arrangementShader.bind(this.gl);
        this.arrangementShader.render(this.gl, [0, 0, 0, 0], target);
    }
    /**
     * Slow! Avoid calling this too often.
     */
    updateInterpolationShader(power, observations, maxEdgeLengthBbox) {
        this.interpolationShader.updateUniformData(this.gl, 'u_power', [power]);
        if (observations) {
            this.interpolationShader.updateTextureData(this.gl, 'u_dataTexture', [observations]);
        }
        if (maxEdgeLengthBbox) {
            this.interpolationShader.updateUniformData(this.gl, 'u_maxDistance', [maxEdgeLengthBbox]);
        }
    }
    /**
     * Slow! Avoid calling this too often.
     */
    runInterpolationShader(target) {
        this.interpolationShader.bind(this.gl);
        this.interpolationShader.render(this.gl, [0, 0, 0, 0], target);
        if (this.settings.storeInterpolatedPixelData) {
            this.interpolatedValues = getCurrentFramebuffersPixels(this.webGlCanvas);
        }
    }
    /**
     * Slow! Avoid calling this too often.
     */
    updateColorizationShader(smooth) {
        // this.colorizationShader.updateUniformData(this.gl, 'u_colorRampValues', colorRamp.map(e => e.val));
        // this.colorizationShader.updateUniformData(this.gl, 'u_colorRampColors', flattenRecursive( colorRamp.map(e => e.rgb) ));
        this.colorizationShader.updateUniformData(this.gl, 'u_smooth', [smooth ? 1 : 0]);
    }
    /**
     * Slow! Avoid calling this too often.
     */
    runColorizationShader(target) {
        this.colorizationShader.bind(this.gl);
        this.colorizationShader.render(this.gl, [0, 0, 0, 0], target);
    }
    parseData(source, valueProperty, maxEdgeLength) {
        let features = source.getFeatures();
        if (source instanceof olCluster) {
            features = source.getSource().getFeatures();
        }
        else {
            features = source.getFeatures();
        }
        const coords = features.map(f => f.getGeometry().getCoordinates());
        const values = features.map(f => parseFloat(f.getProperties()[valueProperty]));
        const bbox = getBbox(coords);
        const deltaX = bbox[2] - bbox[0];
        const deltaY = bbox[3] - bbox[1];
        let addX, addY;
        if (deltaX > deltaY) {
            addY = deltaX - deltaY;
            addX = 0;
        }
        else {
            addY = 0;
            addX = deltaY - deltaX;
        }
        const bboxDelta = [
            bbox[0] - maxEdgeLength,
            bbox[1] - maxEdgeLength,
            bbox[2] + addX + maxEdgeLength,
            bbox[3] + addY + maxEdgeLength
        ];
        const maxVal = values.reduce((prev, curr) => curr > prev ? curr : prev, 0);
        return {
            coords, values, bboxDelta, maxVal
        };
    }
    parseDataBbox(bbox, coords, values, maxVal, maxEdgeLength) {
        const observationsBbox = zip(coords, values).map(o => {
            const coordsBbox = worldCoords2clipBbox([o[0], o[1]], bbox);
            return [
                255 * (coordsBbox[0] + 1) / 2,
                255 * (coordsBbox[1] + 1) / 2,
                255 * o[2] / maxVal,
                255
            ];
        });
        const nrObservations = observationsBbox.length;
        const nextPowerOfTwo = nextPowerOf(nrObservations, 2);
        for (let i = 0; i < nextPowerOfTwo - nrObservations; i++) {
            observationsBbox.push([0, 0, 0, 0]);
        }
        const deltaX = bbox[2] - bbox[0];
        const deltaY = bbox[3] - bbox[1];
        const maxEdgeLengthBbox = maxEdgeLength / Math.max(deltaX, deltaY);
        return { observationsBbox, maxEdgeLengthBbox };
    }
}
const worldCoords2clipBbox = (point, bbox) => {
    const xPerct = (point[0] - bbox[0]) / (bbox[2] - bbox[0]);
    const yPerct = (point[1] - bbox[1]) / (bbox[3] - bbox[1]);
    const xClip = 2 * xPerct - 1;
    const yClip = 2 * yPerct - 1;
    return [xClip, yClip];
};
const createInverseDistanceInterpolationShader = (gl, observationsBbox, maxValue, power, maxEdgeLengthBbox) => {
    const maxObservations = 10000;
    const inverseDistanceProgram = new Program(gl, `
            precision mediump float;
            attribute vec3 a_position;
            attribute vec2 a_texturePosition;
            varying vec2 v_position;
            varying vec2 v_texturePosition;

            void main() {
                v_position = a_position.xy;
                v_texturePosition = a_texturePosition;
                gl_Position = vec4(a_position.xy, 0.0, 1.0);
            }
        `, `
            precision mediump float;
            uniform float u_power;
            uniform sampler2D u_dataTexture;
            uniform int u_nrDataPoints;
            uniform float u_maxValue;
            uniform float u_maxDistance;
            varying vec2 v_position;
            varying vec2 v_texturePosition;

            void main() {

                float valSum = 0.0;
                float wSum = 0.0;
                float minD = 10000.0;
                for (int i = 0; i < ${maxObservations}; i++) {
                    if (i > u_nrDataPoints) {
                        break;
                    }
                    vec4 dataPoint = texture2D(u_dataTexture, vec2(float(i) / float(u_nrDataPoints), 0.5));
                    if (dataPoint.w > 0.0) {  // texture is padded to next power of two with transparent 0-values.
                        vec2 coords = dataPoint.xy * 2.0 - 1.0;  // transforming coords from [0, 1] to [-1, 1]
                        float value = dataPoint.z * u_maxValue;  // transforming value from [0, 1] to [0, maxValue]

                        float d = distance(v_position, coords);
                        float w = 1.0 / pow(d, u_power);
                        valSum += value * w;
                        wSum += w;
                        if (d < minD) {
                            minD = d;
                        }
                    }
                }
                float interpolatedValue = valSum / wSum;
                float alpha = 1.0;
                if (minD > u_maxDistance) {
                    alpha = 0.0;
                }
                vec4 color = vec4(interpolatedValue / u_maxValue, 0.0, 0.0, alpha);

                gl_FragColor = color;
            }
        `);
    const viewPort = rectangleE(2, 2);
    const inverseDistanceShader = new Shader(inverseDistanceProgram, [
        new Attribute(gl, inverseDistanceProgram, 'a_position', viewPort.vertices),
        new Attribute(gl, inverseDistanceProgram, 'a_texturePosition', viewPort.texturePositions)
    ], [
        new Uniform(gl, inverseDistanceProgram, 'u_power', 'float', [power]),
        new Uniform(gl, inverseDistanceProgram, 'u_nrDataPoints', 'int', [observationsBbox.length]),
        new Uniform(gl, inverseDistanceProgram, 'u_maxValue', 'float', [maxValue]),
        new Uniform(gl, inverseDistanceProgram, 'u_maxDistance', 'float', [maxEdgeLengthBbox])
    ], [
        new DataTexture(gl, inverseDistanceProgram, 'u_dataTexture', [observationsBbox], 0)
    ], new Index(gl, viewPort.vertexIndices));
    return inverseDistanceShader;
};
const createColorizationShader = (gl, colorRamp, maxVal, smooth, valueFb) => {
    const maxColorRampValues = 15;
    const colorizationProgram = new Program(gl, `
            precision mediump float;
            attribute vec2 a_position;
            attribute vec2 a_textureCoord;
            varying vec2 v_textureCoord;

            void main() {
                v_textureCoord = a_textureCoord;
                gl_Position = vec4(a_position.xy, 0.0, 1.0);
            }
        `, `
            precision mediump float;
            uniform float u_colorRampValues[${maxColorRampValues}];
            uniform vec3 u_colorRampColors[${maxColorRampValues}];
            uniform int u_nrColorRampValues;
            uniform float u_maxValue;
            uniform bool u_smooth;
            uniform sampler2D u_valueTexture;
            varying vec2 v_textureCoord;

            vec3 valueToSmoothColor(in float value) {
                if (value < u_colorRampValues[0]) {
                    return u_colorRampColors[0];
                }
                for (int i = 1; i < ${maxColorRampValues}; i++) {
                    if (i > u_nrColorRampValues) {
                        break;
                    }
                    if (value < u_colorRampValues[i]) {
                        float alpha = (value - u_colorRampValues[i-1]) / (u_colorRampValues[i] - u_colorRampValues[i-1]);
                        vec3 color = alpha * (u_colorRampColors[i] - u_colorRampColors[i-1]) + u_colorRampColors[i-1];
                        return color;
                    }
                    if (i == u_nrColorRampValues) {
                        return u_colorRampColors[i];
                    }
                }
            }

            vec3 valueToStepColor(in float value) {
                for (int i = 0; i < ${maxColorRampValues}; i++) {
                    if (i > u_nrColorRampValues) {
                        break;
                    }
                    if (value < u_colorRampValues[i]) {
                        return u_colorRampColors[i];
                    }
                    if (i == u_nrColorRampValues) {
                        return u_colorRampColors[i];
                    }
                }
            }

            void main() {
                vec4 pixelData = texture2D(u_valueTexture, v_textureCoord);
                float val = pixelData.r * u_maxValue;
                float alpha = pixelData.w;
                vec3 rgb = vec3(0.0, 0.0, 0.0);
                if (alpha > 0.01) {
                    if (u_smooth) {
                        rgb = valueToSmoothColor(val);
                    } else {
                        rgb = valueToStepColor(val);
                    }
                }
                gl_FragColor = vec4(rgb.x / 255.0, rgb.y / 255.0, rgb.z / 255.0, alpha);
            }
        `);
    const colorizationShader = new Shader(colorizationProgram, [
        new Attribute(gl, colorizationProgram, 'a_position', rectangleA(2.0, 2.0).vertices),
        new Attribute(gl, colorizationProgram, 'a_textureCoord', rectangleA(2.0, 2.0).texturePositions)
    ], [
        new Uniform(gl, colorizationProgram, 'u_colorRampValues', 'float[]', colorRamp.map(e => e.val)),
        new Uniform(gl, colorizationProgram, 'u_colorRampColors', 'vec3[]', flattenRecursive(colorRamp.map(e => e.rgb))),
        new Uniform(gl, colorizationProgram, 'u_nrColorRampValues', 'int', [colorRamp.length]),
        new Uniform(gl, colorizationProgram, 'u_maxValue', 'float', [maxVal]),
        new Uniform(gl, colorizationProgram, 'u_smooth', 'bool', [smooth ? 1 : 0]),
    ], [
        new Texture(gl, colorizationProgram, 'u_valueTexture', valueFb.fbo.texture, 0)
    ]);
    return colorizationShader;
};
const createArrangementShader = (gl, world2pix, pix2clip, bbox, colorFb) => {
    const arrangementProgram = new Program(gl, `
            precision mediump float;
            attribute vec3 a_pos;
            attribute vec2 a_posTexture;
            uniform mat3 u_world2pix;
            uniform mat3 u_pix2clip;
            uniform vec4 u_bbox;
            varying vec2 v_posTexture;

            vec2 clipBbx2worldCoords(vec2 clipCoords, vec4 bbox) {
                float xPerct = ( clipCoords.x + 1.0 ) / 2.0;
                float yPerct = ( clipCoords.y + 1.0 ) / 2.0;
                float xWorld = xPerct * (bbox.z - bbox.x) + bbox.x;
                float yWorld = yPerct * (bbox.w - bbox.y) + bbox.y;
                return vec2(xWorld, yWorld);
            }

            void main() {
                v_posTexture = a_posTexture;
                vec2 worldPos = clipBbx2worldCoords(a_pos.xy, u_bbox);
                vec3 clipPos = u_pix2clip * u_world2pix * vec3(worldPos.xy, 1.0);
                gl_Position = vec4(clipPos.xy, 0.0, 1.0);
            }
        `, `
            precision mediump float;
            uniform sampler2D u_texture;
            varying vec2 v_posTexture;

            void main() {
                gl_FragColor = texture2D(u_texture, v_posTexture);
            }
        `);
    const arrangementShader = new Shader(arrangementProgram, [
        new Attribute(gl, arrangementProgram, 'a_pos', rectangleA(2, 2).vertices),
        new Attribute(gl, arrangementProgram, 'a_posTexture', rectangleA(2, 2).texturePositions),
    ], [
        new Uniform(gl, arrangementProgram, 'u_world2pix', 'mat3', flattenRecursive(world2pix)),
        new Uniform(gl, arrangementProgram, 'u_pix2clip', 'mat3', flattenRecursive(pix2clip)),
        new Uniform(gl, arrangementProgram, 'u_bbox', 'vec4', bbox)
    ], [
        new Texture(gl, arrangementProgram, 'u_texture', colorFb.fbo.texture, 0)
    ]);
    return arrangementShader;
};
const getBbox = (obs) => {
    const xs = obs.map(p => p[0]);
    const ys = obs.map(p => p[1]);
    const xMin = Math.min(...xs);
    const xMax = Math.max(...xs);
    const yMin = Math.min(...ys);
    const yMax = Math.max(...ys);
    return [xMin, yMin, xMax, yMax];
};
const zip = (arr0, arr1) => {
    const out = [];
    for (let i = 0; i < arr0.length; i++) {
        out.push(arr0[i].concat(arr1[i]));
    }
    return out;
};
const createDistanceMatrix = (coords) => {
    const matrix = createNDimArray([coords.length, coords.length]);
    for (let i = 0; i < coords.length; i++) {
        for (let j = i + 1; j < coords.length; j++) {
            const d = pointDistance(coords[i], coords[j]);
            matrix[i][j] = d;
            matrix[j][i] = d;
        }
    }
    return matrix;
};
const create7NearestNeighborsTextureData = (distanceMatrix, coords, values) => {
    const rows = nextPowerOf(values.length, 2);
    const data = createNDimArray([rows, 8, 4]);
    for (let r = 0; r < values.length; r++) {
        data[r][0] = [coords[r][0], coords[r][1], values[r], 255];
        const neighborIndices = getNIndicesSmallest(7, distanceMatrix[r]);
        for (let n = 1; n < 8; n++) {
            const ni = neighborIndices[n - 1];
            data[r][n] = [coords[ni][0], coords[ni][1], values[ni], 255];
        }
    }
    return data;
};
const pointDistance = (a, b) => {
    return Math.sqrt(Math.pow((a[0] - b[0]), 2) + Math.pow((a[1] - b[1]), 2));
};
const getNIndicesSmallest = (n, values) => {
    const smallest = getNSmallest(n, values);
    const indices = getIndicesInArray(smallest, values);
    return indices;
};
const getIndicesInArray = (pickedValues, allValues) => {
    return pickedValues.map(v => allValues.findIndex(a => a === v));
};
const getNSmallest = (n, values) => {
    return values.sort(function (a, b) { return a - b; }).slice(0, n);
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50ZXJwb2xhdGlvbl9yZW5kZXJlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL3V0aWxzLW1hcHMvc3JjL2xpYi9vbC9jdXN0b21SZW5kZXJlcnMvaW50ZXJwb2xhdGlvbl9yZW5kZXJlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFFQSxPQUFPLGFBQWEsTUFBTSxtQkFBbUIsQ0FBQztBQUM5QyxPQUFPLHlCQUF5QixNQUFNLGdDQUFnQyxDQUFDO0FBQ3ZFLE9BQU8sV0FBVyxNQUFNLGlCQUFpQixDQUFDO0FBRzFDLE9BQU8sRUFBMEIsT0FBTyxJQUFJLFNBQVMsRUFBRSxNQUFNLFdBQVcsQ0FBQztBQUN6RSxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sUUFBUSxDQUFDO0FBRXpDLE9BQU8sRUFBRSxNQUFNLEVBQUUsV0FBVyxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDeEgsT0FBTyxFQUFxQiw0QkFBNEIsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQ3BGLE9BQU8sRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDbkUsT0FBTyxFQUFFLFdBQVcsRUFBRSxnQkFBZ0IsRUFBRSxlQUFlLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQStCbkYsTUFBTSxPQUFPLGtCQUFtQixTQUFRLFdBQW1DO0lBSXZFLFlBQVksT0FBa0M7UUFDMUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ2YsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7SUFDM0IsQ0FBQztJQUVELGNBQWM7UUFDVixPQUFPLElBQUkscUJBQXFCLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLENBQUM7SUFDeEUsQ0FBQztJQUVELFdBQVcsQ0FBQyxLQUFhLEVBQUUsTUFBZSxFQUFFLFVBQW1CO1FBQzNELE1BQU0sV0FBVyxHQUFrQztZQUMvQyxTQUFTLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjLENBQUMsU0FBUztZQUNoRCxhQUFhLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjLENBQUMsYUFBYTtZQUN4RCwwQkFBMEIsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQywwQkFBMEI7WUFDbEYsYUFBYSxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLGFBQWE7WUFDeEQsS0FBSyxFQUFFLEtBQUs7WUFDWixVQUFVLEVBQUUsVUFBVTtZQUN0QixNQUFNLEVBQUUsTUFBTTtTQUNqQixDQUFDO1FBQ0QsS0FBSyxDQUFDLFdBQVcsRUFBcUMsQ0FBQyxjQUFjLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDcEYsSUFBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjLEdBQUcsV0FBVyxDQUFDO0lBQzlDLENBQUM7Q0FDSjtBQUVEOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUNILE1BQU0sT0FBTyxxQkFBc0IsU0FBUSxhQUFtRDtJQWdCMUYsWUFBWSxLQUEwQyxFQUFVLFFBQXVDO1FBQ25HLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUQrQyxhQUFRLEdBQVIsUUFBUSxDQUErQjtRQUduRywwQkFBMEI7UUFDMUIsSUFBSSxDQUFDLFNBQVMsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQy9DLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUN6QyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsVUFBVSxFQUFFLFVBQVUsQ0FBQyxDQUFDO1FBQ3pELElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxPQUFPLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDbEQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLFFBQVEsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUVuRCxJQUFJLENBQUMsV0FBVyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDcEQsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLFVBQVUsRUFBRSxVQUFVLENBQUMsQ0FBQztRQUMzRCxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ2xELElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDakQsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLE9BQU8sRUFBRSxNQUFNLENBQUMsQ0FBQztRQUNwRCxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ3JELElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxDQUFFLDBDQUEwQztRQUMxRSxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsQ0FBRSwwQ0FBMEM7UUFDM0UsSUFBSSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUMvQyxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7UUFFN0MsNEJBQTRCO1FBQzVCLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSx5QkFBeUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUUxRCxpQkFBaUI7UUFDakIsTUFBTSxNQUFNLEdBQUcsS0FBSyxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQ2pDLElBQUksQ0FBQyxVQUFVLEdBQUcsTUFBTSxDQUFDLGFBQWEsRUFBRSxDQUFDO1FBQ3pDLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQy9ILE1BQU0sRUFBRSxnQkFBZ0IsRUFBRSxpQkFBaUIsRUFBRSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsU0FBUyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDbkksSUFBSSxDQUFDLElBQUksR0FBRyxTQUFTLENBQUM7UUFFdEIscUJBQXFCO1FBQ3JCLE1BQU0sUUFBUSxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNuRCxJQUFJLENBQUMsbUJBQW1CLEdBQUcsd0NBQXdDLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztRQUMvSSxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksV0FBVyxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUN6RixJQUFJLENBQUMsa0JBQWtCLEdBQUcsd0JBQXdCLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsRUFBRSxNQUFNLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ2pJLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxXQUFXLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3pGLElBQUksQ0FBQyxpQkFBaUIsR0FBRyx1QkFBdUIsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsU0FBUyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUV2RyxpQ0FBaUM7UUFDakMsSUFBSSxDQUFDLHNCQUFzQixDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDOUMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDakQsQ0FBQztJQUVELFlBQVksQ0FBQyxVQUFzQjtRQUMvQixNQUFNLFVBQVUsR0FBRyxVQUFVLENBQUMsZ0JBQWdCLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ3RFLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxHQUFHLFVBQVUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUV6RCxJQUFJLFVBQVUsQ0FBQyxTQUFTLENBQUMsVUFBVSxLQUFLLElBQUksQ0FBQyxVQUFVLEVBQUU7WUFDckQsSUFBSSxDQUFDLFVBQVUsR0FBRyxVQUFVLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQztZQUNsRCxNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUMsU0FBUyxFQUFFLENBQUM7WUFDNUMsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsYUFBYSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLENBQUM7WUFDL0gsTUFBTSxFQUFFLGdCQUFnQixFQUFFLGlCQUFpQixFQUFFLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUNuSSxJQUFJLENBQUMseUJBQXlCLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsZ0JBQWdCLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztZQUN6RixJQUFJLENBQUMsc0JBQXNCLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUM5QyxJQUFJLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUM3QyxJQUFJLENBQUMsSUFBSSxHQUFHLFNBQVMsQ0FBQztTQUN6QjtRQUVELE1BQU0sSUFBSSxHQUFHLFVBQVUsQ0FBQywwQkFBMEIsQ0FBQztRQUNuRCxpSEFBaUg7UUFDakgsSUFBSSxDQUFDLHVCQUF1QixDQUFDLElBQUksRUFBRSxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3RGLElBQUksQ0FBQyxhQUFhLENBQUMsWUFBWSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQzVDLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFFRCxXQUFXLENBQUMsVUFBc0IsRUFBRSxNQUFtQjtRQUNuRCxJQUFJLENBQUMsb0JBQW9CLEVBQUUsQ0FBQyxDQUFFLHVGQUF1RjtRQUNySCxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxFQUFFO1lBQzFCLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDL0UsZUFBZSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLFdBQVcsQ0FBQyxDQUFDLENBQUM7U0FDcEU7YUFBTTtZQUNILGVBQWUsQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7U0FDdkQ7UUFDRCxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUM7SUFDMUIsQ0FBQztJQUVELGVBQWUsQ0FBQyxVQUFzQjtJQUN0QyxDQUFDO0lBRU0sY0FBYyxDQUFDLFdBQTBDO1FBQzVELE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7UUFDbEMsSUFBSSxDQUFDLFFBQVEsR0FBRyxXQUFXLENBQUM7UUFDNUIsSUFBSSxXQUFXLENBQUMsS0FBSyxLQUFLLFdBQVcsQ0FBQyxLQUFLLEVBQUU7WUFDekMsSUFBSSxDQUFDLHlCQUF5QixDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNsRCxJQUFJLENBQUMsc0JBQXNCLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUM5QyxJQUFJLENBQUMsd0JBQXdCLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ2xELElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ2hEO2FBQU0sSUFBSSxXQUFXLENBQUMsTUFBTSxLQUFLLFdBQVcsQ0FBQyxNQUFNLEVBQUU7WUFDbEQsSUFBSSxDQUFDLHdCQUF3QixDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUNsRCxJQUFJLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUNoRDtRQUNELEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUMvQixDQUFDO0lBRUQ7O09BRUc7SUFDSyx1QkFBdUIsQ0FBQywwQkFBb0MsRUFBRSxXQUFtQixFQUFFLFlBQW9CLEVBQUUsSUFBYztRQUMzSCxNQUFNLFNBQVMsR0FBRztZQUNkLENBQUMsMEJBQTBCLENBQUMsQ0FBQyxDQUFDLEVBQUUsMEJBQTBCLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO1lBQ2xFLENBQUMsMEJBQTBCLENBQUMsQ0FBQyxDQUFDLEVBQUUsMEJBQTBCLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO1lBQ2xFLENBQUMsMEJBQTBCLENBQUMsQ0FBQyxDQUFDLEVBQUUsMEJBQTBCLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO1NBQ3JFLENBQUM7UUFDRixNQUFNLFFBQVEsR0FBRztZQUNiLENBQUMsRUFBRSxHQUFHLENBQUMsV0FBVyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUM7WUFDaEMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxZQUFZLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO1lBQ2pDLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQztTQUNoQixDQUFDO1FBQ0YsSUFBSSxDQUFDLGlCQUFpQixDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsYUFBYSxFQUFFLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7UUFDOUYsSUFBSSxDQUFDLGlCQUFpQixDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsWUFBWSxFQUFFLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7UUFDNUYsSUFBSSxDQUFDLGlCQUFpQixDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ3RFLENBQUM7SUFFRDs7T0FFRztJQUNLLG9CQUFvQixDQUFDLE1BQTBCO1FBQ25ELElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3JDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ2pFLENBQUM7SUFFRDs7T0FFRztJQUNLLHlCQUF5QixDQUFDLEtBQWEsRUFBRSxZQUF5QixFQUFFLGlCQUEwQjtRQUNsRyxJQUFJLENBQUMsbUJBQW1CLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxTQUFTLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQ3hFLElBQUksWUFBWSxFQUFFO1lBQ2QsSUFBSSxDQUFDLG1CQUFtQixDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsZUFBZSxFQUFFLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQztTQUN4RjtRQUNELElBQUksaUJBQWlCLEVBQUU7WUFDbkIsSUFBSSxDQUFDLG1CQUFtQixDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsZUFBZSxFQUFFLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDO1NBQzdGO0lBQ0wsQ0FBQztJQUVEOztPQUVHO0lBQ0ssc0JBQXNCLENBQUMsTUFBMEI7UUFDckQsSUFBSSxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDdkMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDL0QsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLDBCQUEwQixFQUFFO1lBQzFDLElBQUksQ0FBQyxrQkFBa0IsR0FBRyw0QkFBNEIsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFlLENBQUM7U0FDMUY7SUFDTCxDQUFDO0lBRUQ7O09BRUc7SUFDSyx3QkFBd0IsQ0FBQyxNQUFlO1FBQzVDLHNHQUFzRztRQUN0RywwSEFBMEg7UUFDMUgsSUFBSSxDQUFDLGtCQUFrQixDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsVUFBVSxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDckYsQ0FBQztJQUVEOztPQUVHO0lBQ0sscUJBQXFCLENBQUMsTUFBMEI7UUFDcEQsSUFBSSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDdEMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDbEUsQ0FBQztJQUVPLFNBQVMsQ0FBQyxNQUFNLEVBQUUsYUFBcUIsRUFBRSxhQUFxQjtRQUNsRSxJQUFJLFFBQVEsR0FBcUIsTUFBTSxDQUFDLFdBQVcsRUFBc0IsQ0FBQztRQUMxRSxJQUFJLE1BQU0sWUFBWSxTQUFTLEVBQUU7WUFDN0IsUUFBUSxHQUFHLE1BQU0sQ0FBQyxTQUFTLEVBQUUsQ0FBQyxXQUFXLEVBQXNCLENBQUM7U0FDbkU7YUFBTTtZQUNILFFBQVEsR0FBRyxNQUFNLENBQUMsV0FBVyxFQUFzQixDQUFDO1NBQ3ZEO1FBRUQsTUFBTSxNQUFNLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxDQUFDO1FBQ25FLE1BQU0sTUFBTSxHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLGFBQWEsRUFBRSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUUvRSxNQUFNLElBQUksR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDN0IsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNqQyxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2pDLElBQUksSUFBWSxFQUFFLElBQVksQ0FBQztRQUMvQixJQUFJLE1BQU0sR0FBRyxNQUFNLEVBQUU7WUFDakIsSUFBSSxHQUFHLE1BQU0sR0FBRyxNQUFNLENBQUM7WUFDdkIsSUFBSSxHQUFHLENBQUMsQ0FBQztTQUNaO2FBQU07WUFDSCxJQUFJLEdBQUcsQ0FBQyxDQUFDO1lBQ1QsSUFBSSxHQUFHLE1BQU0sR0FBRyxNQUFNLENBQUM7U0FDMUI7UUFDRCxNQUFNLFNBQVMsR0FBRztZQUNkLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxhQUFhO1lBQ3ZCLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxhQUFhO1lBQ3ZCLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLEdBQUcsYUFBYTtZQUM5QixJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxHQUFHLGFBQWE7U0FDakMsQ0FBQztRQUNGLE1BQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQztRQUUzRSxPQUFPO1lBQ0gsTUFBTSxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsTUFBTTtTQUNwQyxDQUFDO0lBQ04sQ0FBQztJQUVPLGFBQWEsQ0FBQyxJQUFJLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsYUFBYTtRQUM3RCxNQUFNLGdCQUFnQixHQUFHLEdBQUcsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFO1lBQ2pELE1BQU0sVUFBVSxHQUFHLG9CQUFvQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQzVELE9BQU87Z0JBQ0gsR0FBRyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUM7Z0JBQzdCLEdBQUcsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDO2dCQUM3QixHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU07Z0JBQ25CLEdBQUc7YUFDTixDQUFDO1FBQ04sQ0FBQyxDQUFDLENBQUM7UUFDSCxNQUFNLGNBQWMsR0FBRyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUM7UUFDL0MsTUFBTSxjQUFjLEdBQUcsV0FBVyxDQUFDLGNBQWMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUN0RCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsY0FBYyxHQUFHLGNBQWMsRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUN0RCxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3ZDO1FBRUQsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNqQyxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2pDLE1BQU0saUJBQWlCLEdBQUcsYUFBYSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBRW5FLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxpQkFBaUIsRUFBRSxDQUFDO0lBQ25ELENBQUM7Q0FDSjtBQUVELE1BQU0sb0JBQW9CLEdBQUcsQ0FBQyxLQUFlLEVBQUUsSUFBYyxFQUFZLEVBQUU7SUFDdkUsTUFBTSxNQUFNLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDMUQsTUFBTSxNQUFNLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDMUQsTUFBTSxLQUFLLEdBQUcsQ0FBQyxHQUFHLE1BQU0sR0FBRyxDQUFDLENBQUM7SUFDN0IsTUFBTSxLQUFLLEdBQUcsQ0FBQyxHQUFHLE1BQU0sR0FBRyxDQUFDLENBQUM7SUFDN0IsT0FBTyxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztBQUMxQixDQUFDLENBQUM7QUFFRixNQUFNLHdDQUF3QyxHQUFHLENBQUMsRUFBeUIsRUFBRSxnQkFBNEIsRUFBRSxRQUFnQixFQUFFLEtBQWEsRUFBRSxpQkFBeUIsRUFBVSxFQUFFO0lBRTdLLE1BQU0sZUFBZSxHQUFHLEtBQUssQ0FBQztJQUM5QixNQUFNLHNCQUFzQixHQUFHLElBQUksT0FBTyxDQUFDLEVBQUUsRUFBRTs7Ozs7Ozs7Ozs7O1NBWTFDLEVBQUU7Ozs7Ozs7Ozs7Ozs7OztzQ0FlMkIsZUFBZTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1NBMkI1QyxDQUFDLENBQUM7SUFFUCxNQUFNLFFBQVEsR0FBRyxVQUFVLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ2xDLE1BQU0scUJBQXFCLEdBQUcsSUFBSSxNQUFNLENBQUMsc0JBQXNCLEVBQUU7UUFDN0QsSUFBSSxTQUFTLENBQUMsRUFBRSxFQUFFLHNCQUFzQixFQUFFLFlBQVksRUFBRSxRQUFRLENBQUMsUUFBUSxDQUFDO1FBQzFFLElBQUksU0FBUyxDQUFDLEVBQUUsRUFBRSxzQkFBc0IsRUFBRSxtQkFBbUIsRUFBRSxRQUFRLENBQUMsZ0JBQWdCLENBQUM7S0FDNUYsRUFBRTtRQUNDLElBQUksT0FBTyxDQUFDLEVBQUUsRUFBRSxzQkFBc0IsRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDcEUsSUFBSSxPQUFPLENBQUMsRUFBRSxFQUFFLHNCQUFzQixFQUFFLGdCQUFnQixFQUFFLEtBQUssRUFBRSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQzNGLElBQUksT0FBTyxDQUFDLEVBQUUsRUFBRSxzQkFBc0IsRUFBRSxZQUFZLEVBQUUsT0FBTyxFQUFFLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDMUUsSUFBSSxPQUFPLENBQUMsRUFBRSxFQUFFLHNCQUFzQixFQUFFLGVBQWUsRUFBRSxPQUFPLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0tBQ3pGLEVBQUU7UUFDQyxJQUFJLFdBQVcsQ0FBQyxFQUFFLEVBQUUsc0JBQXNCLEVBQUUsZUFBZSxFQUFFLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxDQUFDLENBQUM7S0FDdEYsRUFBRSxJQUFJLEtBQUssQ0FBQyxFQUFFLEVBQUUsUUFBUSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7SUFFMUMsT0FBTyxxQkFBcUIsQ0FBQztBQUNqQyxDQUFDLENBQUM7QUFFRixNQUFNLHdCQUF3QixHQUFHLENBQUMsRUFBeUIsRUFBRSxTQUFvQixFQUFFLE1BQWMsRUFBRSxNQUFlLEVBQUUsT0FBb0IsRUFBVSxFQUFFO0lBRWhKLE1BQU0sa0JBQWtCLEdBQUcsRUFBRSxDQUFDO0lBQzlCLE1BQU0sbUJBQW1CLEdBQUcsSUFBSSxPQUFPLENBQUMsRUFBRSxFQUFFOzs7Ozs7Ozs7O1NBVXZDLEVBQUU7OzhDQUVtQyxrQkFBa0I7NkNBQ25CLGtCQUFrQjs7Ozs7Ozs7Ozs7c0NBV3pCLGtCQUFrQjs7Ozs7Ozs7Ozs7Ozs7OztzQ0FnQmxCLGtCQUFrQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1NBMkIvQyxDQUFDLENBQUM7SUFFUCxNQUFNLGtCQUFrQixHQUFHLElBQUksTUFBTSxDQUFDLG1CQUFtQixFQUFFO1FBQ3ZELElBQUksU0FBUyxDQUFDLEVBQUUsRUFBRSxtQkFBbUIsRUFBRSxZQUFZLEVBQUUsVUFBVSxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUM7UUFDbkYsSUFBSSxTQUFTLENBQUMsRUFBRSxFQUFFLG1CQUFtQixFQUFFLGdCQUFnQixFQUFFLFVBQVUsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUMsZ0JBQWdCLENBQUM7S0FDbEcsRUFBRTtRQUNDLElBQUksT0FBTyxDQUFDLEVBQUUsRUFBRSxtQkFBbUIsRUFBRSxtQkFBbUIsRUFBRSxTQUFTLEVBQUUsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUMvRixJQUFJLE9BQU8sQ0FBQyxFQUFFLEVBQUUsbUJBQW1CLEVBQUUsbUJBQW1CLEVBQUUsUUFBUSxFQUFFLGdCQUFnQixDQUFFLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUUsQ0FBQztRQUNsSCxJQUFJLE9BQU8sQ0FBQyxFQUFFLEVBQUUsbUJBQW1CLEVBQUUscUJBQXFCLEVBQUUsS0FBSyxFQUFFLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3RGLElBQUksT0FBTyxDQUFDLEVBQUUsRUFBRSxtQkFBbUIsRUFBRSxZQUFZLEVBQUUsT0FBTyxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDckUsSUFBSSxPQUFPLENBQUMsRUFBRSxFQUFFLG1CQUFtQixFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDN0UsRUFBRTtRQUNDLElBQUksT0FBTyxDQUFDLEVBQUUsRUFBRSxtQkFBbUIsRUFBRSxnQkFBZ0IsRUFBRSxPQUFPLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7S0FDakYsQ0FBQyxDQUFDO0lBRUgsT0FBTyxrQkFBa0IsQ0FBQztBQUM5QixDQUFDLENBQUM7QUFHRixNQUFNLHVCQUF1QixHQUFHLENBQUMsRUFBeUIsRUFBRSxTQUFxQixFQUFFLFFBQW9CLEVBQUUsSUFBYyxFQUFFLE9BQW9CLEVBQVUsRUFBRTtJQUNySixNQUFNLGtCQUFrQixHQUFHLElBQUksT0FBTyxDQUFDLEVBQUUsRUFBRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7U0F1QnRDLEVBQUU7Ozs7Ozs7O1NBUUYsQ0FBQyxDQUFDO0lBRVAsTUFBTSxpQkFBaUIsR0FBRyxJQUFJLE1BQU0sQ0FBQyxrQkFBa0IsRUFBRTtRQUNyRCxJQUFJLFNBQVMsQ0FBQyxFQUFFLEVBQUUsa0JBQWtCLEVBQUUsT0FBTyxFQUFFLFVBQVUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDO1FBQ3pFLElBQUksU0FBUyxDQUFDLEVBQUUsRUFBRSxrQkFBa0IsRUFBRSxjQUFjLEVBQUUsVUFBVSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxnQkFBZ0IsQ0FBQztLQUMzRixFQUFFO1FBQ0MsSUFBSSxPQUFPLENBQUMsRUFBRSxFQUFFLGtCQUFrQixFQUFFLGFBQWEsRUFBRSxNQUFNLEVBQUUsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDdkYsSUFBSSxPQUFPLENBQUMsRUFBRSxFQUFFLGtCQUFrQixFQUFFLFlBQVksRUFBRSxNQUFNLEVBQUUsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDckYsSUFBSSxPQUFPLENBQUMsRUFBRSxFQUFFLGtCQUFrQixFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsSUFBSSxDQUFDO0tBQzlELEVBQUU7UUFDQyxJQUFJLE9BQU8sQ0FBQyxFQUFFLEVBQUUsa0JBQWtCLEVBQUUsV0FBVyxFQUFFLE9BQU8sQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztLQUMzRSxDQUFDLENBQUM7SUFFSCxPQUFPLGlCQUFpQixDQUFDO0FBQzdCLENBQUMsQ0FBQztBQUVGLE1BQU0sT0FBTyxHQUFHLENBQUMsR0FBZSxFQUFZLEVBQUU7SUFDMUMsTUFBTSxFQUFFLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzlCLE1BQU0sRUFBRSxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM5QixNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7SUFDN0IsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO0lBQzdCLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztJQUM3QixNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7SUFDN0IsT0FBTyxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ3BDLENBQUMsQ0FBQztBQUVGLE1BQU0sR0FBRyxHQUFHLENBQUMsSUFBVyxFQUFFLElBQVcsRUFBUyxFQUFFO0lBQzVDLE1BQU0sR0FBRyxHQUFHLEVBQUUsQ0FBQztJQUNmLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ2xDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ3JDO0lBQ0QsT0FBTyxHQUFHLENBQUM7QUFDZixDQUFDLENBQUM7QUFFRixNQUFNLG9CQUFvQixHQUFHLENBQUMsTUFBa0IsRUFBYyxFQUFFO0lBQzVELE1BQU0sTUFBTSxHQUFHLGVBQWUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDL0QsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDcEMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ3hDLE1BQU0sQ0FBQyxHQUFHLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDOUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNqQixNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ3BCO0tBQ0o7SUFDRCxPQUFPLE1BQU0sQ0FBQztBQUNsQixDQUFDLENBQUM7QUFFRixNQUFNLGtDQUFrQyxHQUFHLENBQUMsY0FBMEIsRUFBRSxNQUFrQixFQUFFLE1BQWdCLEVBQWdCLEVBQUU7SUFDMUgsTUFBTSxJQUFJLEdBQUcsV0FBVyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDM0MsTUFBTSxJQUFJLEdBQUcsZUFBZSxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzNDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ3BDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQzFELE1BQU0sZUFBZSxHQUFHLG1CQUFtQixDQUFDLENBQUMsRUFBRSxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNsRSxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ3hCLE1BQU0sRUFBRSxHQUFHLGVBQWUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDbEMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7U0FDaEU7S0FDSjtJQUNELE9BQU8sSUFBSSxDQUFDO0FBQ2hCLENBQUMsQ0FBQztBQUVGLE1BQU0sYUFBYSxHQUFHLENBQUMsQ0FBVyxFQUFFLENBQVcsRUFBVSxFQUFFO0lBQ3ZELE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM5RSxDQUFDLENBQUM7QUFFRixNQUFNLG1CQUFtQixHQUFHLENBQUMsQ0FBUyxFQUFFLE1BQWdCLEVBQVksRUFBRTtJQUNsRSxNQUFNLFFBQVEsR0FBRyxZQUFZLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ3pDLE1BQU0sT0FBTyxHQUFHLGlCQUFpQixDQUFDLFFBQVEsRUFBRSxNQUFNLENBQUMsQ0FBQztJQUNwRCxPQUFPLE9BQU8sQ0FBQztBQUNuQixDQUFDLENBQUM7QUFFRixNQUFNLGlCQUFpQixHQUFHLENBQUMsWUFBc0IsRUFBRSxTQUFtQixFQUFZLEVBQUU7SUFDaEYsT0FBTyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3BFLENBQUMsQ0FBQztBQUVGLE1BQU0sWUFBWSxHQUFHLENBQUMsQ0FBUyxFQUFFLE1BQWdCLEVBQVksRUFBRTtJQUMzRCxPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBUyxDQUFDLEVBQUUsQ0FBQyxJQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDcEUsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRmVhdHVyZSB9IGZyb20gJ29sJztcbmltcG9ydCB7IEZyYW1lU3RhdGUgfSBmcm9tICdvbC9QbHVnZ2FibGVNYXAnO1xuaW1wb3J0IExheWVyUmVuZGVyZXIgZnJvbSAnb2wvcmVuZGVyZXIvTGF5ZXInO1xuaW1wb3J0IENhbnZhc1ZlY3RvckxheWVyUmVuZGVyZXIgZnJvbSAnb2wvcmVuZGVyZXIvY2FudmFzL1ZlY3RvckxheWVyJztcbmltcG9ydCBWZWN0b3JMYXllciBmcm9tICdvbC9sYXllci9WZWN0b3InO1xuaW1wb3J0IEdlb21ldHJ5IGZyb20gJ29sL2dlb20vR2VvbWV0cnknO1xuaW1wb3J0IFBvaW50IGZyb20gJ29sL2dlb20vUG9pbnQnO1xuaW1wb3J0IHsgVmVjdG9yIGFzIFZlY3RvclNvdXJjZSwgQ2x1c3RlciBhcyBvbENsdXN0ZXIgfSBmcm9tICdvbC9zb3VyY2UnO1xuaW1wb3J0IHsgcmVwbGFjZUNoaWxkcmVuIH0gZnJvbSAnb2wvZG9tJztcbmltcG9ydCB7IFByb2plY3Rpb24gfSBmcm9tICdvbC9wcm9qJztcbmltcG9ydCB7IFNoYWRlciwgRnJhbWVidWZmZXIsIFByb2dyYW0sIFVuaWZvcm0sIEluZGV4LCBUZXh0dXJlLCBBdHRyaWJ1dGUsIERhdGFUZXh0dXJlIH0gZnJvbSAnLi4vLi4vd2ViZ2wvZW5naW5lLmNvcmUnO1xuaW1wb3J0IHsgRnJhbWVidWZmZXJPYmplY3QsIGdldEN1cnJlbnRGcmFtZWJ1ZmZlcnNQaXhlbHMgfSBmcm9tICcuLi8uLi93ZWJnbC93ZWJnbCc7XG5pbXBvcnQgeyByZWN0YW5nbGVBLCByZWN0YW5nbGVFIH0gZnJvbSAnLi4vLi4vd2ViZ2wvZW5naW5lLnNoYXBlcyc7XG5pbXBvcnQgeyBuZXh0UG93ZXJPZiwgZmxhdHRlblJlY3Vyc2l2ZSwgY3JlYXRlTkRpbUFycmF5IH0gZnJvbSAnLi4vLi4vd2ViZ2wvdXRpbHMnO1xuXG5cblxuXG5leHBvcnQgdHlwZSBDb2xvclJhbXAgPSB7dmFsOiBudW1iZXIsIHJnYjogW251bWJlciwgbnVtYmVyLCBudW1iZXJdfVtdO1xuXG5cblxuZXhwb3J0IGludGVyZmFjZSBJbnRlcnBvbGF0aW9uTGF5ZXJPcHRpb25zIHtcbiAgICBzb3VyY2U6IFZlY3RvclNvdXJjZTxQb2ludD47XG4gICAgcmVuZGVyU2V0dGluZ3M6IEludGVycG9sYXRpb25SZW5kZXJlclNldHRpbmdzO1xuICAgIFtrZXk6IHN0cmluZ106IGFueTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbnRlcnBvbGF0aW9uUmVuZGVyZXJTZXR0aW5ncyB7XG4gICAgLyoqIG1heGltdW0gZGlzdGFuY2UgZm9yIGludGVycG9sYXRpb24gKi9cbiAgICBtYXhFZGdlTGVuZ3RoOiBudW1iZXI7XG4gICAgcG93ZXI6IG51bWJlcjtcbiAgICAvKiogYHZhbGAvYGNvbG9yYCBwYWlycy4gYSBnaXZlbiBgY29sb3JgIGlzIHVzZWQgZm9yIGFsbCB2YWx1ZXMgc3RyaWN0bHkgc21hbGxlciB0aGFuIGB2YWxgLiAgKi9cbiAgICBjb2xvclJhbXA6IENvbG9yUmFtcDtcbiAgICAvKiogc2hvdyBhIHNtb290aCBjb2xvci1ncmFkaWVudCBvciBpc29saW5lcz8gKi9cbiAgICBzbW9vdGg6IGJvb2xlYW47XG4gICAgLyoqIHdoaWNoIGZlYXR1cmUtcHJvcGVydHkgc2hvdWxkIGJlIGludGVycG9sYXRlZD8gKi9cbiAgICB2YWx1ZVByb3BlcnR5OiBzdHJpbmc7XG4gICAgc2hvd0xhYmVsczogYm9vbGVhbjtcbiAgICAvKiogYWxsb3dzIHlvdSB0byByZWFkIG91dCBpbnRlcnBvbGF0ZWQgcGl4ZWwgdmFsdWVzLCBidXQgYmFkIGZvciBwZXJmb3JtYW5jZSAqL1xuICAgIHN0b3JlSW50ZXJwb2xhdGVkUGl4ZWxEYXRhOiBib29sZWFuO1xufVxuXG5cbmV4cG9ydCBjbGFzcyBJbnRlcnBvbGF0aW9uTGF5ZXIgZXh0ZW5kcyBWZWN0b3JMYXllcjxWZWN0b3JTb3VyY2U8R2VvbWV0cnk+PiB7XG5cbiAgICByZWFkb25seSBvcHRpb25zOiBJbnRlcnBvbGF0aW9uTGF5ZXJPcHRpb25zO1xuXG4gICAgY29uc3RydWN0b3Iob3B0aW9uczogSW50ZXJwb2xhdGlvbkxheWVyT3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG5cbiAgICBjcmVhdGVSZW5kZXJlcigpOiBJbnRlcnBvbGF0aW9uUmVuZGVyZXIge1xuICAgICAgICByZXR1cm4gbmV3IEludGVycG9sYXRpb25SZW5kZXJlcih0aGlzLCB0aGlzLm9wdGlvbnMucmVuZGVyU2V0dGluZ3MpO1xuICAgIH1cblxuICAgIHVwZGF0ZVBhcmFzKHBvd2VyOiBudW1iZXIsIHNtb290aDogYm9vbGVhbiwgc2hvd0xhYmVsczogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICBjb25zdCBuZXdTZXR0aW5nczogSW50ZXJwb2xhdGlvblJlbmRlcmVyU2V0dGluZ3MgPSB7XG4gICAgICAgICAgICBjb2xvclJhbXA6IHRoaXMub3B0aW9ucy5yZW5kZXJTZXR0aW5ncy5jb2xvclJhbXAsXG4gICAgICAgICAgICBtYXhFZGdlTGVuZ3RoOiB0aGlzLm9wdGlvbnMucmVuZGVyU2V0dGluZ3MubWF4RWRnZUxlbmd0aCxcbiAgICAgICAgICAgIHN0b3JlSW50ZXJwb2xhdGVkUGl4ZWxEYXRhOiB0aGlzLm9wdGlvbnMucmVuZGVyU2V0dGluZ3Muc3RvcmVJbnRlcnBvbGF0ZWRQaXhlbERhdGEsXG4gICAgICAgICAgICB2YWx1ZVByb3BlcnR5OiB0aGlzLm9wdGlvbnMucmVuZGVyU2V0dGluZ3MudmFsdWVQcm9wZXJ0eSxcbiAgICAgICAgICAgIHBvd2VyOiBwb3dlcixcbiAgICAgICAgICAgIHNob3dMYWJlbHM6IHNob3dMYWJlbHMsXG4gICAgICAgICAgICBzbW9vdGg6IHNtb290aCxcbiAgICAgICAgfTtcbiAgICAgICAgKHN1cGVyLmdldFJlbmRlcmVyKCkgYXMgbmV2ZXIgYXMgSW50ZXJwb2xhdGlvblJlbmRlcmVyKS51cGRhdGVTZXR0aW5ncyhuZXdTZXR0aW5ncyk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5yZW5kZXJTZXR0aW5ncyA9IG5ld1NldHRpbmdzO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGlzIHJlbmRlcmVyIHJ1bnMgdGhyZWUgc2hhZGVycyBpbiBhIHJvdy5cbiAqICAxLiBpbnRlcnBvbGF0aW9uU2hhZGVyOiB0YWtlcyBldmVyeSBvYnNlcnZhdGlvbiBhdCBldmVyeSBwaXhlbCBhbmQgZXhlY3V0ZXMgdGhlIGludGVycG9sYXRpb24uIFRoZSB2YWx1ZXMgYXJlIHN0b3JlZCBpbiBgdmFsdWVGYmAuXG4gKiAgMi4gY29sb3JpemF0aW9uU2hhZGVyOiB1c2VzIHRoZSBpbnRlcnBvbGF0ZWQgdmFsdWVzIGZyb20gdmFsdWVGYiB0byBhcHBseSB0aGUgY29sb3JpemF0aW9uIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gY29sb3JSYW1wIGFuZCBzbW9vdGhpbmctb3B0aW9ucy5cbiAqICAzLiBhcnJhbmdlbWVudFNoYWRlcjogdGhlIHByZXZpb3VzIHNoYWRlcnMgaGF2ZSBtb3ZlZCB0aGUgZGF0YSBpbiB0aGUgY2VudGVyIG9mIHRoZSBjYW52YXMuIHRoaXMgc2hhZGVyIG5vdyBhcnJhbmdlcyB0aGUgcGl4ZWxzIHRvIHRoZSBjb3JyZWN0IHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBtYXAuXG4gKlxuICogT25seSB0aGUgdGhpcmQgc2hhZGVyIG5lZWRzIHRvIGJlIGV4ZWN1dGVkIHdpdGggZXZlcnkgZnJhbWUuIFRoaXMgd2F5LCB0aGUgb3BlcmF0aW9uLWhlYXZ5IGludGVycG9sYXRpb24gZG9lcyBub3Qgc2xvdyBkb3duIHRoZSBtYXAuXG4gKiBJdCBnZW5lcmFsbHkgbWFrZXMgc2Vuc2UgdG8gYXJyYW5nZSBzaGFkZXJzIGluIHN1Y2ggYSB3YXkgdGhhdCBhbGwgb3BlbmxheWVycy1wZXJzcGVjdGl2ZS1vcGVyYXRpb25zIG9jY3VyIGluIHRoZSBsYXN0IHNoYWRlci5cbiAqXG4gKiB2YWx1ZUZiIGlzIGFsc28gYmVpbmcgdXNlZCB0byBoYW5kbGUgY2xpY2sgZXZlbnRzOiBmcm9tIHRoaXMgc3RydWN0dXJlIHdlIGdldCB0aGUgYWN0dWFsIHZhbHVlIGF0IGEgcGl4ZWwgd2hlbiB0aGUgdXNlciBjbGlja3MuXG4gKlxuICogTm90ZSBhIGZldyBjYXZlYXRzLlxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgcmVhbGx5IGludGVuZGVkIGZvciB1cGRhdGluZyBvYnNlcnZhdGlvbnMsIG1heEVkZ2VMZW5ndGggb3IgY29sb3JSYW1wcyBhdCBydW50aW1lLiBUaGVzZSBwYXJhbWV0ZXJzIGFyZSByYXRoZXIgaW50ZW5kZWQgZm9yIHRoZSBkZXZlbG9wZXIgdG8gc2V0IG9uY2UuXG4gKiBXaGlsZSB5b3UgY2FuIGNoYW5nZSB0aGUgY29sb3ItcmFtcCBhdCBydW50aW1lLCBpdCdzIGxlbmd0aCBpcyBoYXJkY29kZWQgaW4gdGhlIGNvbG9yaXphdGlvbiBzaGFkZXIsIHNvIHlvdSdkIGhhdmUgdG8gcmVjb21waWxlIGl0IHRvIHByb3Blcmx5IHJlZmxlY3QgdGhlIG5ldyByYW1wLlxuICogSW4gdGhlIHNhbWUgd2F5LCB0aGUgaW50ZXJwb2xhdGlvbi1zaGFkZXIgaGFzIHRoZSBudW1iZXIgb2Ygb2JzZXJ2YXRpb25zIGJha2VkIGludG8gaXQuIFdoZW4gbmV3IGRhdGEgYmVjb21lcyBhdmFpbGFibGUsIHlvdSBtdXN0IHJlY29tcGlsZSB0aGUgaW50ZXJwb2xhdGlvbiBzaGFkZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnRlcnBvbGF0aW9uUmVuZGVyZXIgZXh0ZW5kcyBMYXllclJlbmRlcmVyPCBWZWN0b3JMYXllcjxWZWN0b3JTb3VyY2U8R2VvbWV0cnk+Pj4ge1xuXG4gICAgcHJpdmF0ZSBjb250YWluZXI6IEhUTUxEaXZFbGVtZW50O1xuICAgIHByaXZhdGUgcG9pbnRSZW5kZXJlcjogQ2FudmFzVmVjdG9yTGF5ZXJSZW5kZXJlcjtcbiAgICBwcml2YXRlIHdlYkdsQ2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudDtcbiAgICBwcml2YXRlIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQ7XG4gICAgcHJpdmF0ZSBpbnRlcnBvbGF0aW9uU2hhZGVyOiBTaGFkZXI7XG4gICAgcHJpdmF0ZSB2YWx1ZUZiOiBGcmFtZWJ1ZmZlcjtcbiAgICBwcml2YXRlIGNvbG9yaXphdGlvblNoYWRlcjogU2hhZGVyO1xuICAgIHByaXZhdGUgY29sb3JGYjogRnJhbWVidWZmZXI7XG4gICAgcHJpdmF0ZSBhcnJhbmdlbWVudFNoYWRlcjogU2hhZGVyO1xuICAgIHByaXZhdGUgaW50ZXJwb2xhdGVkVmFsdWVzOiBVaW50OEFycmF5O1xuXG4gICAgcHJpdmF0ZSBwcm9qZWN0aW9uOiBQcm9qZWN0aW9uO1xuICAgIHByaXZhdGUgYmJveDogbnVtYmVyW107XG5cbiAgICBjb25zdHJ1Y3RvcihsYXllcjogVmVjdG9yTGF5ZXI8VmVjdG9yU291cmNlPEdlb21ldHJ5Pj4sIHByaXZhdGUgc2V0dGluZ3M6IEludGVycG9sYXRpb25SZW5kZXJlclNldHRpbmdzKSB7XG4gICAgICAgIHN1cGVyKGxheWVyKTtcblxuICAgICAgICAvLyBzZXR0aW5nIHVwIEhUTUwgZWxlbWVudFxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdvbC1sYXllcicpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5zZXRQcm9wZXJ0eSgncG9zaXRpb24nLCAnYWJzb2x1dGUnKTtcbiAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUuc2V0UHJvcGVydHkoJ3dpZHRoJywgJzEwMCUnKTtcbiAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUuc2V0UHJvcGVydHkoJ2hlaWdodCcsICcxMDAlJyk7XG5cbiAgICAgICAgdGhpcy53ZWJHbENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICB0aGlzLndlYkdsQ2FudmFzLnN0eWxlLnNldFByb3BlcnR5KCdwb3NpdGlvbicsICdhYnNvbHV0ZScpO1xuICAgICAgICB0aGlzLndlYkdsQ2FudmFzLnN0eWxlLnNldFByb3BlcnR5KCdsZWZ0JywgJzBweCcpO1xuICAgICAgICB0aGlzLndlYkdsQ2FudmFzLnN0eWxlLnNldFByb3BlcnR5KCd0b3AnLCAnMHB4Jyk7XG4gICAgICAgIHRoaXMud2ViR2xDYW52YXMuc3R5bGUuc2V0UHJvcGVydHkoJ3dpZHRoJywgJzEwMCUnKTtcbiAgICAgICAgdGhpcy53ZWJHbENhbnZhcy5zdHlsZS5zZXRQcm9wZXJ0eSgnaGVpZ2h0JywgJzEwMCUnKTtcbiAgICAgICAgdGhpcy53ZWJHbENhbnZhcy53aWR0aCA9IDEwMDA7ICAvLyA8LS0gbWFrZSBzbWFsbGVyIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VcbiAgICAgICAgdGhpcy53ZWJHbENhbnZhcy5oZWlnaHQgPSAxMDAwOyAgLy8gPC0tIG1ha2Ugc21hbGxlciBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlXG4gICAgICAgIHRoaXMuZ2wgPSB0aGlzLndlYkdsQ2FudmFzLmdldENvbnRleHQoJ3dlYmdsJyk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMud2ViR2xDYW52YXMpO1xuXG4gICAgICAgIC8vIHNldHRpbmcgdXAgcG9pbnQtcmVuZGVyZXJcbiAgICAgICAgdGhpcy5wb2ludFJlbmRlcmVyID0gbmV3IENhbnZhc1ZlY3RvckxheWVyUmVuZGVyZXIobGF5ZXIpO1xuXG4gICAgICAgIC8vIHByZXBhcmluZyBkYXRhXG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IGxheWVyLmdldFNvdXJjZSgpO1xuICAgICAgICB0aGlzLnByb2plY3Rpb24gPSBzb3VyY2UuZ2V0UHJvamVjdGlvbigpO1xuICAgICAgICBjb25zdCB7IGNvb3JkcywgdmFsdWVzLCBiYm94RGVsdGEsIG1heFZhbCB9ID0gdGhpcy5wYXJzZURhdGEoc291cmNlLCB0aGlzLnNldHRpbmdzLnZhbHVlUHJvcGVydHksIHRoaXMuc2V0dGluZ3MubWF4RWRnZUxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHsgb2JzZXJ2YXRpb25zQmJveCwgbWF4RWRnZUxlbmd0aEJib3ggfSA9IHRoaXMucGFyc2VEYXRhQmJveChiYm94RGVsdGEsIGNvb3JkcywgdmFsdWVzLCBtYXhWYWwsIHRoaXMuc2V0dGluZ3MubWF4RWRnZUxlbmd0aCk7XG4gICAgICAgIHRoaXMuYmJveCA9IGJib3hEZWx0YTtcblxuICAgICAgICAvLyBzZXR0aW5nIHVwIHNoYWRlcnNcbiAgICAgICAgY29uc3QgaWRlbnRpdHkgPSBbWzEsIDAsIDBdLCBbMCwgMSwgMF0sIFswLCAwLCAxXV07XG4gICAgICAgIHRoaXMuaW50ZXJwb2xhdGlvblNoYWRlciA9IGNyZWF0ZUludmVyc2VEaXN0YW5jZUludGVycG9sYXRpb25TaGFkZXIodGhpcy5nbCwgb2JzZXJ2YXRpb25zQmJveCwgbWF4VmFsLCB0aGlzLnNldHRpbmdzLnBvd2VyLCBtYXhFZGdlTGVuZ3RoQmJveCk7XG4gICAgICAgIHRoaXMudmFsdWVGYiA9IG5ldyBGcmFtZWJ1ZmZlcih0aGlzLmdsLCB0aGlzLndlYkdsQ2FudmFzLndpZHRoLCB0aGlzLndlYkdsQ2FudmFzLmhlaWdodCk7XG4gICAgICAgIHRoaXMuY29sb3JpemF0aW9uU2hhZGVyID0gY3JlYXRlQ29sb3JpemF0aW9uU2hhZGVyKHRoaXMuZ2wsIHRoaXMuc2V0dGluZ3MuY29sb3JSYW1wLCBtYXhWYWwsIHRoaXMuc2V0dGluZ3Muc21vb3RoLCB0aGlzLnZhbHVlRmIpO1xuICAgICAgICB0aGlzLmNvbG9yRmIgPSBuZXcgRnJhbWVidWZmZXIodGhpcy5nbCwgdGhpcy53ZWJHbENhbnZhcy53aWR0aCwgdGhpcy53ZWJHbENhbnZhcy5oZWlnaHQpO1xuICAgICAgICB0aGlzLmFycmFuZ2VtZW50U2hhZGVyID0gY3JlYXRlQXJyYW5nZW1lbnRTaGFkZXIodGhpcy5nbCwgaWRlbnRpdHksIGlkZW50aXR5LCBiYm94RGVsdGEsIHRoaXMuY29sb3JGYik7XG5cbiAgICAgICAgLy8gcnVubmluZyBmaXJzdCB0d28gc2hhZGVycyBvbmNlXG4gICAgICAgIHRoaXMucnVuSW50ZXJwb2xhdGlvblNoYWRlcih0aGlzLnZhbHVlRmIuZmJvKTtcbiAgICAgICAgdGhpcy5ydW5Db2xvcml6YXRpb25TaGFkZXIodGhpcy5jb2xvckZiLmZibyk7XG4gICAgfVxuXG4gICAgcHJlcGFyZUZyYW1lKGZyYW1lU3RhdGU6IEZyYW1lU3RhdGUpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgbGF5ZXJTdGF0ZSA9IGZyYW1lU3RhdGUubGF5ZXJTdGF0ZXNBcnJheVtmcmFtZVN0YXRlLmxheWVySW5kZXhdO1xuICAgICAgICB0aGlzLndlYkdsQ2FudmFzLnN0eWxlLm9wYWNpdHkgPSBgJHtsYXllclN0YXRlLm9wYWNpdHl9YDtcblxuICAgICAgICBpZiAoZnJhbWVTdGF0ZS52aWV3U3RhdGUucHJvamVjdGlvbiAhPT0gdGhpcy5wcm9qZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnByb2plY3Rpb24gPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZS5wcm9qZWN0aW9uO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlID0gc3VwZXIuZ2V0TGF5ZXIoKS5nZXRTb3VyY2UoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgY29vcmRzLCB2YWx1ZXMsIGJib3hEZWx0YSwgbWF4VmFsIH0gPSB0aGlzLnBhcnNlRGF0YShzb3VyY2UsIHRoaXMuc2V0dGluZ3MudmFsdWVQcm9wZXJ0eSwgdGhpcy5zZXR0aW5ncy5tYXhFZGdlTGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgb2JzZXJ2YXRpb25zQmJveCwgbWF4RWRnZUxlbmd0aEJib3ggfSA9IHRoaXMucGFyc2VEYXRhQmJveChiYm94RGVsdGEsIGNvb3JkcywgdmFsdWVzLCBtYXhWYWwsIHRoaXMuc2V0dGluZ3MubWF4RWRnZUxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUludGVycG9sYXRpb25TaGFkZXIodGhpcy5zZXR0aW5ncy5wb3dlciwgb2JzZXJ2YXRpb25zQmJveCwgbWF4RWRnZUxlbmd0aEJib3gpO1xuICAgICAgICAgICAgdGhpcy5ydW5JbnRlcnBvbGF0aW9uU2hhZGVyKHRoaXMudmFsdWVGYi5mYm8pO1xuICAgICAgICAgICAgdGhpcy5ydW5Db2xvcml6YXRpb25TaGFkZXIodGhpcy5jb2xvckZiLmZibyk7XG4gICAgICAgICAgICB0aGlzLmJib3ggPSBiYm94RGVsdGE7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjMnBUID0gZnJhbWVTdGF0ZS5jb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybTtcbiAgICAgICAgLy8gdXNpbmcgZnJhbWVTdGF0ZS5zaXplIGluc3RlYWQgb2YgdGhpcy53ZWJHbENhbnZhcy5jbGllbnRXaWR0aCBiZWNhdXNlIHRoZSBsYXR0ZXIgaXMgbnVsbCB3aGVuIGxheWVyIGludmlzaWJsZS5cbiAgICAgICAgdGhpcy51cGRhdGVBcnJhbmdlbWVudFNoYWRlcihjMnBULCBmcmFtZVN0YXRlLnNpemVbMF0sIGZyYW1lU3RhdGUuc2l6ZVsxXSwgdGhpcy5iYm94KTtcbiAgICAgICAgdGhpcy5wb2ludFJlbmRlcmVyLnByZXBhcmVGcmFtZShmcmFtZVN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmVuZGVyRnJhbWUoZnJhbWVTdGF0ZTogRnJhbWVTdGF0ZSwgdGFyZ2V0OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50IHtcbiAgICAgICAgdGhpcy5ydW5BcnJhbmdlbWVudFNoYWRlcigpOyAgLy8gQHRvZG86IGFycmFuZ2VtZW50IHNoYWRlciBjb3VsZCBiZSByZXBsYWNlZCB3aXRoIGEgc2ltcGxlIGNzcy10cmFuc2Zvcm1hdGlvbi1tYXRyaXguXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnNob3dMYWJlbHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50Q2FudmFzID0gdGhpcy5wb2ludFJlbmRlcmVyLnJlbmRlckZyYW1lKGZyYW1lU3RhdGUsIHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgICAgIHJlcGxhY2VDaGlsZHJlbih0aGlzLmNvbnRhaW5lciwgW3RoaXMud2ViR2xDYW52YXMsIHBvaW50Q2FudmFzXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXBsYWNlQ2hpbGRyZW4odGhpcy5jb250YWluZXIsIFt0aGlzLndlYkdsQ2FudmFzXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICAgIH1cblxuICAgIHJlbmRlckRlY2x1dHRlcihmcmFtZVN0YXRlOiBGcmFtZVN0YXRlKSB7XG4gICAgfVxuXG4gICAgcHVibGljIHVwZGF0ZVNldHRpbmdzKG5ld1NldHRpbmdzOiBJbnRlcnBvbGF0aW9uUmVuZGVyZXJTZXR0aW5ncykge1xuICAgICAgICBjb25zdCBvbGRTZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3M7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBuZXdTZXR0aW5ncztcbiAgICAgICAgaWYgKG5ld1NldHRpbmdzLnBvd2VyICE9PSBvbGRTZXR0aW5ncy5wb3dlcikge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVJbnRlcnBvbGF0aW9uU2hhZGVyKG5ld1NldHRpbmdzLnBvd2VyKTtcbiAgICAgICAgICAgIHRoaXMucnVuSW50ZXJwb2xhdGlvblNoYWRlcih0aGlzLnZhbHVlRmIuZmJvKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29sb3JpemF0aW9uU2hhZGVyKG5ld1NldHRpbmdzLnNtb290aCk7XG4gICAgICAgICAgICB0aGlzLnJ1bkNvbG9yaXphdGlvblNoYWRlcih0aGlzLmNvbG9yRmIuZmJvKTtcbiAgICAgICAgfSBlbHNlIGlmIChuZXdTZXR0aW5ncy5zbW9vdGggIT09IG9sZFNldHRpbmdzLnNtb290aCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVDb2xvcml6YXRpb25TaGFkZXIobmV3U2V0dGluZ3Muc21vb3RoKTtcbiAgICAgICAgICAgIHRoaXMucnVuQ29sb3JpemF0aW9uU2hhZGVyKHRoaXMuY29sb3JGYi5mYm8pO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLmdldExheWVyKCkuY2hhbmdlZCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBhdCBldmVyeSByZW5kZXJGcmFtZS4gRmFzdC5cbiAgICAgKi9cbiAgICBwcml2YXRlIHVwZGF0ZUFycmFuZ2VtZW50U2hhZGVyKGNvb3JkaW5hdGVUb1BpeGVsVHJhbnNmb3JtOiBudW1iZXJbXSwgY2FudmFzV2lkdGg6IG51bWJlciwgY2FudmFzSGVpZ2h0OiBudW1iZXIsIGJib3g6IG51bWJlcltdKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHdvcmxkMnBpeCA9IFtcbiAgICAgICAgICAgIFtjb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybVswXSwgY29vcmRpbmF0ZVRvUGl4ZWxUcmFuc2Zvcm1bMV0sIDAuXSxcbiAgICAgICAgICAgIFtjb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybVsyXSwgY29vcmRpbmF0ZVRvUGl4ZWxUcmFuc2Zvcm1bM10sIDAuXSxcbiAgICAgICAgICAgIFtjb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybVs0XSwgY29vcmRpbmF0ZVRvUGl4ZWxUcmFuc2Zvcm1bNV0sIDEuXVxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBwaXgyY2xpcCA9IFtcbiAgICAgICAgICAgIFsxLiAvIChjYW52YXNXaWR0aCAvIDIpLCAwLiwgMC5dLFxuICAgICAgICAgICAgWzAsIC0xLiAvIChjYW52YXNIZWlnaHQgLyAyKSwgMC5dLFxuICAgICAgICAgICAgWy0xLiwgMS4sIDEuXVxuICAgICAgICBdO1xuICAgICAgICB0aGlzLmFycmFuZ2VtZW50U2hhZGVyLnVwZGF0ZVVuaWZvcm1EYXRhKHRoaXMuZ2wsICd1X3dvcmxkMnBpeCcsIGZsYXR0ZW5SZWN1cnNpdmUod29ybGQycGl4KSk7XG4gICAgICAgIHRoaXMuYXJyYW5nZW1lbnRTaGFkZXIudXBkYXRlVW5pZm9ybURhdGEodGhpcy5nbCwgJ3VfcGl4MmNsaXAnLCBmbGF0dGVuUmVjdXJzaXZlKHBpeDJjbGlwKSk7XG4gICAgICAgIHRoaXMuYXJyYW5nZW1lbnRTaGFkZXIudXBkYXRlVW5pZm9ybURhdGEodGhpcy5nbCwgJ3VfYmJveCcsIGJib3gpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBhdCBldmVyeSByZW5kZXJGcmFtZS4gRmFzdC5cbiAgICAgKi9cbiAgICBwcml2YXRlIHJ1bkFycmFuZ2VtZW50U2hhZGVyKHRhcmdldD86IEZyYW1lYnVmZmVyT2JqZWN0KTogdm9pZCB7XG4gICAgICAgIHRoaXMuYXJyYW5nZW1lbnRTaGFkZXIuYmluZCh0aGlzLmdsKTtcbiAgICAgICAgdGhpcy5hcnJhbmdlbWVudFNoYWRlci5yZW5kZXIodGhpcy5nbCwgWzAsIDAsIDAsIDBdLCB0YXJnZXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNsb3chIEF2b2lkIGNhbGxpbmcgdGhpcyB0b28gb2Z0ZW4uXG4gICAgICovXG4gICAgcHJpdmF0ZSB1cGRhdGVJbnRlcnBvbGF0aW9uU2hhZGVyKHBvd2VyOiBudW1iZXIsIG9ic2VydmF0aW9ucz86IG51bWJlcltdW10sIG1heEVkZ2VMZW5ndGhCYm94PzogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaW50ZXJwb2xhdGlvblNoYWRlci51cGRhdGVVbmlmb3JtRGF0YSh0aGlzLmdsLCAndV9wb3dlcicsIFtwb3dlcl0pO1xuICAgICAgICBpZiAob2JzZXJ2YXRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmludGVycG9sYXRpb25TaGFkZXIudXBkYXRlVGV4dHVyZURhdGEodGhpcy5nbCwgJ3VfZGF0YVRleHR1cmUnLCBbb2JzZXJ2YXRpb25zXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heEVkZ2VMZW5ndGhCYm94KSB7XG4gICAgICAgICAgICB0aGlzLmludGVycG9sYXRpb25TaGFkZXIudXBkYXRlVW5pZm9ybURhdGEodGhpcy5nbCwgJ3VfbWF4RGlzdGFuY2UnLCBbbWF4RWRnZUxlbmd0aEJib3hdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNsb3chIEF2b2lkIGNhbGxpbmcgdGhpcyB0b28gb2Z0ZW4uXG4gICAgICovXG4gICAgcHJpdmF0ZSBydW5JbnRlcnBvbGF0aW9uU2hhZGVyKHRhcmdldD86IEZyYW1lYnVmZmVyT2JqZWN0KTogdm9pZCB7XG4gICAgICAgIHRoaXMuaW50ZXJwb2xhdGlvblNoYWRlci5iaW5kKHRoaXMuZ2wpO1xuICAgICAgICB0aGlzLmludGVycG9sYXRpb25TaGFkZXIucmVuZGVyKHRoaXMuZ2wsIFswLCAwLCAwLCAwXSwgdGFyZ2V0KTtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc3RvcmVJbnRlcnBvbGF0ZWRQaXhlbERhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJwb2xhdGVkVmFsdWVzID0gZ2V0Q3VycmVudEZyYW1lYnVmZmVyc1BpeGVscyh0aGlzLndlYkdsQ2FudmFzKSBhcyBVaW50OEFycmF5O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2xvdyEgQXZvaWQgY2FsbGluZyB0aGlzIHRvbyBvZnRlbi5cbiAgICAgKi9cbiAgICBwcml2YXRlIHVwZGF0ZUNvbG9yaXphdGlvblNoYWRlcihzbW9vdGg6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgLy8gdGhpcy5jb2xvcml6YXRpb25TaGFkZXIudXBkYXRlVW5pZm9ybURhdGEodGhpcy5nbCwgJ3VfY29sb3JSYW1wVmFsdWVzJywgY29sb3JSYW1wLm1hcChlID0+IGUudmFsKSk7XG4gICAgICAgIC8vIHRoaXMuY29sb3JpemF0aW9uU2hhZGVyLnVwZGF0ZVVuaWZvcm1EYXRhKHRoaXMuZ2wsICd1X2NvbG9yUmFtcENvbG9ycycsIGZsYXR0ZW5SZWN1cnNpdmUoIGNvbG9yUmFtcC5tYXAoZSA9PiBlLnJnYikgKSk7XG4gICAgICAgIHRoaXMuY29sb3JpemF0aW9uU2hhZGVyLnVwZGF0ZVVuaWZvcm1EYXRhKHRoaXMuZ2wsICd1X3Ntb290aCcsIFtzbW9vdGggPyAxIDogMF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNsb3chIEF2b2lkIGNhbGxpbmcgdGhpcyB0b28gb2Z0ZW4uXG4gICAgICovXG4gICAgcHJpdmF0ZSBydW5Db2xvcml6YXRpb25TaGFkZXIodGFyZ2V0PzogRnJhbWVidWZmZXJPYmplY3QpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jb2xvcml6YXRpb25TaGFkZXIuYmluZCh0aGlzLmdsKTtcbiAgICAgICAgdGhpcy5jb2xvcml6YXRpb25TaGFkZXIucmVuZGVyKHRoaXMuZ2wsIFswLCAwLCAwLCAwXSwgdGFyZ2V0KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHBhcnNlRGF0YShzb3VyY2UsIHZhbHVlUHJvcGVydHk6IHN0cmluZywgbWF4RWRnZUxlbmd0aDogbnVtYmVyKSB7XG4gICAgICAgIGxldCBmZWF0dXJlczogRmVhdHVyZTxQb2ludD5bXSA9IHNvdXJjZS5nZXRGZWF0dXJlcygpIGFzIEZlYXR1cmU8UG9pbnQ+W107XG4gICAgICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBvbENsdXN0ZXIpIHtcbiAgICAgICAgICAgIGZlYXR1cmVzID0gc291cmNlLmdldFNvdXJjZSgpLmdldEZlYXR1cmVzKCkgYXMgRmVhdHVyZTxQb2ludD5bXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZlYXR1cmVzID0gc291cmNlLmdldEZlYXR1cmVzKCkgYXMgRmVhdHVyZTxQb2ludD5bXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvb3JkcyA9IGZlYXR1cmVzLm1hcChmID0+IGYuZ2V0R2VvbWV0cnkoKS5nZXRDb29yZGluYXRlcygpKTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gZmVhdHVyZXMubWFwKGYgPT4gcGFyc2VGbG9hdChmLmdldFByb3BlcnRpZXMoKVt2YWx1ZVByb3BlcnR5XSkpO1xuXG4gICAgICAgIGNvbnN0IGJib3ggPSBnZXRCYm94KGNvb3Jkcyk7XG4gICAgICAgIGNvbnN0IGRlbHRhWCA9IGJib3hbMl0gLSBiYm94WzBdO1xuICAgICAgICBjb25zdCBkZWx0YVkgPSBiYm94WzNdIC0gYmJveFsxXTtcbiAgICAgICAgbGV0IGFkZFg6IG51bWJlciwgYWRkWTogbnVtYmVyO1xuICAgICAgICBpZiAoZGVsdGFYID4gZGVsdGFZKSB7XG4gICAgICAgICAgICBhZGRZID0gZGVsdGFYIC0gZGVsdGFZO1xuICAgICAgICAgICAgYWRkWCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGRZID0gMDtcbiAgICAgICAgICAgIGFkZFggPSBkZWx0YVkgLSBkZWx0YVg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmJveERlbHRhID0gW1xuICAgICAgICAgICAgYmJveFswXSAtIG1heEVkZ2VMZW5ndGgsXG4gICAgICAgICAgICBiYm94WzFdIC0gbWF4RWRnZUxlbmd0aCxcbiAgICAgICAgICAgIGJib3hbMl0gKyBhZGRYICsgbWF4RWRnZUxlbmd0aCxcbiAgICAgICAgICAgIGJib3hbM10gKyBhZGRZICsgbWF4RWRnZUxlbmd0aFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBtYXhWYWwgPSB2YWx1ZXMucmVkdWNlKChwcmV2LCBjdXJyKSA9PiBjdXJyID4gcHJldiA/IGN1cnIgOiBwcmV2LCAwKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29vcmRzLCB2YWx1ZXMsIGJib3hEZWx0YSwgbWF4VmFsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwYXJzZURhdGFCYm94KGJib3gsIGNvb3JkcywgdmFsdWVzLCBtYXhWYWwsIG1heEVkZ2VMZW5ndGgpIHtcbiAgICAgICAgY29uc3Qgb2JzZXJ2YXRpb25zQmJveCA9IHppcChjb29yZHMsIHZhbHVlcykubWFwKG8gPT4ge1xuICAgICAgICAgICAgY29uc3QgY29vcmRzQmJveCA9IHdvcmxkQ29vcmRzMmNsaXBCYm94KFtvWzBdLCBvWzFdXSwgYmJveCk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIDI1NSAqIChjb29yZHNCYm94WzBdICsgMSkgLyAyLFxuICAgICAgICAgICAgICAgIDI1NSAqIChjb29yZHNCYm94WzFdICsgMSkgLyAyLFxuICAgICAgICAgICAgICAgIDI1NSAqIG9bMl0gLyBtYXhWYWwsXG4gICAgICAgICAgICAgICAgMjU1XG4gICAgICAgICAgICBdO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbnJPYnNlcnZhdGlvbnMgPSBvYnNlcnZhdGlvbnNCYm94Lmxlbmd0aDtcbiAgICAgICAgY29uc3QgbmV4dFBvd2VyT2ZUd28gPSBuZXh0UG93ZXJPZihuck9ic2VydmF0aW9ucywgMik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV4dFBvd2VyT2ZUd28gLSBuck9ic2VydmF0aW9uczsgaSsrKSB7XG4gICAgICAgICAgICBvYnNlcnZhdGlvbnNCYm94LnB1c2goWzAsIDAsIDAsIDBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRlbHRhWCA9IGJib3hbMl0gLSBiYm94WzBdO1xuICAgICAgICBjb25zdCBkZWx0YVkgPSBiYm94WzNdIC0gYmJveFsxXTtcbiAgICAgICAgY29uc3QgbWF4RWRnZUxlbmd0aEJib3ggPSBtYXhFZGdlTGVuZ3RoIC8gTWF0aC5tYXgoZGVsdGFYLCBkZWx0YVkpO1xuXG4gICAgICAgIHJldHVybiB7IG9ic2VydmF0aW9uc0Jib3gsIG1heEVkZ2VMZW5ndGhCYm94IH07XG4gICAgfVxufVxuXG5jb25zdCB3b3JsZENvb3JkczJjbGlwQmJveCA9IChwb2ludDogbnVtYmVyW10sIGJib3g6IG51bWJlcltdKTogbnVtYmVyW10gPT4ge1xuICAgIGNvbnN0IHhQZXJjdCA9IChwb2ludFswXSAtIGJib3hbMF0pIC8gKGJib3hbMl0gLSBiYm94WzBdKTtcbiAgICBjb25zdCB5UGVyY3QgPSAocG9pbnRbMV0gLSBiYm94WzFdKSAvIChiYm94WzNdIC0gYmJveFsxXSk7XG4gICAgY29uc3QgeENsaXAgPSAyICogeFBlcmN0IC0gMTtcbiAgICBjb25zdCB5Q2xpcCA9IDIgKiB5UGVyY3QgLSAxO1xuICAgIHJldHVybiBbeENsaXAsIHlDbGlwXTtcbn07XG5cbmNvbnN0IGNyZWF0ZUludmVyc2VEaXN0YW5jZUludGVycG9sYXRpb25TaGFkZXIgPSAoZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgb2JzZXJ2YXRpb25zQmJveDogbnVtYmVyW11bXSwgbWF4VmFsdWU6IG51bWJlciwgcG93ZXI6IG51bWJlciwgbWF4RWRnZUxlbmd0aEJib3g6IG51bWJlcik6IFNoYWRlciA9PiB7XG5cbiAgICBjb25zdCBtYXhPYnNlcnZhdGlvbnMgPSAxMDAwMDtcbiAgICBjb25zdCBpbnZlcnNlRGlzdGFuY2VQcm9ncmFtID0gbmV3IFByb2dyYW0oZ2wsIGBcbiAgICAgICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuICAgICAgICAgICAgYXR0cmlidXRlIHZlYzMgYV9wb3NpdGlvbjtcbiAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFfdGV4dHVyZVBvc2l0aW9uO1xuICAgICAgICAgICAgdmFyeWluZyB2ZWMyIHZfcG9zaXRpb247XG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzIgdl90ZXh0dXJlUG9zaXRpb247XG5cbiAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgICAgICB2X3Bvc2l0aW9uID0gYV9wb3NpdGlvbi54eTtcbiAgICAgICAgICAgICAgICB2X3RleHR1cmVQb3NpdGlvbiA9IGFfdGV4dHVyZVBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChhX3Bvc2l0aW9uLnh5LCAwLjAsIDEuMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGAsIGBcbiAgICAgICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB1X3Bvd2VyO1xuICAgICAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdV9kYXRhVGV4dHVyZTtcbiAgICAgICAgICAgIHVuaWZvcm0gaW50IHVfbnJEYXRhUG9pbnRzO1xuICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB1X21heFZhbHVlO1xuICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB1X21heERpc3RhbmNlO1xuICAgICAgICAgICAgdmFyeWluZyB2ZWMyIHZfcG9zaXRpb247XG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzIgdl90ZXh0dXJlUG9zaXRpb247XG5cbiAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcblxuICAgICAgICAgICAgICAgIGZsb2F0IHZhbFN1bSA9IDAuMDtcbiAgICAgICAgICAgICAgICBmbG9hdCB3U3VtID0gMC4wO1xuICAgICAgICAgICAgICAgIGZsb2F0IG1pbkQgPSAxMDAwMC4wO1xuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHttYXhPYnNlcnZhdGlvbnN9OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiB1X25yRGF0YVBvaW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmVjNCBkYXRhUG9pbnQgPSB0ZXh0dXJlMkQodV9kYXRhVGV4dHVyZSwgdmVjMihmbG9hdChpKSAvIGZsb2F0KHVfbnJEYXRhUG9pbnRzKSwgMC41KSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhUG9pbnQudyA+IDAuMCkgeyAgLy8gdGV4dHVyZSBpcyBwYWRkZWQgdG8gbmV4dCBwb3dlciBvZiB0d28gd2l0aCB0cmFuc3BhcmVudCAwLXZhbHVlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIgY29vcmRzID0gZGF0YVBvaW50Lnh5ICogMi4wIC0gMS4wOyAgLy8gdHJhbnNmb3JtaW5nIGNvb3JkcyBmcm9tIFswLCAxXSB0byBbLTEsIDFdXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCB2YWx1ZSA9IGRhdGFQb2ludC56ICogdV9tYXhWYWx1ZTsgIC8vIHRyYW5zZm9ybWluZyB2YWx1ZSBmcm9tIFswLCAxXSB0byBbMCwgbWF4VmFsdWVdXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IGQgPSBkaXN0YW5jZSh2X3Bvc2l0aW9uLCBjb29yZHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgdyA9IDEuMCAvIHBvdyhkLCB1X3Bvd2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbFN1bSArPSB2YWx1ZSAqIHc7XG4gICAgICAgICAgICAgICAgICAgICAgICB3U3VtICs9IHc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZCA8IG1pbkQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5EID0gZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmbG9hdCBpbnRlcnBvbGF0ZWRWYWx1ZSA9IHZhbFN1bSAvIHdTdW07XG4gICAgICAgICAgICAgICAgZmxvYXQgYWxwaGEgPSAxLjA7XG4gICAgICAgICAgICAgICAgaWYgKG1pbkQgPiB1X21heERpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFscGhhID0gMC4wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2ZWM0IGNvbG9yID0gdmVjNChpbnRlcnBvbGF0ZWRWYWx1ZSAvIHVfbWF4VmFsdWUsIDAuMCwgMC4wLCBhbHBoYSk7XG5cbiAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYCk7XG5cbiAgICBjb25zdCB2aWV3UG9ydCA9IHJlY3RhbmdsZUUoMiwgMik7XG4gICAgY29uc3QgaW52ZXJzZURpc3RhbmNlU2hhZGVyID0gbmV3IFNoYWRlcihpbnZlcnNlRGlzdGFuY2VQcm9ncmFtLCBbXG4gICAgICAgIG5ldyBBdHRyaWJ1dGUoZ2wsIGludmVyc2VEaXN0YW5jZVByb2dyYW0sICdhX3Bvc2l0aW9uJywgdmlld1BvcnQudmVydGljZXMpLFxuICAgICAgICBuZXcgQXR0cmlidXRlKGdsLCBpbnZlcnNlRGlzdGFuY2VQcm9ncmFtLCAnYV90ZXh0dXJlUG9zaXRpb24nLCB2aWV3UG9ydC50ZXh0dXJlUG9zaXRpb25zKVxuICAgIF0sIFtcbiAgICAgICAgbmV3IFVuaWZvcm0oZ2wsIGludmVyc2VEaXN0YW5jZVByb2dyYW0sICd1X3Bvd2VyJywgJ2Zsb2F0JywgW3Bvd2VyXSksXG4gICAgICAgIG5ldyBVbmlmb3JtKGdsLCBpbnZlcnNlRGlzdGFuY2VQcm9ncmFtLCAndV9uckRhdGFQb2ludHMnLCAnaW50JywgW29ic2VydmF0aW9uc0Jib3gubGVuZ3RoXSksXG4gICAgICAgIG5ldyBVbmlmb3JtKGdsLCBpbnZlcnNlRGlzdGFuY2VQcm9ncmFtLCAndV9tYXhWYWx1ZScsICdmbG9hdCcsIFttYXhWYWx1ZV0pLFxuICAgICAgICBuZXcgVW5pZm9ybShnbCwgaW52ZXJzZURpc3RhbmNlUHJvZ3JhbSwgJ3VfbWF4RGlzdGFuY2UnLCAnZmxvYXQnLCBbbWF4RWRnZUxlbmd0aEJib3hdKVxuICAgIF0sIFtcbiAgICAgICAgbmV3IERhdGFUZXh0dXJlKGdsLCBpbnZlcnNlRGlzdGFuY2VQcm9ncmFtLCAndV9kYXRhVGV4dHVyZScsIFtvYnNlcnZhdGlvbnNCYm94XSwgMClcbiAgICBdLCBuZXcgSW5kZXgoZ2wsIHZpZXdQb3J0LnZlcnRleEluZGljZXMpKTtcblxuICAgIHJldHVybiBpbnZlcnNlRGlzdGFuY2VTaGFkZXI7XG59O1xuXG5jb25zdCBjcmVhdGVDb2xvcml6YXRpb25TaGFkZXIgPSAoZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgY29sb3JSYW1wOiBDb2xvclJhbXAsIG1heFZhbDogbnVtYmVyLCBzbW9vdGg6IGJvb2xlYW4sIHZhbHVlRmI6IEZyYW1lYnVmZmVyKTogU2hhZGVyID0+IHtcblxuICAgIGNvbnN0IG1heENvbG9yUmFtcFZhbHVlcyA9IDE1O1xuICAgIGNvbnN0IGNvbG9yaXphdGlvblByb2dyYW0gPSBuZXcgUHJvZ3JhbShnbCwgYFxuICAgICAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uO1xuICAgICAgICAgICAgYXR0cmlidXRlIHZlYzIgYV90ZXh0dXJlQ29vcmQ7XG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzIgdl90ZXh0dXJlQ29vcmQ7XG5cbiAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgICAgICB2X3RleHR1cmVDb29yZCA9IGFfdGV4dHVyZUNvb3JkO1xuICAgICAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChhX3Bvc2l0aW9uLnh5LCAwLjAsIDEuMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGAsIGBcbiAgICAgICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB1X2NvbG9yUmFtcFZhbHVlc1ske21heENvbG9yUmFtcFZhbHVlc31dO1xuICAgICAgICAgICAgdW5pZm9ybSB2ZWMzIHVfY29sb3JSYW1wQ29sb3JzWyR7bWF4Q29sb3JSYW1wVmFsdWVzfV07XG4gICAgICAgICAgICB1bmlmb3JtIGludCB1X25yQ29sb3JSYW1wVmFsdWVzO1xuICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB1X21heFZhbHVlO1xuICAgICAgICAgICAgdW5pZm9ybSBib29sIHVfc21vb3RoO1xuICAgICAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdV92YWx1ZVRleHR1cmU7XG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzIgdl90ZXh0dXJlQ29vcmQ7XG5cbiAgICAgICAgICAgIHZlYzMgdmFsdWVUb1Ntb290aENvbG9yKGluIGZsb2F0IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgdV9jb2xvclJhbXBWYWx1ZXNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVfY29sb3JSYW1wQ29sb3JzWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMTsgaSA8ICR7bWF4Q29sb3JSYW1wVmFsdWVzfTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID4gdV9uckNvbG9yUmFtcFZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgdV9jb2xvclJhbXBWYWx1ZXNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IGFscGhhID0gKHZhbHVlIC0gdV9jb2xvclJhbXBWYWx1ZXNbaS0xXSkgLyAodV9jb2xvclJhbXBWYWx1ZXNbaV0gLSB1X2NvbG9yUmFtcFZhbHVlc1tpLTFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzMgY29sb3IgPSBhbHBoYSAqICh1X2NvbG9yUmFtcENvbG9yc1tpXSAtIHVfY29sb3JSYW1wQ29sb3JzW2ktMV0pICsgdV9jb2xvclJhbXBDb2xvcnNbaS0xXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSB1X25yQ29sb3JSYW1wVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdV9jb2xvclJhbXBDb2xvcnNbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZlYzMgdmFsdWVUb1N0ZXBDb2xvcihpbiBmbG9hdCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHttYXhDb2xvclJhbXBWYWx1ZXN9OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiB1X25yQ29sb3JSYW1wVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCB1X2NvbG9yUmFtcFZhbHVlc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVfY29sb3JSYW1wQ29sb3JzW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09IHVfbnJDb2xvclJhbXBWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1X2NvbG9yUmFtcENvbG9yc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgIHZlYzQgcGl4ZWxEYXRhID0gdGV4dHVyZTJEKHVfdmFsdWVUZXh0dXJlLCB2X3RleHR1cmVDb29yZCk7XG4gICAgICAgICAgICAgICAgZmxvYXQgdmFsID0gcGl4ZWxEYXRhLnIgKiB1X21heFZhbHVlO1xuICAgICAgICAgICAgICAgIGZsb2F0IGFscGhhID0gcGl4ZWxEYXRhLnc7XG4gICAgICAgICAgICAgICAgdmVjMyByZ2IgPSB2ZWMzKDAuMCwgMC4wLCAwLjApO1xuICAgICAgICAgICAgICAgIGlmIChhbHBoYSA+IDAuMDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVfc21vb3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZ2IgPSB2YWx1ZVRvU21vb3RoQ29sb3IodmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJnYiA9IHZhbHVlVG9TdGVwQ29sb3IodmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHJnYi54IC8gMjU1LjAsIHJnYi55IC8gMjU1LjAsIHJnYi56IC8gMjU1LjAsIGFscGhhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYCk7XG5cbiAgICBjb25zdCBjb2xvcml6YXRpb25TaGFkZXIgPSBuZXcgU2hhZGVyKGNvbG9yaXphdGlvblByb2dyYW0sIFtcbiAgICAgICAgbmV3IEF0dHJpYnV0ZShnbCwgY29sb3JpemF0aW9uUHJvZ3JhbSwgJ2FfcG9zaXRpb24nLCByZWN0YW5nbGVBKDIuMCwgMi4wKS52ZXJ0aWNlcyksXG4gICAgICAgIG5ldyBBdHRyaWJ1dGUoZ2wsIGNvbG9yaXphdGlvblByb2dyYW0sICdhX3RleHR1cmVDb29yZCcsIHJlY3RhbmdsZUEoMi4wLCAyLjApLnRleHR1cmVQb3NpdGlvbnMpXG4gICAgXSwgW1xuICAgICAgICBuZXcgVW5pZm9ybShnbCwgY29sb3JpemF0aW9uUHJvZ3JhbSwgJ3VfY29sb3JSYW1wVmFsdWVzJywgJ2Zsb2F0W10nLCBjb2xvclJhbXAubWFwKGUgPT4gZS52YWwpKSxcbiAgICAgICAgbmV3IFVuaWZvcm0oZ2wsIGNvbG9yaXphdGlvblByb2dyYW0sICd1X2NvbG9yUmFtcENvbG9ycycsICd2ZWMzW10nLCBmbGF0dGVuUmVjdXJzaXZlKCBjb2xvclJhbXAubWFwKGUgPT4gZS5yZ2IpICkpLFxuICAgICAgICBuZXcgVW5pZm9ybShnbCwgY29sb3JpemF0aW9uUHJvZ3JhbSwgJ3VfbnJDb2xvclJhbXBWYWx1ZXMnLCAnaW50JywgW2NvbG9yUmFtcC5sZW5ndGhdKSxcbiAgICAgICAgbmV3IFVuaWZvcm0oZ2wsIGNvbG9yaXphdGlvblByb2dyYW0sICd1X21heFZhbHVlJywgJ2Zsb2F0JywgW21heFZhbF0pLFxuICAgICAgICBuZXcgVW5pZm9ybShnbCwgY29sb3JpemF0aW9uUHJvZ3JhbSwgJ3Vfc21vb3RoJywgJ2Jvb2wnLCBbc21vb3RoID8gMSA6IDBdKSxcbiAgICBdLCBbXG4gICAgICAgIG5ldyBUZXh0dXJlKGdsLCBjb2xvcml6YXRpb25Qcm9ncmFtLCAndV92YWx1ZVRleHR1cmUnLCB2YWx1ZUZiLmZiby50ZXh0dXJlLCAwKVxuICAgIF0pO1xuXG4gICAgcmV0dXJuIGNvbG9yaXphdGlvblNoYWRlcjtcbn07XG5cblxuY29uc3QgY3JlYXRlQXJyYW5nZW1lbnRTaGFkZXIgPSAoZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgd29ybGQycGl4OiBudW1iZXJbXVtdLCBwaXgyY2xpcDogbnVtYmVyW11bXSwgYmJveDogbnVtYmVyW10sIGNvbG9yRmI6IEZyYW1lYnVmZmVyKTogU2hhZGVyID0+IHtcbiAgICBjb25zdCBhcnJhbmdlbWVudFByb2dyYW0gPSBuZXcgUHJvZ3JhbShnbCwgYFxuICAgICAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMyBhX3BvcztcbiAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFfcG9zVGV4dHVyZTtcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0MyB1X3dvcmxkMnBpeDtcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0MyB1X3BpeDJjbGlwO1xuICAgICAgICAgICAgdW5pZm9ybSB2ZWM0IHVfYmJveDtcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMiB2X3Bvc1RleHR1cmU7XG5cbiAgICAgICAgICAgIHZlYzIgY2xpcEJieDJ3b3JsZENvb3Jkcyh2ZWMyIGNsaXBDb29yZHMsIHZlYzQgYmJveCkge1xuICAgICAgICAgICAgICAgIGZsb2F0IHhQZXJjdCA9ICggY2xpcENvb3Jkcy54ICsgMS4wICkgLyAyLjA7XG4gICAgICAgICAgICAgICAgZmxvYXQgeVBlcmN0ID0gKCBjbGlwQ29vcmRzLnkgKyAxLjAgKSAvIDIuMDtcbiAgICAgICAgICAgICAgICBmbG9hdCB4V29ybGQgPSB4UGVyY3QgKiAoYmJveC56IC0gYmJveC54KSArIGJib3gueDtcbiAgICAgICAgICAgICAgICBmbG9hdCB5V29ybGQgPSB5UGVyY3QgKiAoYmJveC53IC0gYmJveC55KSArIGJib3gueTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmVjMih4V29ybGQsIHlXb3JsZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgICAgICB2X3Bvc1RleHR1cmUgPSBhX3Bvc1RleHR1cmU7XG4gICAgICAgICAgICAgICAgdmVjMiB3b3JsZFBvcyA9IGNsaXBCYngyd29ybGRDb29yZHMoYV9wb3MueHksIHVfYmJveCk7XG4gICAgICAgICAgICAgICAgdmVjMyBjbGlwUG9zID0gdV9waXgyY2xpcCAqIHVfd29ybGQycGl4ICogdmVjMyh3b3JsZFBvcy54eSwgMS4wKTtcbiAgICAgICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoY2xpcFBvcy54eSwgMC4wLCAxLjApO1xuICAgICAgICAgICAgfVxuICAgICAgICBgLCBgXG4gICAgICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICAgICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMiB2X3Bvc1RleHR1cmU7XG5cbiAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X3Bvc1RleHR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICBgKTtcblxuICAgIGNvbnN0IGFycmFuZ2VtZW50U2hhZGVyID0gbmV3IFNoYWRlcihhcnJhbmdlbWVudFByb2dyYW0sIFtcbiAgICAgICAgbmV3IEF0dHJpYnV0ZShnbCwgYXJyYW5nZW1lbnRQcm9ncmFtLCAnYV9wb3MnLCByZWN0YW5nbGVBKDIsIDIpLnZlcnRpY2VzKSxcbiAgICAgICAgbmV3IEF0dHJpYnV0ZShnbCwgYXJyYW5nZW1lbnRQcm9ncmFtLCAnYV9wb3NUZXh0dXJlJywgcmVjdGFuZ2xlQSgyLCAyKS50ZXh0dXJlUG9zaXRpb25zKSxcbiAgICBdLCBbXG4gICAgICAgIG5ldyBVbmlmb3JtKGdsLCBhcnJhbmdlbWVudFByb2dyYW0sICd1X3dvcmxkMnBpeCcsICdtYXQzJywgZmxhdHRlblJlY3Vyc2l2ZSh3b3JsZDJwaXgpKSxcbiAgICAgICAgbmV3IFVuaWZvcm0oZ2wsIGFycmFuZ2VtZW50UHJvZ3JhbSwgJ3VfcGl4MmNsaXAnLCAnbWF0MycsIGZsYXR0ZW5SZWN1cnNpdmUocGl4MmNsaXApKSxcbiAgICAgICAgbmV3IFVuaWZvcm0oZ2wsIGFycmFuZ2VtZW50UHJvZ3JhbSwgJ3VfYmJveCcsICd2ZWM0JywgYmJveClcbiAgICBdLCBbXG4gICAgICAgIG5ldyBUZXh0dXJlKGdsLCBhcnJhbmdlbWVudFByb2dyYW0sICd1X3RleHR1cmUnLCBjb2xvckZiLmZiby50ZXh0dXJlLCAwKVxuICAgIF0pO1xuXG4gICAgcmV0dXJuIGFycmFuZ2VtZW50U2hhZGVyO1xufTtcblxuY29uc3QgZ2V0QmJveCA9IChvYnM6IG51bWJlcltdW10pOiBudW1iZXJbXSA9PiB7XG4gICAgY29uc3QgeHMgPSBvYnMubWFwKHAgPT4gcFswXSk7XG4gICAgY29uc3QgeXMgPSBvYnMubWFwKHAgPT4gcFsxXSk7XG4gICAgY29uc3QgeE1pbiA9IE1hdGgubWluKC4uLnhzKTtcbiAgICBjb25zdCB4TWF4ID0gTWF0aC5tYXgoLi4ueHMpO1xuICAgIGNvbnN0IHlNaW4gPSBNYXRoLm1pbiguLi55cyk7XG4gICAgY29uc3QgeU1heCA9IE1hdGgubWF4KC4uLnlzKTtcbiAgICByZXR1cm4gW3hNaW4sIHlNaW4sIHhNYXgsIHlNYXhdO1xufTtcblxuY29uc3QgemlwID0gKGFycjA6IGFueVtdLCBhcnIxOiBhbnlbXSk6IGFueVtdID0+IHtcbiAgICBjb25zdCBvdXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycjAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb3V0LnB1c2goYXJyMFtpXS5jb25jYXQoYXJyMVtpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcblxuY29uc3QgY3JlYXRlRGlzdGFuY2VNYXRyaXggPSAoY29vcmRzOiBudW1iZXJbXVtdKTogbnVtYmVyW11bXSA9PiB7XG4gICAgY29uc3QgbWF0cml4ID0gY3JlYXRlTkRpbUFycmF5KFtjb29yZHMubGVuZ3RoLCBjb29yZHMubGVuZ3RoXSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgY29vcmRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBkID0gcG9pbnREaXN0YW5jZShjb29yZHNbaV0sIGNvb3Jkc1tqXSk7XG4gICAgICAgICAgICBtYXRyaXhbaV1bal0gPSBkO1xuICAgICAgICAgICAgbWF0cml4W2pdW2ldID0gZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF0cml4O1xufTtcblxuY29uc3QgY3JlYXRlN05lYXJlc3ROZWlnaGJvcnNUZXh0dXJlRGF0YSA9IChkaXN0YW5jZU1hdHJpeDogbnVtYmVyW11bXSwgY29vcmRzOiBudW1iZXJbXVtdLCB2YWx1ZXM6IG51bWJlcltdKTogbnVtYmVyW11bXVtdID0+IHtcbiAgICBjb25zdCByb3dzID0gbmV4dFBvd2VyT2YodmFsdWVzLmxlbmd0aCwgMik7XG4gICAgY29uc3QgZGF0YSA9IGNyZWF0ZU5EaW1BcnJheShbcm93cywgOCwgNF0pO1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgdmFsdWVzLmxlbmd0aDsgcisrKSB7XG4gICAgICAgIGRhdGFbcl1bMF0gPSBbY29vcmRzW3JdWzBdLCBjb29yZHNbcl1bMV0sIHZhbHVlc1tyXSwgMjU1XTtcbiAgICAgICAgY29uc3QgbmVpZ2hib3JJbmRpY2VzID0gZ2V0TkluZGljZXNTbWFsbGVzdCg3LCBkaXN0YW5jZU1hdHJpeFtyXSk7XG4gICAgICAgIGZvciAobGV0IG4gPSAxOyBuIDwgODsgbisrKSB7XG4gICAgICAgICAgICBjb25zdCBuaSA9IG5laWdoYm9ySW5kaWNlc1tuIC0gMV07XG4gICAgICAgICAgICBkYXRhW3JdW25dID0gW2Nvb3Jkc1tuaV1bMF0sIGNvb3Jkc1tuaV1bMV0sIHZhbHVlc1tuaV0sIDI1NV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59O1xuXG5jb25zdCBwb2ludERpc3RhbmNlID0gKGE6IG51bWJlcltdLCBiOiBudW1iZXJbXSk6IG51bWJlciA9PiB7XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdygoYVswXSAtIGJbMF0pLCAyKSArIE1hdGgucG93KChhWzFdIC0gYlsxXSksIDIpKTtcbn07XG5cbmNvbnN0IGdldE5JbmRpY2VzU21hbGxlc3QgPSAobjogbnVtYmVyLCB2YWx1ZXM6IG51bWJlcltdKTogbnVtYmVyW10gPT4ge1xuICAgIGNvbnN0IHNtYWxsZXN0ID0gZ2V0TlNtYWxsZXN0KG4sIHZhbHVlcyk7XG4gICAgY29uc3QgaW5kaWNlcyA9IGdldEluZGljZXNJbkFycmF5KHNtYWxsZXN0LCB2YWx1ZXMpO1xuICAgIHJldHVybiBpbmRpY2VzO1xufTtcblxuY29uc3QgZ2V0SW5kaWNlc0luQXJyYXkgPSAocGlja2VkVmFsdWVzOiBudW1iZXJbXSwgYWxsVmFsdWVzOiBudW1iZXJbXSk6IG51bWJlcltdID0+IHtcbiAgICByZXR1cm4gcGlja2VkVmFsdWVzLm1hcCh2ID0+IGFsbFZhbHVlcy5maW5kSW5kZXgoYSA9PiBhID09PSB2KSk7XG59O1xuXG5jb25zdCBnZXROU21hbGxlc3QgPSAobjogbnVtYmVyLCB2YWx1ZXM6IG51bWJlcltdKTogbnVtYmVyW10gPT4ge1xuICAgIHJldHVybiB2YWx1ZXMuc29ydChmdW5jdGlvbihhLCBiKXsgcmV0dXJuIGEgLSBiOyB9KS5zbGljZSgwLCBuKTtcbn07XG4iXX0=