import * as i0 from '@angular/core';
import { Injectable, Component, ViewEncapsulation, ViewChild, Input, NgModule } from '@angular/core';
import { StackedLayertype, CustomLayertype, WfsLayertype, KmlLayertype, GeojsonLayertype, TmsLayertype, WmtsLayertype, WmsLayertype, XyzLayertype, RasterLayer, VectorLayer, WmtsLayer, StackedLayer, CustomLayer } from '@dlr-eoc/services-layers';
import olMap from 'ol/Map';
import olView from 'ol/View';
import olBaseLayer from 'ol/layer/Base';
import olLayer from 'ol/layer/Layer';
import olLayerGroup from 'ol/layer/Group';
import olOverlay from 'ol/Overlay';
import olBaseTileLayer from 'ol/layer/BaseTile';
import olBaseVectorLayer from 'ol/layer/BaseVector';
import olBaseImageLayer from 'ol/layer/BaseImage';
import olImageLayer from 'ol/layer/Image';
import olTileLayer from 'ol/layer/Tile';
import olVectorLayer from 'ol/layer/Vector';
import olVectorTileSource from 'ol/source/VectorTile';
import olVectorTileLayer from 'ol/layer/VectorTile';
import { applyStyle } from 'ol-mapbox-style';
import { createXYZ } from 'ol/tilegrid';
import olMVT from 'ol/format/MVT';
import olXYZ from 'ol/source/XYZ';
import olTileSource from 'ol/source/Tile';
import olTileWMS from 'ol/source/TileWMS';
import olImageWMS from 'ol/source/ImageWMS';
import olTileImageSource from 'ol/source/TileImage';
import olImageSource from 'ol/source/Image';
import olWMTS from 'ol/source/WMTS';
import olWMTSTileGrid from 'ol/tilegrid/WMTS';
import olTileGrid from 'ol/tilegrid/TileGrid';
import olVectorSource from 'ol/source/Vector';
import olRasterSource from 'ol/source/Raster';
import olSourceCluster from 'ol/source/Cluster';
import olCollection from 'ol/Collection';
import olGeoJSON from 'ol/format/GeoJSON';
import olKML from 'ol/format/KML';
import olProjection from 'ol/proj/Projection';
import { transform, get, transformExtent } from 'ol/proj';
import { register } from 'ol/proj/proj4';
import proj4 from 'proj4';
import { getHeight, getWidth, getTopLeft, containsCoordinate, extend } from 'ol/extent';
import { DEFAULT_MAX_ZOOM, DEFAULT_TILE_SIZE } from 'ol/tilegrid/common';
import { easeOut } from 'ol/easing.js';
import olStyle from 'ol/style/Style';
import olText from 'ol/style/Text';
import olFill from 'ol/style/Fill';
import olCircleStyle from 'ol/style/Circle';
import olStroke from 'ol/style/Stroke';
import { DragBox } from 'ol/interaction';
import { getUid } from 'ol/util';
import { Subject } from 'rxjs';
import { flattenLayers } from '@dlr-eoc/utils-maps';
import OverlayPositioning from 'ol/OverlayPositioning';
import { MapState } from '@dlr-eoc/services-map-state';
import { skip } from 'rxjs/operators';
import Attribution from 'ol/control/Attribution';
import ScaleLine from 'ol/control/ScaleLine';
import Zoom from 'ol/control/Zoom';
import olMousePosition from 'ol/control/MousePosition';
import { toStringXY } from 'ol/coordinate';
import olFullScreen from 'ol/control/FullScreen';
import olOverviewMap from 'ol/control/OverviewMap';
import olOSM from 'ol/source/OSM';
import olRotate from 'ol/control/Rotate';
import * as i2 from '@angular/common';
import { CommonModule } from '@angular/common';

const OVERLAY_TYPE_KEY = 'type';
const FILTER_TYPE_KEY = 'filtertype';
const ID_KEY$1 = 'id';
const TITLE_KEY = 'title';
const WebMercator = 'EPSG:3857';
const WGS84 = 'EPSG:4326';
class MapOlService {
    constructor(crf, app, injector) {
        this.crf = crf;
        this.app = app;
        this.injector = injector;
        this.hitTolerance = 0;
        this.hitLayerCurr = null;
        this.hitLayerPrev = null;
        /** 'olProjection' */
        this.projectionChange = new Subject();
        /**
         * This object keeps track of currently bound angular-components that are being used as popups.
         * We keep a reference to them here so that we can remove them again after they are no longer displayed.
         */
        this.dynamicPopupComponents = new Map();
        /**
         * To filtered out layers and show the popup beneath e.g. text overlays
         * in map.forEachLayerAtPixel for raster and map.forEachFeatureAtPixel for vector
         */
        this.filterLayerNoPopup = (l) => {
            const popup = (l.get('popup'));
            let shouldNotFilterLayer = true;
            if (popup && this.isPopupObj(popup)) {
                if (popup.filterLayer === true) {
                    shouldNotFilterLayer = false;
                }
            }
            return shouldNotFilterLayer;
        };
        this.map = new olMap({ controls: [] });
        this.view = new olView();
        this.EPSG = WebMercator;
    }
    /**
     * if this is used in an angular component then set the target after the view is created
     * e.g. this.map.setTarget(this.mapDivView.nativeElement) in ngAfterViewInit()
     */
    createMap(target) {
        const zoom = 0;
        const center = {
            lat: 0,
            lon: 0
        };
        const baselayerGroup = new olLayerGroup({
            layers: []
        });
        baselayerGroup.set(FILTER_TYPE_KEY, 'baselayers');
        baselayerGroup.set(TITLE_KEY, 'Base maps');
        baselayerGroup.set(ID_KEY$1, 'ID_filtertype_baselayers');
        const layersGroup = new olLayerGroup({
            layers: []
        });
        layersGroup.set(FILTER_TYPE_KEY, 'layers');
        layersGroup.set(TITLE_KEY, 'Layers');
        layersGroup.set(ID_KEY$1, 'ID_filtertype_layers');
        // ---------------------------------------------------------------------------------------------------
        const overlayGroup = new olLayerGroup({
            layers: []
        });
        overlayGroup.set(FILTER_TYPE_KEY, 'overlays');
        overlayGroup.set(TITLE_KEY, 'Overlays');
        overlayGroup.set(ID_KEY$1, 'ID_filtertype_overlays');
        /**
         * set default viewOptions
         */
        this.viewOptions = {
            center: transform([center.lon, center.lat], WGS84, this.EPSG),
            zoom,
            projection: get(this.EPSG)
        };
        if (this.view['constrainRotation']) {
            this.viewOptions.constrainRotation = this.view['constrainRotation'];
        }
        if (this.view['enableRotation']) {
            this.viewOptions.enableRotation = this.view['enableRotation'];
        }
        if (this.view['extent']) {
            this.viewOptions.extent = this.view['extent'];
        }
        if (this.view['constrainOnlyCenter']) {
            this.viewOptions.constrainOnlyCenter = this.view['constrainOnlyCenter'];
        }
        if (this.view['smoothExtentConstraint']) {
            this.viewOptions.smoothExtentConstraint = this.view['smoothExtentConstraint'];
        }
        if (this.view.getMaxResolution()) {
            this.viewOptions.maxResolution = this.view.getMaxResolution();
        }
        if (this.view.getMinResolution()) {
            this.viewOptions.minResolution = this.view.getMinResolution();
        }
        if (this.view.getMaxZoom()) {
            this.viewOptions.maxZoom = this.view.getMaxZoom();
        }
        if (this.view.getMinZoom()) {
            this.viewOptions.minZoom = this.view.getMinZoom();
        }
        if (this.view['multiWorld']) {
            this.viewOptions.multiWorld = this.view['multiWorld'];
        }
        if (this.view['constrainResolution']) {
            this.viewOptions.constrainResolution = this.view['constrainResolution'];
        }
        if (this.view['smoothResolutionConstraint']) {
            this.viewOptions.smoothResolutionConstraint = this.view['smoothResolutionConstraint'];
        }
        if (this.view.getResolution()) {
            this.viewOptions.resolution = this.view.getResolution();
        }
        if (this.view.getResolutions()) {
            this.viewOptions.resolutions = this.view.getResolutions();
        }
        if (this.view['rotation']) {
            this.viewOptions.rotation = this.view['rotation'];
        }
        if (this.view['zoomFactor']) {
            this.viewOptions.zoomFactor = this.view['zoomFactor'];
        }
        const tempview = new olView(this.viewOptions);
        /** define map in constructor so it is created before to use it in projects onInit Method  */
        [baselayerGroup, layersGroup, overlayGroup].map(layer => this.map.addLayer(layer));
        this.map.setView(tempview);
        // this.map.getControls().clear();
        this.view = this.map.getView();
        this.setProjection(this.EPSG);
        if (target) {
            this.map.setTarget(target);
        }
        return {
            map: this.map,
            view: this.view
        };
    }
    setHitTolerance(tolerance) {
        this.hitTolerance = tolerance;
    }
    getHitTolerance() {
        return this.hitTolerance;
    }
    /**
     * See this example:
     * https://openlayers.org/en/latest/examples/box-selection.html
     */
    addBboxSelection(conditionForDrawing, onBoxStart, onBoxEnd, dragBoxOptions) {
        const options = {
            className: 'ol-drag-select',
            condition: conditionForDrawing,
        };
        Object.assign(options, dragBoxOptions);
        const dragBox = new DragBox(dragBoxOptions);
        if (onBoxStart) {
            /** TODO: check Types on the next ol update */
            dragBox.on('boxstart', (evt) => {
                onBoxStart(evt);
            });
        }
        if (onBoxEnd) {
            dragBox.on('boxend', (evt) => {
                const extent = dragBox.getGeometry().getExtent();
                onBoxEnd(extent, evt);
            });
        }
        this.map.addInteraction(dragBox);
        return dragBox;
    }
    /**
     * get an array of olLayers from a group type
     */
    getLayers(filtertype) {
        const lowerType = filtertype.toLowerCase();
        let layers;
        this.map.getLayers().getArray().forEach((layerGroup) => {
            if (layerGroup.get(FILTER_TYPE_KEY) === lowerType) {
                layers = layerGroup.getLayers().getArray();
            }
        });
        return layers;
    }
    getLayersFromGroup(group, filtertype, recursive = false) {
        const layers = group.getLayers().getArray();
        let tempLayers = layers;
        if (recursive) {
            let groups = [].concat(layers);
            layers.forEach(l => {
                if (l instanceof olLayerGroup) {
                    groups = groups.concat(this.getLayersFromGroup(l, filtertype, true));
                }
            });
            tempLayers = groups;
        }
        if (filtertype) {
            return tempLayers.filter(l => l.get(FILTER_TYPE_KEY) && l.get(FILTER_TYPE_KEY).toLowerCase() === filtertype.toLowerCase());
        }
        else {
            return tempLayers;
        }
    }
    getLayerByKey(key, filtertype) {
        const layers = this.getLayersFromGroup(this.map.getLayerGroup(), filtertype);
        const flattenedLayers = flattenLayers(layers);
        const keyLayers = [];
        flattenedLayers.forEach((item) => {
            if (item.get(key.key) && item.get(key.key) === key.value) {
                if (keyLayers.indexOf(item) === -1) {
                    keyLayers.push(item);
                }
            }
        });
        if (!keyLayers.length) {
            const subLayers = this.getLayersFromGroup(this.map.getLayerGroup(), filtertype, true); // (map.getLayerGroup(), filtertype, filtertypeKey, true);
            if (subLayers.length) {
                subLayers.forEach((item) => {
                    if (item.get(key.key) && item.get(key.key) === key.value) {
                        if (keyLayers.indexOf(item) === -1) {
                            keyLayers.push(item);
                        }
                    }
                });
            }
        }
        // there could maybe more the one layers with the same key!!!!
        if (keyLayers.length === 1) {
            return keyLayers[0];
        }
        else {
            return null;
        }
    }
    /**
     * set a FilterType to a Layer or Group recursively
     *
     * @param key [key='filtertype']
     */
    setRecursiveKey(layer, value, key = FILTER_TYPE_KEY) {
        layer.set(key, value);
        if (layer instanceof olLayerGroup) {
            layer.getLayers().forEach(l => {
                this.setRecursiveKey(l, value, key);
            });
        }
    }
    /**
     * add a olLayer to a group if it is not there
     */
    addLayer(layer, filtertype) {
        const lowerType = filtertype.toLowerCase();
        let layers;
        this.map.getLayers().getArray().forEach((layerGroup) => {
            if (layerGroup.get(FILTER_TYPE_KEY) === lowerType) {
                if (!this.isLayerInGroup(layer, layerGroup)) {
                    layers = layerGroup.getLayers().getArray();
                    this.setRecursiveKey(layer, lowerType, FILTER_TYPE_KEY);
                    layers.push(layer);
                    layerGroup.setLayers(new olCollection(layers));
                }
            }
        });
        return layers;
    }
    isLayerInGroup(layer, layerGroup) {
        const layers = layerGroup.getLayers().getArray();
        const haseLayer = layers.filter(l => l.get('id') === layer.get('id'));
        if (haseLayer.length) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
      * Get all direkt Layer Groups added to the map
      *
      * @param filtertypeKey [filtertypeKey='filtertype']
      */
    getLayerGroups(filtertype) {
        const layerGroups = [];
        this.map.getLayers().forEach((lg) => {
            if (lg instanceof olLayerGroup) {
                if (filtertype) {
                    if (lg.get(FILTER_TYPE_KEY) && lg.get(FILTER_TYPE_KEY).toLowerCase() === filtertype.toLowerCase()) {
                        layerGroups.push(lg);
                    }
                }
                else {
                    layerGroups.push(lg);
                }
            }
        });
        return layerGroups;
    }
    /**
     * add a array of olLayers to a group if they are not there
     */
    addLayers(layers, filtertype) {
        const lowerType = filtertype.toLocaleLowerCase();
        let newLayers;
        const layerGroups = this.getLayerGroups(lowerType);
        layerGroups.forEach(lg => {
            const groupLayers = lg.getLayers();
            if (groupLayers.getLength() > 0) {
                // I think doing it like this should be more performant like as using the addLayer in a loop
                newLayers = lg.getLayers().getArray();
                layers.map(layer => {
                    if (!this.isLayerInGroup(layer, lg)) {
                        newLayers.push(layer);
                    }
                });
            }
            else {
                newLayers = layers;
            }
            newLayers.forEach(l => {
                if (l instanceof olLayerGroup) {
                    this.setRecursiveKey(l, lowerType, FILTER_TYPE_KEY);
                }
            });
            lg.setLayers(new olCollection(newLayers));
        });
        return newLayers;
    }
    /**
     * reset a group with an array of olLayers
     */
    setLayers(layers, filtertype) {
        const lowerType = filtertype.toLocaleLowerCase();
        const layerGroups = this.getLayerGroups(lowerType);
        layers.forEach(l => {
            if (l instanceof olLayerGroup) {
                this.setRecursiveKey(l, filtertype.toLocaleLowerCase(), FILTER_TYPE_KEY);
            }
        });
        layerGroups.forEach(l => {
            this.cleanUpEventListeners(l, layers);
            l.setLayers(new olCollection(layers));
        });
        return layers;
    }
    /**
     * Clean up event listeners from layers and sources
     *
     * TODO: is this needed? when layers or sources are removed, then there is no Target anymore which listens for events?
     * there are also other functions like removeLayerByKey(), removeAllLayers()
     */
    cleanUpEventListeners(layerGroup, newLayers) {
        /** get Difference of old layers and new layers */
        const layersToRemove = layerGroup.getLayers().getArray().filter(x => !newLayers.map(l => l.get('id')).includes(x.get('id')));
        this.removeListenersFromOldLayers(layersToRemove);
        // TODO: is this done by setLayers??
        layersToRemove.forEach(l => layerGroup.getLayers().remove(l));
    }
    /**
     * on() and un() are functions of olObservable which extends EventTarget
     *
     * https://github.com/openlayers/openlayers/blob/v6.5.0/src/ol/events/Target.js#L145
     * https://github.com/openlayers/openlayers/blob/v6.5.0/src/ol/events/Target.js#L134
     */
    addEventsToLayer(ukisLayer, olLayer, olSource) {
        if (ukisLayer.events) {
            if (ukisLayer.events.layer) {
                ukisLayer.events.layer.forEach(e => {
                    const listeners = olLayer.getListeners(e.event);
                    /** only add listener if it was not registered on the olLayer object (for CustomLayer) */
                    if (!listeners) {
                        /** TODO: check Types on the next ol update - we only define a string so the user has to check if the right event is used */
                        olLayer.on(e.event, e.listener);
                    }
                });
            }
            if (ukisLayer.events.source) {
                ukisLayer.events.source.forEach(e => {
                    const listeners = olSource.getListeners(e.event);
                    /** only add listener if it was not registered on the olSource object (for CustomLayer) */
                    if (!listeners) {
                        /** TODO: check Types on the next ol update - we only define a string so the user has to check if the right event is used */
                        olSource.on(e.event, e.listener);
                    }
                });
            }
        }
    }
    /** TODO: try to remove/replace this function - Property 'disposeInternal' is protected ol function */
    removeListenersFromOldLayers(layers) {
        const disposeLayerInternal = (layer) => {
            if (typeof layer.getSource === 'function') {
                const source = layer.getSource();
                if (source) {
                    // https://github.com/dlr-eoc/ukis-frontend-libraries/issues/100
                    if (source instanceof olRasterSource) {
                        source.dispose();
                    }
                    if (source.hasListener()) {
                        source.disposeInternal();
                    }
                }
            }
            if (layer.hasListener()) {
                layer.disposeInternal();
            }
        };
        layers.forEach(l => {
            if (l instanceof olLayerGroup) {
                l.getLayers().forEach(subL => {
                    disposeLayerInternal(subL);
                });
            }
            else if (l instanceof olBaseLayer) {
                disposeLayerInternal(l);
            }
        });
    }
    /**
     * get corresponding Layer Group on which the layer is added
     */
    getLayerGroupForLayer(layer) {
        const subLayers = this.getLayersFromGroup(this.map.getLayerGroup(), null, true);
        subLayers.push(this.map.getLayerGroup());
        let lyerGroup = null;
        subLayers.forEach((l) => {
            if (l instanceof olLayerGroup) {
                const groupLayers = this.getLayersFromGroup(l);
                const hasLayer = groupLayers.find(i => i === layer);
                if (hasLayer) {
                    lyerGroup = {
                        group: l,
                        layer: hasLayer
                    };
                }
            }
        });
        return lyerGroup;
    }
    removeLayerByKey(key, filtertype) {
        const lowerType = filtertype.toLocaleLowerCase();
        const layer = this.getLayerByKey(key, lowerType);
        if (layer) {
            const gropObj = this.getLayerGroupForLayer(layer);
            if (gropObj.group) {
                const filterdLayers = this.getLayersFromGroup(gropObj.group).filter(i => i !== layer);
                gropObj.group.setLayers(new olCollection(filterdLayers));
            }
        }
    }
    updateLayerByKey(key, newLayer, filtertype) {
        const lowerType = filtertype.toLocaleLowerCase();
        this.map.getLayers().forEach((layerGroup) => {
            if (layerGroup.get(FILTER_TYPE_KEY) === lowerType) {
                const groupLayers = layerGroup.getLayers();
                groupLayers.forEach((oldLayer, index) => {
                    if (oldLayer.get(key.key) && oldLayer.get(key.key) === key.value) {
                        const newProperties = newLayer.getProperties();
                        const newExtent = newLayer.getExtent();
                        const newMaxZoom = newLayer.getMaxZoom();
                        const newMinZoom = newLayer.getMinZoom();
                        const newOpacity = newLayer.getOpacity();
                        const newVisible = newLayer.getVisible();
                        const newZIndex = newLayer.getZIndex();
                        if (oldLayer instanceof olLayer && newLayer instanceof olLayer) {
                            const newSource = newLayer.getSource();
                            oldLayer.setSource(newSource);
                        }
                        if (newProperties) {
                            oldLayer.setProperties(newProperties);
                        }
                        if (newExtent) {
                            oldLayer.setExtent(newExtent);
                        }
                        if (newMaxZoom) {
                            oldLayer.setMaxZoom(newMaxZoom);
                        }
                        if (newMinZoom) {
                            oldLayer.setMinZoom(newMinZoom);
                        }
                        if (newOpacity) {
                            oldLayer.setOpacity(newOpacity);
                        }
                        if (newVisible) {
                            oldLayer.setVisible(newVisible);
                        }
                        if (newZIndex) {
                            oldLayer.setZIndex(newZIndex);
                        }
                        oldLayer.changed();
                        groupLayers.setAt(index, oldLayer);
                    }
                });
                layerGroup.setLayers(groupLayers);
            }
        });
    }
    removeAllLayers(filtertype) {
        const lowerType = filtertype.toLowerCase();
        let layers;
        this.map.getLayers().getArray().forEach((layerGroup) => {
            if (layerGroup.get(FILTER_TYPE_KEY) === lowerType) {
                layers = layerGroup.getLayers();
                layers.clear();
            }
        });
    }
    /**
     * This function resets/adds all olLayers of a type with the new UKIS-Layers
     *
     * if only one group of them map is used and setLayers is called then the map flickers!
     * this is because all layers are newly created and each get new ol_uid's
     */
    setUkisLayers(layers, filtertype) {
        const lowerType = filtertype.toLowerCase();
        const tempLayers = [];
        // TODO try to deep check if a layer if exactly the same and dont create it new
        // create hash from layer???
        if (layers.length < 1 && lowerType !== 'baselayers') {
            // this.removeAllLayers('overlays');
            // this.removeAllLayers('layers');
            this.removeAllLayers(lowerType);
        }
        else {
            layers.forEach((newLayer) => {
                const layer = this.create_layers(newLayer);
                // check if layer not undefined
                if (layer) {
                    tempLayers.push(layer);
                }
            });
        }
        if (tempLayers.length > 0) {
            this.setLayers(tempLayers, lowerType);
            // TODO: checkt to replace type with filtertype -> but breaking Change!!
            const newTempLayer = {
                type: lowerType, layers: tempLayers
            };
            return newTempLayer;
        }
    }
    /** This function resets/adds a olLayer of a type with the new UKIS-Layer */
    setUkisLayer(newLayer, filtertype) {
        if (!filtertype) {
            filtertype = newLayer.filtertype;
        }
        const lowerType = filtertype.toLowerCase();
        const oldLayers = this.getLayers(lowerType);
        const oldLayer = oldLayers.find(l => l.get('id') === newLayer.id);
        const newOlLayer = this.create_layers(newLayer);
        if (oldLayer) {
            this.removeLayerByKey({ key: ID_KEY$1, value: oldLayer.get(ID_KEY$1) }, filtertype);
            this.addLayer(newOlLayer, filtertype);
        }
        else {
            this.addLayer(newOlLayer, filtertype);
        }
    }
    updateUkisLayer(newLayer, filtertype) {
        if (!filtertype) {
            filtertype = newLayer.filtertype;
        }
        const lowerType = filtertype.toLowerCase();
        const oldLayers = this.getLayers(lowerType);
        const oldLayer = oldLayers.find(l => l.get('id') === newLayer.id);
        const newOlLayer = this.create_layers(newLayer);
        if (newOlLayer) {
            this.updateLayerByKey({ key: ID_KEY$1, value: oldLayer.get(ID_KEY$1) }, newOlLayer, filtertype);
        }
    }
    create_layers(newLayer) {
        let newOlLayer;
        switch (newLayer.type) {
            case XyzLayertype:
                newOlLayer = this.create_xyz_layer(newLayer);
                break;
            case WmsLayertype:
                newOlLayer = this.create_wms_layer(newLayer);
                break;
            case WmtsLayertype:
                newOlLayer = this.create_wmts_layer(newLayer);
                break;
            case TmsLayertype:
                newOlLayer = this.create_tms_layer(newLayer);
                break;
            case GeojsonLayertype:
                newOlLayer = this.create_geojson_layer(newLayer);
                break;
            case KmlLayertype:
                newOlLayer = this.create_kml_layer(newLayer);
                break;
            case WfsLayertype:
                newOlLayer = this.create_wfs_layer(newLayer);
                break;
            case CustomLayertype:
                newOlLayer = this.create_custom_layer(newLayer);
                break;
            case StackedLayertype:
                newOlLayer = this.create_stacked_layer(newLayer);
                break;
        }
        return newOlLayer;
    }
    /**
     * create layeroptions olLayerOptions<OptionSources> & ILayerOptions
     * - id
     * - name
     * - filtertype
     * - type
     * - legendImg
     * - visible
     * - zIndex
     * - opacity
     * - attribution
     * - continuousWorld
     * - set crossOrigin for popup layers
     * - set source on layeroptions
     * - popup
     * - maxResolution/minResolution
     * - maxZoom/minZoom
     * - bbox
     */
    createOlLayerOptions(l, type, source) {
        if (source) {
            if (l.attribution) {
                source.setAttributions([l.attribution]);
            }
            if (l.continuousWorld) {
                /**
                 * set wrapX after source creation is not possible so we have to use the private property
                 * https://github.com/openlayers/openlayers/blob/v6.13.0/src/ol/source/Source.js#L48
                 */
                // tslint:disable-next-line: no-string-literal
                source['wrapX_'] = l.continuousWorld;
            }
            /** set crossOrigin for popup layers  */
            if (l.popup && !l.crossOrigin && l.crossOrigin !== null) {
                this.sourceSetCross(source);
            }
            if (l.crossOrigin || l.crossOrigin === null) {
                this.sourceSetCross(source);
            }
        }
        // ------------------------------------------
        const layeroptions = {
            // className - if
            opacity: l.opacity || 1,
            visible: l.visible,
            // extent - if
            zIndex: 1,
            // minResolution - if
            // maxResolution - if
            // minZoom - if
            // maxZoom - if
            // source - if
            // map - not set
            // render - not set
            // properties - not set
            id: l.id,
            name: l.name,
            filtertype: l.filtertype,
            type,
            legendImg: l.legendImg
        };
        if (source) {
            layeroptions.source = source;
        }
        if (l.popup) {
            layeroptions.popup = l.popup;
            /**
             * ol 6.x problem if popup (map.forEachLayerAtPixel) use className
             * https://github.com/openlayers/openlayers/releases/tag/v6.0.0
             */
            layeroptions.className = l.id;
        }
        if (l.maxResolution) {
            layeroptions.maxResolution = l.maxResolution;
        }
        if (l.minResolution) {
            layeroptions.minResolution = l.minResolution;
        }
        if (l.maxZoom) {
            layeroptions.maxZoom = l.maxZoom;
        }
        if (l.minZoom) {
            layeroptions.minZoom = l.minZoom;
        }
        if (l.bbox) {
            layeroptions.extent = transformExtent(l.bbox.slice(0, 4), WGS84, this.getProjection().getCode());
        }
        return layeroptions;
    }
    /**
     * define layer types
     */
    /**
     * https://openlayers.org/en/latest/apidoc/module-ol_layer_Tile-TileLayer.html
     * https://openlayers.org/en/latest/apidoc/module-ol_source_XYZ-XYZ.html
     */
    create_xyz_layer(l) {
        const xyzOptions = {
            wrapX: false
        };
        if (l.crossOrigin) {
            xyzOptions.crossOrigin = l.crossOrigin;
        }
        const olsource = new olXYZ(xyzOptions);
        const layeroptions = this.createOlLayerOptions(l, 'xyz', olsource);
        const baseTileLayerOptions = {
            preload: 0,
            useInterimTilesOnError: true
        };
        const newlayer = new olTileLayer(Object.assign(layeroptions, baseTileLayerOptions));
        this.setSubdomains(l, newlayer);
        this.setCrossOrigin(l, newlayer);
        this.addEventsToLayer(l, newlayer, olsource);
        return newlayer;
    }
    /**
     * create_xyz_layer for Raster
     *
     * or
     *
     * https://openlayers.org/en/latest/apidoc/module-ol_layer_VectorTile-VectorTileLayer.html
     * https://openlayers.org/en/latest/apidoc/module-ol_source_VectorTile-VectorTile.html
     * https://openlayers.org/en/latest/apidoc/module-ol_format_MVT-MVT.html
     */
    create_tms_layer(l) {
        var _a, _b;
        let newlayer = null;
        if (l instanceof RasterLayer) {
            newlayer = this.create_xyz_layer(l);
            newlayer.set('type', 'tms');
            return newlayer;
        }
        else if (l instanceof VectorLayer) {
            const olsource = new olVectorTileSource({
                format: new olMVT(),
                tileGrid: createXYZ({ minZoom: l.minZoom || undefined, maxZoom: l.maxZoom || undefined }),
                url: l.url,
                wrapX: false
            });
            const layeroptions = this.createOlLayerOptions(l, 'tms', olsource);
            const vectorTileLayerOptions = {
                declutter: true,
                renderMode: 'hybrid'
            };
            newlayer = new olVectorTileLayer(Object.assign(layeroptions, vectorTileLayerOptions));
            this.setSubdomains(l, newlayer);
            this.setCrossOrigin(l, newlayer);
            this.addEventsToLayer(l, newlayer, olsource);
            const style = (_a = l === null || l === void 0 ? void 0 : l.options) === null || _a === void 0 ? void 0 : _a.style;
            const mapboxSourceKey = (_b = l === null || l === void 0 ? void 0 : l.options) === null || _b === void 0 ? void 0 : _b.styleSource;
            if (style && mapboxSourceKey) {
                applyStyle(newlayer, style, mapboxSourceKey);
            }
            return newlayer;
        }
    }
    create_wms_layer(l) {
        var _a, _b, _c, _d;
        let newlayer;
        if (((_a = l.params) === null || _a === void 0 ? void 0 : _a.TILED) === 'true' || ((_b = l.params) === null || _b === void 0 ? void 0 : _b.TILED) === undefined || ((_c = l.params) === null || _c === void 0 ? void 0 : _c.TILED) === null) {
            newlayer = this.create_tiled_wms_layer(l);
        }
        else if (((_d = l.params) === null || _d === void 0 ? void 0 : _d.TILED) === 'false') {
            newlayer = this.create_image_wms_layer(l);
        }
        return newlayer;
    }
    /**
     * https://openlayers.org/en/latest/apidoc/module-ol_layer_Tile-TileLayer.html
     * https://openlayers.org/en/latest/apidoc/module-ol_source_TileWMS-TileWMS.html
     */
    create_tiled_wms_layer(l) {
        const tileOptions = {
            /** use assign here otherwise params is passed by object reference to the openlayers layer! */
            params: Object.assign({}, this.keysToUppercase(l.params)),
            wrapX: false
        };
        if (l.tileSize) {
            tileOptions['tileGrid'] = this.getTileGrid('default', null, l.tileSize);
            delete tileOptions.params['tileSize'];
        }
        if (l.crossOrigin) {
            tileOptions.crossOrigin = l.crossOrigin;
        }
        const olsource = new olTileWMS(tileOptions);
        const baseTileLayerOptions = {
            preload: 0,
            useInterimTilesOnError: true
        };
        const layeroptions = this.createOlLayerOptions(l, 'wms', olsource);
        const newlayer = new olTileLayer(Object.assign(layeroptions, baseTileLayerOptions));
        this.setSubdomains(l, newlayer);
        this.addEventsToLayer(l, newlayer, olsource);
        return newlayer;
    }
    /**
     * https://openlayers.org/en/latest/apidoc/module-ol_layer_Image-ImageLayer.html
     * https://openlayers.org/en/latest/apidoc/module-ol_source_ImageWMS-ImageWMS.html
     */
    create_image_wms_layer(l) {
        const options = {
            /**
             * use assign here otherwise params is passed by object reference to the openlayers layer!
             * https://thecodebarbarian.com/object-assign-vs-object-spread.html
             */
            params: Object.assign({}, this.keysToUppercase(l.params)),
            url: l.url
        };
        const olsource = new olImageWMS(options);
        const layeroptions = this.createOlLayerOptions(l, 'wms', olsource);
        const baseImageLayerOptions = {};
        const newlayer = new olImageLayer(Object.assign(layeroptions, baseImageLayerOptions));
        this.addEventsToLayer(l, newlayer, olsource);
        return newlayer;
    }
    /**
     * https://openlayers.org/en/latest/apidoc/module-ol_layer_Tile-TileLayer.html
     * https://openlayers.org/en/latest/apidoc/module-ol_source_WMTS-WMTS.html
     */
    create_wmts_layer(l) {
        if (l instanceof WmtsLayer) {
            let tileGrid = this.getTileGrid('wmts');
            let matrixSet = this.EPSG;
            if (l.params.matrixSetOptions) {
                matrixSet = l.params.matrixSetOptions.matrixSet;
                if ('resolutions' in l.params.matrixSetOptions) {
                    const resolutions = l.params.matrixSetOptions.resolutions;
                    tileGrid = this.getTileGrid('wmts', null, l.tileSize, null, resolutions);
                }
                else if ('resolutionLevels' in l.params.matrixSetOptions || 'tileMatrixPrefix' in l.params.matrixSetOptions) { /** ISimpleMatrixSet */
                    const resolutionLevels = l.params.matrixSetOptions.resolutionLevels;
                    const tileMatrixPrefix = l.params.matrixSetOptions.tileMatrixPrefix;
                    tileGrid = this.getTileGrid('wmts', resolutionLevels, l.tileSize, tileMatrixPrefix, null);
                }
                if ('matrixIds' in l.params.matrixSetOptions) {
                    const matrixIds = l.params.matrixSetOptions.matrixIds;
                    tileGrid = this.getTileGrid('wmts', null, l.tileSize, null, null, matrixIds);
                }
            }
            let wmtsOptions = {
                url: l.url,
                tileGrid,
                matrixSet,
                wrapX: false,
                layer: l.params.layer,
                style: l.params.style
            };
            wmtsOptions = Object.assign({}, wmtsOptions, l.params);
            if (l.crossOrigin) {
                wmtsOptions.crossOrigin = l.crossOrigin;
            }
            const olsource = new olWMTS(wmtsOptions);
            const layeroptions = this.createOlLayerOptions(l, 'wmts', olsource);
            const baseTileLayerOptions = {};
            const newlayer = new olTileLayer(Object.assign(layeroptions, baseTileLayerOptions));
            this.setSubdomains(l, newlayer);
            this.setCrossOrigin(l, newlayer);
            this.addEventsToLayer(l, newlayer, olsource);
            return newlayer;
        }
        else {
            const layer = l;
            console.error(`layer with id: ${layer.id} and type ${layer.type} is no instanceof WmtsLayer!`);
        }
    }
    /**
     * check projects/demo-maps/src/app/route-components/route-example-olperformance/services/largelayers.service.ts
     * for WFS examples.
     *
     * https://openlayers.org/en/latest/apidoc/module-ol_layer_Vector-VectorLayer.html
     * https://openlayers.org/en/latest/apidoc/module-ol_source_Vector-VectorSource.html
     */
    create_wfs_layer(l) {
        let url = null;
        if (l.url.indexOf('http://') === 0 || l.url.indexOf('https://') === 0) {
            url = new URL(l.url);
        }
        else {
            url = new URL(l.url, window.location.origin);
        }
        // making sure that srsname is set to current projection
        url.searchParams.set('srsname', this.EPSG);
        // note that we don't need to adjust the bbox. contrary to wms'es, in a wfs,
        // a bbox may use another projection than the srsname.
        const olsource = new olVectorSource({
            format: new olGeoJSON(),
            url: url.toString()
        });
        const layeroptions = this.createOlLayerOptions(l, 'wfs', olsource);
        const baseVectorLayerOptions = {};
        if (l.options) {
            // here Object.assign modifies the target object - style... is included
            Object.assign(baseVectorLayerOptions, l.options);
        }
        const newlayer = new olVectorLayer(Object.assign(layeroptions, baseVectorLayerOptions));
        if (l.cluster) {
            this.setCluster(l, newlayer, olsource, {});
        }
        this.setSubdomains(l, newlayer);
        this.setCrossOrigin(l, newlayer);
        this.addEventsToLayer(l, newlayer, olsource);
        return newlayer;
    }
    /**
     * https://openlayers.org/en/latest/apidoc/module-ol_layer_Vector-VectorLayer.html
     * https://openlayers.org/en/latest/apidoc/module-ol_source_Vector-VectorSource.html
     * https://openlayers.org/en/latest/apidoc/module-ol_format_GeoJSON-GeoJSON.html
     */
    create_geojson_layer(l) {
        let olsource;
        if (l.data) {
            olsource = new olVectorSource({
                features: this.geoJsonToFeatures(l.data),
                format: new olGeoJSON(),
                wrapX: false
            });
        }
        else if (l.url) {
            olsource = new olVectorSource({
                url: l.url,
                format: new olGeoJSON({
                    dataProjection: WGS84,
                    featureProjection: this.EPSG
                }),
                wrapX: false
            });
        }
        const layeroptions = this.createOlLayerOptions(l, 'geojson', olsource);
        const baseVectorLayerOptions = {};
        if (l.options) {
            // here Object.assign modifies the target object - style... is included
            Object.assign(baseVectorLayerOptions, l.options);
        }
        const newlayer = new olVectorLayer(Object.assign(layeroptions, baseVectorLayerOptions));
        if (l.cluster) {
            this.setCluster(l, newlayer, olsource, {});
        }
        this.setCrossOrigin(l, newlayer);
        this.addEventsToLayer(l, newlayer, olsource);
        return newlayer;
    }
    /**
     * https://openlayers.org/en/latest/apidoc/module-ol_layer_Vector-VectorLayer.html
     * https://openlayers.org/en/latest/apidoc/module-ol_source_Vector-VectorSource.html
     * https://openlayers.org/en/latest/apidoc/module-ol_format_KML-KML.html
     */
    create_kml_layer(l) {
        let olsource;
        if (l.data) {
            olsource = new olVectorSource({
                features: new olKML({ extractStyles: true }).readFeatures(l.data, {
                    dataProjection: WGS84,
                    featureProjection: this.EPSG
                }),
                format: new olKML(),
                wrapX: false
            });
        }
        else if (l.url) {
            olsource = new olVectorSource({
                url: l.url,
                format: new olKML({
                    extractStyles: true,
                    crossOrigin: (l.crossOrigin && l.crossOrigin === null) ? l.crossOrigin : 'anonymous',
                }),
                wrapX: false
            });
        }
        const layeroptions = this.createOlLayerOptions(l, 'kml', olsource);
        const baseVectorLayerOptions = {};
        if (l.options) {
            // here Object.assign modifies the target object - style... is included
            Object.assign(baseVectorLayerOptions, l.options);
        }
        const newlayer = new olVectorLayer(Object.assign(layeroptions, baseVectorLayerOptions));
        if (l.cluster) {
            this.setCluster(l, newlayer, olsource, {});
        }
        this.setCrossOrigin(l, newlayer);
        this.addEventsToLayer(l, newlayer, layeroptions.source);
        return newlayer;
    }
    /** bug fix: https://github.com/openlayers/openlayers/issues/10099 */
    setCrossOrigin(l, layer) {
        if (layer instanceof olLayer) {
            const olsource = layer.getSource();
            /** set crossOrigin for popup layers  */
            if (l.popup && !l.crossOrigin && l.crossOrigin !== null) {
                this.sourceSetCross(olsource);
            }
            if (l.crossOrigin || l.crossOrigin === null) {
                this.sourceSetCross(olsource);
            }
        }
    }
    /**
     * set cluster source and style for point layers
     */
    setCluster(l, layer, source, styleCache) {
        if (l.cluster) {
            const clusteroptions = {};
            if (typeof l.cluster === 'object') {
                // here Object.assign modifies the target object
                Object.assign(clusteroptions, l.cluster);
            }
            clusteroptions.source = source;
            const clusterSource = new olSourceCluster(clusteroptions);
            // layeroptions.source = clusterSource;
            layer.setSource(clusterSource);
            layer.setStyle((feature) => {
                const size = feature.get('features').length;
                let style = styleCache[size];
                if (!style) {
                    style = new olStyle({
                        image: new olCircleStyle({
                            radius: 10,
                            stroke: new olStroke({
                                color: '#fff'
                            }),
                            fill: new olFill({
                                color: '#3399CC'
                            })
                        }),
                        text: new olText({
                            text: size.toString(),
                            fill: new olFill({
                                color: '#fff'
                            })
                        })
                    });
                    styleCache[size] = style;
                }
                return style;
            });
        }
    }
    /** use subdomains to setUrl/s on source */
    setSubdomains(l, layer) {
        if (l instanceof VectorLayer || l instanceof RasterLayer) {
            const source = layer.getSource();
            if (l.subdomains) {
                if (l.type === 'wfs' && (source instanceof olVectorSource)) {
                    l.url = l.url.replace('{s}', `${l.subdomains[0]}-${l.subdomains[l.subdomains.length - 1]}`);
                    source.setUrl(l.url);
                }
                else if (!(source instanceof olVectorSource)) {
                    const urls = l.subdomains.map((item) => l.url.replace('{s}', `${item}`));
                    source.setUrls(urls);
                }
            }
            else {
                source.setUrl(l.url);
            }
        }
    }
    sourceSetCross(source) {
        /**
         * https://github.com/search?q=crossOrigin+repo%3Aopenlayers%2Fopenlayers+path%3Asrc%2Fol%2Fsource%2F&type=Code&ref=advsearch&l=&l=
         */
        if (source instanceof olImageSource || source instanceof olTileImageSource || source instanceof olTileSource) {
            source['crossOrigin'] = 'anonymous';
            source['crossOrigin_'] = 'anonymous';
        }
    }
    /**
     * Use this Layer to add a not supported OpenLayers layer
     *
     * custom_layer: olBaseLayer
     */
    create_custom_layer(l) {
        if (l.custom_layer) {
            const layer = l.custom_layer;
            if (layer instanceof olLayer) {
                const olsource = layer.getSource();
                if (l.attribution) {
                    olsource.setAttributions([l.attribution]);
                }
                if (l.continuousWorld) {
                    /**
                     * set wrapX after source creation is not possible so we have to use the private property
                     * It works based on a test in codesandbox.io
                     * https://github.com/openlayers/openlayers/blob/v6.13.0/src/ol/source/Source.js#L48
                     */
                    // tslint:disable-next-line: no-string-literal
                    olsource['wrapX_'] = l.continuousWorld;
                }
                else {
                    // tslint:disable-next-line: no-string-literal
                    olsource['wrapX_'] = false;
                }
                this.setCrossOrigin(l, layer);
                this.addEventsToLayer(l, layer, olsource);
                // https://github.com/dlr-eoc/ukis-frontend-libraries/issues/100
                if (olsource instanceof olRasterSource) {
                    layer.on('change:source', (evt) => {
                        evt.oldValue.dispose();
                    });
                }
            }
            else if (layer instanceof olLayerGroup) {
                layer.getLayers().forEach(gl => {
                    const layerId = `${l.id}_${getUid(gl)}`;
                    if (!gl.get('id')) {
                        gl.set('id', layerId);
                    }
                    if (gl instanceof olLayer) {
                        this.setCrossOrigin(l, gl);
                        this.addEventsToLayer(l, gl, gl.getSource());
                    }
                    /**
                     * groups are flattened in map.forEachLayerAtPixel so add popup to each layer
                     * popup will be shown for top layer in the Group if there is a pixel color
                     */
                    if (l.popup && !gl.get('popup')) {
                        gl.set('popup', l.popup);
                        /** set className if not default ol-layer */
                        if (gl.getClassName() === 'ol-layer') {
                            gl['className_'] = layerId;
                        }
                    }
                });
            }
            else {
                console.error(`The custom_layer of ${l.id} in not a openlayers Layer`);
            }
            if (l.maxResolution) {
                layer.setMaxResolution(l.maxResolution);
            }
            if (l.minResolution) {
                layer.setMinResolution(l.minResolution);
            }
            if (l.maxZoom) {
                layer.setMaxZoom(l.maxZoom);
            }
            if (l.minZoom) {
                layer.setMinZoom(l.minZoom);
            }
            const layeroptions = {
                type: 'custom',
                name: l.name,
                id: l.id,
                visible: l.visible,
                legendImg: l.legendImg,
                opacity: l.opacity || 1,
                zIndex: 1,
            };
            if (l.popup && !(layer instanceof olLayerGroup)) {
                layeroptions.popup = l.popup;
                /**
                 * ol 6.x problem if popup (map.forEachLayerAtPixel) use className
                 * needs the class Name to detect if it is a different layer at the pixel value
                 * https://github.com/openlayers/openlayers/releases/tag/v6.0.0
                 */
                // tslint:disable-next-line: no-string-literal
                layer['className_'] = l.id;
            }
            if (l.bbox) {
                const extent = transformExtent(l.bbox.slice(0, 4), WGS84, this.getProjection().getCode());
                layer.setExtent(extent);
            }
            layer.setProperties(layeroptions);
            // don't delete the custom Layer, it is used to newly create all layers from layerservice after map all layers removed!
            // delete l.custom_layer;
            return layer;
        }
        else {
            console.log('attribute custom_layer not set on layer type custom!', l);
        }
    }
    /**
     * Use this Layer to stack multiple ukis layers in one.
     * creates a olLayerGroup from create_layers
     */
    create_stacked_layer(l) {
        if (l instanceof StackedLayer) {
            const layers = l.layers.map(ml => {
                /** Set all to visible because the visibility of merge layers cannot be controlled later */
                ml.visible = true;
                /** popups are get from the olLayer later so add them */
                ml.popup = l.popup;
                /** events are get from the olLayer later so add them */
                ml.events = l.events;
                return this.create_layers(ml);
            });
            const baseLayerOptions = this.createOlLayerOptions(l, 'custom');
            const groupOptions = {
                layers
            };
            const layerGroup = new olLayerGroup(Object.assign(baseLayerOptions, groupOptions));
            return layerGroup;
        }
        else {
            console.log('layer is not of type StackedLayer!', l);
        }
    }
    resolutionsFromExtent(extent, optMaxZoom, tileSize) {
        const maxZoom = optMaxZoom;
        const height = getHeight(extent);
        const width = getWidth(extent);
        const maxResolution = Math.max(width / tileSize, height / tileSize);
        const length = maxZoom + 1;
        const resolutions = new Array(length);
        for (let z = 0; z < length; ++z) {
            resolutions[z] = maxResolution / Math.pow(2, z);
        }
        return resolutions;
    }
    matrixIdsFromResolutions(resolutionLevels, matrixIdPrefix) {
        return Array.from(Array(resolutionLevels).keys()).map(l => {
            if (matrixIdPrefix) {
                return `${matrixIdPrefix}:${l}`;
            }
            else {
                return l;
            }
        });
    }
    getTileGrid(type = 'default', resolutionLevels, tileSize, matrixIdPrefix, resolutions, matrixIds) {
        const newResolutionLevels = resolutionLevels || DEFAULT_MAX_ZOOM;
        const newTileSize = tileSize || DEFAULT_TILE_SIZE;
        const newMatrixIdPrefix = matrixIdPrefix || '';
        const projectionExtent = this.getProjection().getExtent();
        const defaultResolutions = this.resolutionsFromExtent(projectionExtent, newResolutionLevels, newTileSize);
        const defaultMatrixIds = this.matrixIdsFromResolutions(defaultResolutions.length, newMatrixIdPrefix);
        /** how to generate matrix ids is not in the wms GetCapabilities ?? */
        const tileGridOptions = {
            extent: projectionExtent,
            origin: getTopLeft(projectionExtent),
            resolutions: resolutions || defaultResolutions,
            tileSize: [newTileSize, newTileSize]
        };
        if (type === 'wmts') {
            tileGridOptions.matrixIds = matrixIds || defaultMatrixIds;
            const grid = new olWMTSTileGrid(tileGridOptions);
            return grid;
        }
        else if (type === 'default') {
            const grid = new olTileGrid(tileGridOptions);
            return grid;
        }
    }
    isPopupObj(layerpopup) {
        return (layerpopup && typeof layerpopup === 'object') && !Array.isArray(layerpopup);
    }
    isPopupObjMove(layerpopup) {
        return (this.isPopupObj(layerpopup) && layerpopup.event === 'move');
    }
    isPopupObjClick(layerpopup) {
        return (this.isPopupObj(layerpopup) && layerpopup.event === 'click');
    }
    isPopupObjArray(layerpopup) {
        return Array.isArray(layerpopup) && layerpopup.length && this.isPopupObj(layerpopup[0]);
    }
    isPopupStringArray(layerpopup) {
        return Array.isArray(layerpopup) && layerpopup.length && typeof layerpopup[0] === 'string';
    }
    eventIsBrowserEvent(popupEvt, evt) {
        if (popupEvt === 'move' && evt.type === 'pointermove') {
            return true;
        }
        else if (popupEvt === 'click' && evt.type === 'click') {
            return true;
        }
    }
    /** USED in map-ol.component */
    /**
     * TODO:
     * - check the pointer event
     * - on move event set cursor -> depends on which kind of layer??
     *   layers with features and only color pixel
     *
     * - forEachFeatureAtPixel: Detect features that intersect a pixel on the viewport
     *   Vector Layers???
     *
     * - forEachLayerAtPixel: Detect layers that have a color value at a pixel on the viewport (false positives unless the map layers have had different className)
     *   Raster Layers???
     */
    /**
     *  layers_on_click() and layers_on_pointermove() should be removed
     *  this filtering must be done later
     *
     *  1. on a Map event Filter if map has layers on the pixel
     *  forEachLayerAtPixel: Detect layers that have a color value at a pixel on the viewport (false positives unless the map layers have had different className)
     *  check layer source crossOrigin = anonymous
     *
     *  2. Filter if it is the top visible layer - so no popups are shown for layers beneath https://github.com/dlr-eoc/ukis-frontend-libraries/issues/94#issuecomment-916759628
     *  3. check if the top visible layer has a popup property
     *  4. For this Layer change the cursor on forEachLayerAtPixel -> hit
     *
     *  5. Differentiate between raster and vector to get features or layer.color for the properties passed to the popup
     *  For Features change the cursor on forEachFeatureAtPixel -> hit
     *
     *  6. limit properties if popup property is: Array<string> | popup | popup[] -> popup?.filterkeys
     *  7. overwrite properties if popup property is: popup | popup[]
     *  8. check for popupFunction, asyncPopup and dynamicPopup
     *  9. use addPopup() or addPopupObj()
     *
     *  10. check popup event and if move popup exists => reuse old popup
     *  11. remove move popups if different event or !popup.event
     *  12. create new popup if not 10. or 11.
     *  13. prepare ol overlayoptions
     *  14. remove DynamicPopup if exists
     *  15. createPopupContainer
     *  16. set ol overlay addEvent and type = popup
     *  17. get coordinate from geometry or map.event
     *  18. set Position and map.addOverlay(overlay) if popup not exists
     */
    layersOnMapEvent(evt) {
        let layerHit = false;
        /**
         * Detect layers that have a color value at a pixel on the viewport, and execute a callback with each matching layer.
         * Layers included in the detection can be configured through opt_layerFilter.
         *
         * Note: this may give false positives unless the map layers have had different *className* properties assigned to them.
         * Also there could be cross-origin data, so set crossOrigin: 'anonymous' for layers where you want get pixel data!!
         */
        const item = this.map.forEachLayerAtPixel(evt.pixel, (layer, color) => {
            /**
             * return to stop detection and use the top (first detected) layer
             * This is faster than pushing the layers into an array and iterate over it.
             * And normally the user is only interested in the top Layer. If it is still necessary to detect several layers at the same time, then use a new function for map.on()
             */
            return { layer, color };
        }, {
            layerFilter: this.filterLayerNoPopup
        });
        if (item) {
            /**
             * only show for top layer and if top layer has popup
             */
            const hasPopup = (item.layer.get('popup'));
            if (hasPopup) {
                /** check if cursor was set (we need this only on move?) */
                this.hitLayerCurr = item.layer.get('id');
                if (!this.hitLayerPrev) {
                    this.hitLayerPrev = this.hitLayerCurr;
                }
                /** set cursor for Layers with a color value */
                if (item.color) {
                    layerHit = true;
                }
                /** remove cursor and move-popups on layer change */
                if (this.hitLayerPrev && this.hitLayerPrev !== this.hitLayerCurr) {
                    layerHit = false;
                    this.hitLayerPrev = this.hitLayerCurr;
                }
                const useEvent = this.topLayerCheckEvent(evt, hasPopup);
                if (useEvent) {
                    this.layerOnEvent(evt, item.layer, item.color);
                }
            }
        }
        if (layerHit) {
            this.map.getTargetElement().style.cursor = 'pointer';
        }
        else {
            this.removeAllPopups((item) => {
                return item.get('addEvent') === 'pointermove';
            });
            this.map.getTargetElement().style.cursor = '';
        }
    }
    topLayerCheckEvent(evt, popup) {
        let useEvent = null;
        const clickOrMove = (evt, popup) => {
            if (popup.event) {
                if (this.eventIsBrowserEvent(popup.event, evt) && this.isPopupObjClick(popup)) {
                    useEvent = 'click';
                }
                else if (this.eventIsBrowserEvent(popup.event, evt) && this.isPopupObjMove(popup)) {
                    useEvent = 'move';
                }
            }
            else {
                /** only show popups without an event for browser click  */
                if (evt.type === 'click') {
                    useEvent = 'click';
                }
            }
        };
        // check event is browser event
        if (typeof popup === 'boolean') {
            if (popup === true) {
                /** only show popups without an event for browser click  */
                if (evt.type === 'click') {
                    useEvent = 'click';
                }
            }
        }
        else if (this.isPopupStringArray(popup)) {
            /** only show popups without an event for browser click  */
            if (evt.type === 'click') {
                useEvent = 'click';
            }
        }
        else {
            /** popup is  popup | popup[] */
            if (this.isPopupObjArray(popup)) {
                popup.map(p => {
                    clickOrMove(evt, p);
                });
            }
            else {
                clickOrMove(evt, popup);
            }
        }
        return useEvent;
    }
    /**
     * https://openlayers.org/en/latest/apidoc/module-ol_layer_Layer-Layer.html#Subclasses
     */
    checkIsRaster(layer) {
        if (layer instanceof olBaseImageLayer || layer instanceof olBaseTileLayer) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * https://openlayers.org/en/latest/apidoc/module-ol_layer_Layer-Layer.html#Subclasses
     */
    checkIsVector(layer) {
        if (layer instanceof olBaseVectorLayer && !this.checkIsRaster(layer)) {
            return true;
        }
        else {
            return false;
        }
    }
    layerOnEvent(evt, layer, color) {
        if (this.checkIsRaster(layer)) {
            this.rasterOnEvent(evt, layer, color);
        }
        else if (this.checkIsVector(layer)) {
            this.vectorOnEvent(evt);
        }
    }
    vectorOnEvent(evt) {
        let featureHit = false;
        const item = this.map.forEachFeatureAtPixel(evt.pixel, (feature, layer) => {
            /** set cursor for features with a color value */
            featureHit = true;
            /**
             * return to stop detection and use the top (first detected) feature
             * This is faster than pushing the feature into an array and iterate over it.
             */
            return { feature, layer };
        }, {
            layerFilter: (layer) => {
                let shouldNotFilterLayer = true;
                if (layer instanceof olBaseVectorLayer) {
                    const olSource = layer.getSource();
                    if (olSource instanceof olSourceCluster) {
                        shouldNotFilterLayer = olSource.getSource() instanceof olVectorSource;
                    }
                    else {
                        shouldNotFilterLayer = olSource instanceof olVectorSource || olSource instanceof olVectorTileSource;
                    }
                }
                const filter = this.filterLayerNoPopup(layer);
                if (filter === false) {
                    shouldNotFilterLayer = false;
                }
                /** fix for https://github.com/openlayers/openlayers/issues/12886 */
                const layerExtent = layer.getExtent();
                if (layerExtent) {
                    const pixelCoordinate = this.map.getCoordinateFromPixel(evt.pixel);
                    if (!containsCoordinate(layerExtent, pixelCoordinate)) {
                        shouldNotFilterLayer = false;
                    }
                }
                return shouldNotFilterLayer;
            },
            hitTolerance: this.hitTolerance
        });
        if (item) {
            /**
             * only show for top feature and if top layer has popup
             */
            const hasPopup = (item.layer.get('popup'));
            if (hasPopup) {
                const layer = item.layer;
                const feature = item.feature;
                let properties = {};
                const childFeatures = feature.getProperties().features;
                if (childFeatures && childFeatures.length === 1) {
                    const childFeature = childFeatures[0];
                    properties = childFeature.getProperties();
                }
                else if (childFeatures && childFeatures.length > 1) {
                    /**
                     * zoom to cluster on click
                     * or check for layerpopup.event !== move
                     */
                    if (evt.type === 'click') {
                        const extent = this.getFeaturesExtent(feature.getProperties().features);
                        this.setExtent(extent);
                        return false;
                    }
                    else {
                        return true;
                    }
                }
                else {
                    // type no cluster
                    properties = feature.getProperties();
                }
                this.prepareAddPopup(properties, layer, feature, evt, hasPopup);
            }
        }
        if (featureHit) {
            this.map.getTargetElement().style.cursor = 'pointer';
        }
        else {
            this.map.getTargetElement().style.cursor = '';
        }
    }
    rasterOnEvent(evt, layer, color) {
        const layerpopup = layer.get('popup');
        let properties = {};
        if (layerpopup) {
            properties = layer.getProperties();
            properties.evt = evt;
            if (color) {
                properties.color = color;
            }
            this.prepareAddPopup(properties, layer, null, evt, layerpopup);
        }
    }
    prepareAddPopup(layerProperties, layer, feature, evt, layerpopup) {
        const args = {
            modelName: layerProperties.id,
            properties: layerProperties,
            layer,
            feature,
            event: evt
        };
        let popupProperties = Object.assign({}, layerProperties);
        if (popupProperties.geometry) {
            delete popupProperties.geometry;
        }
        const limitPopupObjProperties = (popupObj) => {
            if (popupObj && popupObj.filterkeys) {
                popupProperties = Object.keys(popupProperties)
                    .filter(key => popupObj.filterkeys.includes(key))
                    .reduce((obj, key) => {
                    obj[key] = popupProperties[key];
                    return obj;
                }, {});
            }
        };
        /** Popup is array - limit properties */
        if (this.isPopupStringArray(layerpopup)) {
            popupProperties = Object.keys(popupProperties)
                .filter(key => layerpopup.includes(key))
                .reduce((obj, key) => {
                obj[key] = popupProperties[key];
                return obj;
            }, {});
        }
        /** Popup is array of popupObj - limit properties */
        else if (this.isPopupObjArray(layerpopup)) {
            // is the first popupObj in the array with the same event as evt.type
            const popupObj = layerpopup.find(p => this.eventIsBrowserEvent(p.event, evt));
            limitPopupObjProperties(popupObj);
        }
        /** Popup is object - limit properties */
        else if (this.isPopupObj(layerpopup)) {
            limitPopupObjProperties(layerpopup);
        }
        const overwritePopup = (popupObj) => {
            /** overwrite the keys of the layer properties */
            if (popupObj.properties) {
                const usedProperties = Object.keys(popupObj.properties);
                if (Array.isArray(usedProperties)) {
                    popupProperties = Object.keys(popupProperties)
                        /* .filter(key => usedProperties.includes(key)) */
                        .reduce((obj, key) => {
                        const newKey = popupObj.properties[key];
                        if (newKey) {
                            obj[newKey] = popupProperties[key];
                        }
                        else {
                            obj[key] = popupProperties[key];
                        }
                        return obj;
                    }, {});
                }
            }
        };
        /** overwrite and us popupFunction or dynamicPopup */
        if (this.isPopupObjArray(layerpopup)) {
            layerpopup.forEach(p => {
                if (this.eventIsBrowserEvent(p.event, evt)) {
                    overwritePopup(p);
                }
            });
        }
        else if (this.isPopupObj(layerpopup)) {
            overwritePopup(layerpopup);
        }
        const addPopupObj = (popupObj) => {
            /** async function where you can paste a html string to the callback */
            if ('asyncPopup' in popupObj) {
                popupObj.asyncPopup(popupProperties, (html) => {
                    this.addPopup(args, null, html, popupObj.event, popupObj.single);
                });
                /** add event if popup object */
            }
            else {
                /** adjust args if popupFunction or dynamicPopup*/
                if (popupObj.popupFunction) {
                    args.popupFn = popupObj.popupFunction; //This could be done in createPopupContainer()
                }
                else if (popupObj.dynamicPopup) {
                    args.dynamicPopup = popupObj.dynamicPopup; // This could be done in createPopupContainer()
                }
                this.addPopup(args, popupProperties, null, popupObj.event, popupObj.single);
            }
        };
        /** popup is boolean or string array */
        if (typeof layerpopup === 'boolean' || this.isPopupStringArray(layerpopup)) {
            this.addPopup(args, popupProperties, null);
        }
        /** popup array of popupObj */
        else if (this.isPopupObjArray(layerpopup)) {
            layerpopup.forEach(p => {
                // filter that browser event and popup event are the same
                if (this.eventIsBrowserEvent(p.event, evt)) {
                    addPopupObj(p);
                }
            });
        }
        /** popup is a popupObj */
        else if (layerpopup) {
            addPopupObj(layerpopup);
        }
    }
    // TODO: overlapping layers - move popup is added on click ???
    addPopup(args, popupObj, html, event, removePopups) {
        var _a, _b;
        const layerpopup = args.layer.get('popup');
        // check if popup is already there and event is move
        const layerID = args.layer.get('id');
        const moveID = `popup_move_ID`;
        const moveKeyLayerFeature = 'move_ID_L_F';
        const movePopup = this.getPopups().find(item => item.getId() === moveID);
        const browserEvent = args.event;
        let moveIDlf = null;
        if (event === 'move') {
            /** only on raster color is added - see rasterOnEvent()*/
            if ((_a = args.properties) === null || _a === void 0 ? void 0 : _a.color) {
                moveIDlf = `${layerID}:${(_b = args.properties) === null || _b === void 0 ? void 0 : _b.color.toString()}`;
            }
            else {
                if (args.feature) {
                    moveIDlf = `${layerID}:${getUid(args.feature)}`;
                }
                else if (args.layer) {
                    moveIDlf = `${layerID}:${getUid(args.layer)}`;
                }
            }
        }
        /**
         * If event move and the map already has a Overlay for move
         * then only create new html container and set the position
         */
        if (event === 'move' && browserEvent.type === 'pointermove' && movePopup) {
            let coordinate;
            if (args.properties && args.properties.geometry && args.properties.geometry.getType() === 'Point') {
                coordinate = args.properties.geometry.getCoordinates();
            }
            else {
                coordinate = browserEvent.coordinate;
            }
            /** check if layer or feature changes, then only create new container */
            if (moveIDlf !== movePopup.get(moveKeyLayerFeature)) {
                const container = this.createPopupContainer(movePopup, args, popupObj, html, event);
                movePopup.setElement(container);
            }
            movePopup.setPosition(coordinate);
            /** update movePopup to be rendered over the previous added popup */
            movePopup.getElement().parentElement.style.zIndex = '1';
        }
        else if (browserEvent.type === 'pointermove' && !event) {
            /** remove move popup if move on a click layer */
            if (movePopup) {
                this.removeAllPopups((item) => {
                    return item.get('addEvent') === 'pointermove';
                });
            }
        }
        else if (browserEvent.type === 'pointermove' && event === 'click') {
            if (movePopup) {
                this.removeAllPopups((item) => {
                    return item.get('addEvent') === 'pointermove';
                });
            }
        }
        else {
            let popupID = null;
            if (event === 'move') {
                popupID = moveID;
            }
            else {
                if (args.feature) {
                    popupID = `${layerID}:${getUid(args.feature)}`;
                }
                else if (args.layer) {
                    popupID = `${layerID}:${getUid(args.layer)}`;
                }
                else {
                    popupID = `${layerID}:popup_${new Date().getTime()}`;
                }
            }
            const defaultOptions = {
                // element: container,
                autoPan: true,
                id: popupID,
                autoPanAnimation: {
                    duration: 250
                },
                positioning: OverlayPositioning.BOTTOM_CENTER,
                stopEvent: true,
                insertFirst: false,
            };
            let overlayoptions = defaultOptions;
            /**
             * Check if popup is an array of popup obj's or a popup obj
             * then merge the popup?.options with the default ol/overlay options
             */
            if (this.isPopupObjArray(layerpopup)) {
                const objForEvent = layerpopup.find(p => this.eventIsBrowserEvent(p.event, browserEvent));
                if (objForEvent.options) {
                    overlayoptions = Object.assign(defaultOptions, objForEvent.options);
                }
            }
            else if (this.isPopupObj(layerpopup) && layerpopup.options) {
                overlayoptions = Object.assign(defaultOptions, layerpopup.options);
            }
            const overlay = new olOverlay(overlayoptions);
            if (moveIDlf) {
                overlay.set(moveKeyLayerFeature, moveIDlf);
            }
            if (removePopups) {
                this.removeAllPopups((item) => {
                    // only remove the popups from the current layer
                    const elementID = item.getId();
                    const layer = elementID.toString().split(':')[0];
                    if (layer) {
                        if (layerID === layer) {
                            return layerID === layer;
                        }
                    }
                    else {
                        return true;
                    }
                });
            }
            const hasPopup = this.getPopups().find(item => (item.getId() === overlay.getId() && overlay.getId() !== moveID));
            if (hasPopup) {
                // removes ol-part of popup
                this.map.removeOverlay(hasPopup);
                // removes angular-part of popup
                this.destroyDynamicPopupComponent(hasPopup.getId().toString());
            }
            const container = this.createPopupContainer(overlay, args, popupObj, html, event);
            /** edge case when moving and clicking sometimes the browser event is not like the popup event */
            if (overlay.getId() === moveID) {
                overlay.set('addEvent', 'pointermove');
            }
            else {
                overlay.set('addEvent', browserEvent.type);
            }
            overlay.set(OVERLAY_TYPE_KEY, 'popup');
            overlay.setElement(container);
            let coordinate;
            if (args.properties && args.properties.geometry && args.properties.geometry.getType() === 'Point') {
                coordinate = args.properties.geometry.getCoordinates();
            }
            else {
                coordinate = browserEvent.coordinate;
            }
            overlay.setPosition(coordinate);
            /**
             * edge case prevent add multiple movePopup's
             * only add a new popup if it's not a movePopup or there isn't a already existing movePopup
             */
            if (!(movePopup && event === 'move')) {
                this.map.addOverlay(overlay);
            }
        }
    }
    createPopupContainer(overlay, args, popupObj, html, event) {
        const content = document.createElement('div');
        content.className = 'ol-popup-content';
        let popupHtml = '';
        if (args.popupFn) {
            popupHtml = args.popupFn(popupObj);
        }
        else if (html && (!popupObj || Object.keys(popupObj).length === 0)) {
            popupHtml = html;
        }
        else {
            popupHtml = this.createPopupHtml(popupObj);
        }
        content.innerHTML = popupHtml;
        if (args.dynamicPopup) {
            // To prevent memory leak:
            // if this very popup already has been created (for example `popup_move_ID`),
            // then destroy it before creating a new one.
            const id = overlay.getId().toString();
            this.destroyDynamicPopupComponent(id);
            // Only now create a new one.
            const dArgs = {
                event: args.event,
                layer: args.layer,
                feature: args.feature || null,
                dynamicPopup: args.dynamicPopup,
                properties: popupObj,
            };
            this.createDynamicPopupComponent(id, content, dArgs);
        }
        const container = document.createElement('div');
        container.className = 'ol-popup';
        container.id = overlay.getId().toString();
        container.style.display = 'block';
        if (!event || event !== 'move') {
            const closer = document.createElement('a');
            closer.className = 'ol-popup-closer';
            container.appendChild(closer);
            const closeFunction = () => {
                closer.removeEventListener('click', closeFunction, false);
                // removes ol-part of popup
                this.map.removeOverlay(overlay);
                // removes angular-part of popup
                this.destroyDynamicPopupComponent(overlay.getId().toString());
            };
            closer.addEventListener('click', closeFunction, false);
        }
        container.appendChild(content);
        return container;
    }
    /** USED in map-ol.component */
    removeAllPopups(filter) {
        let popups = this.getPopups();
        if (filter) {
            popups = this.getPopups().filter(filter);
        }
        popups.forEach((overlay) => {
            if (overlay.get(OVERLAY_TYPE_KEY) === 'popup') {
                // removes ol-part of popup
                this.map.removeOverlay(overlay);
                // removes angular-part of popup
                this.destroyDynamicPopupComponent(overlay.getId().toString());
            }
        });
    }
    createPopupHtml(obj) {
        let htmlStr = '<table>';
        for (const o in obj) {
            if (obj.hasOwnProperty(o)) {
                htmlStr += '<tr><td style="vertical-align: top; padding-right: 7px;"><b>' + o + ': </b></td><td>' + obj[o] +
                    '</td></tr>';
            }
        }
        htmlStr = htmlStr + '</table>';
        return htmlStr;
    }
    getPopups() {
        const popups = [];
        this.map.getOverlays().getArray().slice(0).forEach((overlay) => {
            if (overlay.get(OVERLAY_TYPE_KEY) === 'popup') {
                popups.push(overlay);
            }
        });
        return popups;
    }
    /**
     * Destroys a popup-component.
     *  - kills the component (with `.destroy()`)
     *  - detaches it from angular-application (with `.destroy()`)
     *  - removes the entry from `this.dynamicPopupComponents`
     * @param id : The string under which the popup-component has been stored in `this.dynamicPopupComponents`
     */
    destroyDynamicPopupComponent(id) {
        if (this.dynamicPopupComponents.has(id)) {
            this.dynamicPopupComponents.get(id).destroy();
            this.dynamicPopupComponents.delete(id);
        }
    }
    /**
     * Creates an angular component to be used as popup-body.
     *  - creates component
     *  - attaches component-view to angular-application
     *  - keeps reference to component in `this.dynamicPopupComponents` for later removal.
     *
     * @param id : The container-id. Also the id under which the component will be stored in `this.dynamicPopupComponents`.
     * @param anchorElement : The html-element to which the popup-component shall be attached
     * @param args : Must contain `dynamicPopup`
     */
    createDynamicPopupComponent(id, anchorElement, args) {
        const factory = this.crf.resolveComponentFactory(args.dynamicPopup.component);
        const popupBody = factory.create(this.injector, [], anchorElement);
        if (args.dynamicPopup.getAttributes) {
            const attributes = args.dynamicPopup.getAttributes(args);
            for (const key in attributes) {
                if (attributes[key] !== 'undefined') {
                    popupBody.instance[key] = attributes[key];
                }
            }
        }
        this.app.attachView(popupBody.hostView);
        this.dynamicPopupComponents.set(id, popupBody);
    }
    /**
     *
     * @param extent: [minX, minY, maxX, maxY]
     * @param geographic: boolean
     * @param fitOptions: olFitOptions
     * @returns olExtend: [minX, minY, maxX, maxY]
     */
    setExtent(extent, geographic, fitOptions) {
        const projection = (geographic) ? get(WGS84) : get(this.EPSG);
        const transfomExtent = transformExtent(extent.slice(0, 4), projection, this.getProjection().getCode());
        const newFitOptions = {
            size: this.map.getSize(),
            // padding: [100, 200, 100, 100] // Padding (in pixels) to be cleared inside the view. Values in the array are top, right, bottom and left padding. Default is [0, 0, 0, 0].
        };
        if (fitOptions) {
            Object.assign(newFitOptions, fitOptions);
        }
        this.map.getView().fit(transfomExtent, fitOptions);
        return transfomExtent;
    }
    /** USED in map-ol.component */
    /** ol.Coordinate xy */
    setCenter(center, geographic) {
        const projection = (geographic) ? get(WGS84) : get(this.EPSG);
        const transfomCenter = transform(center, projection, this.getProjection().getCode());
        // console.log('set center in svc', transfomCenter)
        // console.log(this.map.getView().getCenter())
        this.map.getView().setCenter(transfomCenter);
        return transfomCenter;
    }
    /** USED in map-ol.component */
    getCenter(geographic) {
        const dstProjection = (geographic) ? get(WGS84) : get(this.EPSG);
        const srcProjection = get(this.getProjection().getCode());
        const transfomCenter = transform(this.map.getView().getCenter(), srcProjection, dstProjection);
        return transfomCenter;
    }
    /**
     *
     * @param features: olFeature[]
     * @param geographic: boolean
     * @returns olExtend: [minX, minY, maxX, maxY]
     */
    getFeaturesExtent(features, geographic) {
        const extent = features[0].getGeometry().getExtent().slice(0);
        features.forEach((feature) => {
            extend(extent, feature.getGeometry().getExtent());
        });
        if (geographic) {
            const projection = get(WGS84);
            const transfomExtent = transformExtent(extent, this.getProjection().getCode(), projection);
            return transfomExtent;
        }
        else {
            return extent;
        }
    }
    /** USED in map-ol.component */
    /**
     * @param geographic: boolean
     * @returns olExtend: [minX, minY, maxX, maxY]
     */
    getCurrentExtent(geographic) {
        const projection = (geographic) ? get(WGS84) : get(this.EPSG);
        const extent = this.map.getView().calculateExtent();
        const transfomExtent = transformExtent(extent, this.getProjection().getCode(), projection);
        return transfomExtent;
    }
    /** USED in map-ol.component */
    setZoom(zoom, notifier) {
        const view = this.map.getView();
        view.setZoom(zoom);
    }
    /** USED in map-ol.component */
    getZoom() {
        return this.map.getView().getZoom();
    }
    zoomInOut(value) {
        const view = this.map.getView();
        if (!view) {
            // the map does not have a view, so we can't act
            // upon it
            return;
        }
        const duration = 250;
        const delta = value === '+' ? 1 : -1;
        const currentZoom = view.getZoom();
        if (currentZoom !== undefined) {
            const newZoom = view.getConstrainedZoom(currentZoom + delta);
            if (duration > 0) {
                if (view.getAnimating()) {
                    view.cancelAnimations();
                }
                view.animate({
                    zoom: newZoom,
                    duration,
                    easing: easeOut
                });
            }
            else {
                view.setZoom(newZoom);
            }
        }
    }
    geoJsonToFeature(geojson) {
        const GEOJSON = new olGeoJSON({
            dataProjection: WGS84,
            featureProjection: this.EPSG
        });
        return GEOJSON.readFeature(geojson);
    }
    geoJsonToFeatures(geojson) {
        const GEOJSON = new olGeoJSON({
            dataProjection: WGS84,
            featureProjection: this.EPSG
        });
        return GEOJSON.readFeatures(geojson);
    }
    /**
     * @returns 'olProjection'
     */
    getProjection() {
        return this.map.getView().getProjection();
    }
    /**
     * function to reproject vector features
     * @param source:  olVectorSource
     * @param srcProj: string (e.g. 'EPSG:4326')
     * @param dstProj: string (e.g. 'EPSG:3857')
     */
    reprojectFeatures(source, srcProj, dstProj) {
        source.getFeatures().forEach(feature => {
            feature.getGeometry().transform(srcProj, dstProj);
        });
    }
    /**
     * vector layers will be reprojected automatically
     * wms layers will be updated with corresponding proj def in the requests.
     * for other raster layers and for those wms layers which backend does not support target projection, please
     * define initial(default) layer projection, so openlayers will reproject on the client side
     * projection is proj~ProjectionLike
     */
    setProjection(projection) {
        if (projection) {
            let viewOptions = {};
            if (this.viewOptions) {
                viewOptions = this.viewOptions;
                viewOptions.minResolution = undefined;
                viewOptions.maxResolution = undefined;
                viewOptions.resolution = undefined;
                viewOptions.resolutions = undefined;
            }
            if (projection instanceof olProjection) {
                viewOptions.projection = projection;
                const newCenter = transform(this.map.getView().getCenter(), this.map.getView().getProjection(), projection); // get center coordinates in the new projection
                viewOptions.center = newCenter; // this.map.getView().getCenter();
                // _viewOptions.extent = projection.getExtent();// || undefined;
                viewOptions.zoom = this.map.getView().getZoom();
            }
            else if (typeof projection === 'string') {
                viewOptions.projection = projection;
                viewOptions.center = this.map.getView().getCenter();
                viewOptions.zoom = this.map.getView().getZoom();
            }
            const view = new olView(viewOptions);
            const oldProjection = this.EPSG;
            this.EPSG = view.getProjection().getCode();
            this.map.setView(view);
            this.view = this.map.getView();
            // reprojecting vector layers
            this.map.getLayers().getArray().forEach((layerGroup) => {
                layerGroup.getLayers().getArray().forEach(layer => {
                    if (layer instanceof olLayer) {
                        let source = layer.getSource();
                        // check for nested sources, e.g. cluster or cluster of clusters etc
                        while (source['source']) {
                            source = source['source'];
                        }
                        if (source instanceof olVectorSource) {
                            this.reprojectFeatures(source, oldProjection, this.EPSG);
                        }
                    }
                });
            });
            this.projectionChange.next(this.getProjection());
        }
        else {
            // console.log('projection code is undefined');
        }
    }
    /**
     * @param projDef.code - e.g.: "EPSG:4326"
     * @param projDef.proj4js - e.g.: "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"
     */
    registerProjection(projDef) {
        proj4.defs(projDef.code, projDef.proj4js);
        register(proj4);
    }
    /**
     * Returns a OpenLayers Projection from Options
     */
    getOlProjection(projDef) {
        return new olProjection({
            code: projDef.code,
            extent: projDef.extent ? projDef.extent : undefined,
            worldExtent: projDef.worldExtent ? projDef.worldExtent : undefined,
            global: projDef.global ? projDef.global : false,
            units: projDef.units ? projDef.units : undefined
        });
    }
    keysToUppercase(obj) {
        Object.keys(obj).forEach((key) => {
            const k = key.toUpperCase();
            if (k !== key) {
                obj[k] = obj[key];
                delete obj[key];
            }
        });
        return obj;
    }
}
MapOlService.fac = i0.ngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: MapOlService, deps: [{ token: i0.ComponentFactoryResolver }, { token: i0.ApplicationRef }, { token: i0.Injector }], target: i0.FactoryTarget.Injectable });
MapOlService.prov = i0.ngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: MapOlService, providedIn: 'root' });
i0.ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: MapOlService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i0.ComponentFactoryResolver }, { type: i0.ApplicationRef }, { type: i0.Injector }]; } });

const ID_KEY = 'id';
class MapOlComponent {
    constructor(mapSvc, ngZone) {
        this.mapSvc = mapSvc;
        this.ngZone = ngZone;
        this.subs = [];
        this.privMapwidth = 0;
        this.removePopupsOnMouseLeave = (evt) => {
            this.mapSvc.removeAllPopups((item) => {
                return item.get('addEvent') === 'pointermove';
            });
        };
    }
    get mapwidth() {
        return this.privMapwidth;
    }
    set mapwidth(width) {
        this.privMapwidth = width;
        this.map.updateSize();
    }
    /**
     * - subscribe to layers oninit so they get pulled after view init
     */
    ngOnInit() {
        /** Subscribe to mapStateSvc before map is created */
        this.subscribeToMapState();
        this.initMap();
        this.subscribeToLayers();
    }
    /**
     * - set target of ol map after angular has rendered the element
     * - then subscribe to map events
     */
    ngAfterViewInit() {
        this.map.setTarget(this.mapDivView.nativeElement);
        /** Get last state from mapStateSvc and set it, so a User can set the initial MapState in a component on ngOnInit */
        const oldMapState = this.mapStateSvc.getMapState().getValue();
        this.setMapState(oldMapState);
        /** Subscribe to map events when the map completely created  */
        this.subscribeToMapEvents();
        this.map.getTargetElement().addEventListener('mouseleave', this.removePopupsOnMouseLeave);
    }
    ngAfterViewChecked() {
        /**
         * - compare map size to update Map Size on container resize
         * - set Timeout to also resize map on route change
         */
        if (this.mapDivView) {
            const mapWidth = this.mapDivView.nativeElement.offsetWidth;
            if (mapWidth !== this.mapwidth) {
                this.ngZone.runOutsideAngular(() => {
                    setTimeout(() => {
                        this.mapwidth = mapWidth;
                    }, 100);
                });
            }
        }
    }
    ngOnDestroy() {
        this.subs.forEach(sub => sub.unsubscribe());
        if (this.map) {
            this.map.un('moveend', this.mapOnMoveend);
            this.map.un('click', this.mapOnClickMove);
            this.map.un('dblclick', this.mapOnDclick);
            this.map.getTargetElement().removeEventListener('mouseleave', this.removePopupsOnMouseLeave);
            this.map.getInteractions().forEach((i) => {
                this.map.removeInteraction(i);
            });
        }
    }
    addUpdateLayers(layers, filtertype, layersunderneath) {
        /** get all underneath layers for zIndex */
        let otherlayerslength = 0;
        layersunderneath.forEach(itemType => {
            otherlayerslength += this.mapSvc.getLayers(itemType).length;
        });
        /** if length of layers has changed add new layers */
        if (layers.length !== this.mapSvc.getLayers(filtertype).length) {
            this.mapSvc.setUkisLayers(layers, filtertype);
            // if layers underneath add thhen to the zIndex of layer
            if (otherlayerslength > 0) {
                for (const layer of layers) {
                    const ollayer = this.mapSvc.getLayerByKey({ key: ID_KEY, value: layer.id }, filtertype);
                    if (ollayer) {
                        if (ollayer.getZIndex() !== layers.indexOf(layer) + otherlayerslength) {
                            ollayer.setZIndex(layers.indexOf(layer) + otherlayerslength);
                            this.setZIndexForGroup(ollayer, layers, layer, otherlayerslength);
                        }
                    }
                }
            }
        }
        else {
            /** if layers already on the map -length not changed- update them */
            for (const layer of layers) {
                const ollayer = this.mapSvc.getLayerByKey({ key: ID_KEY, value: layer.id }, filtertype);
                if (ollayer) {
                    if (ollayer.getVisible() !== layer.visible) {
                        ollayer.setVisible(layer.visible);
                    }
                    if (ollayer.getOpacity() !== layer.opacity) {
                        ollayer.setOpacity(layer.opacity);
                    }
                    if (layer instanceof CustomLayer && ollayer instanceof olLayer) {
                        const newSource = layer.custom_layer.getSource();
                        const oldSource = ollayer.getSource();
                        if (newSource && getUid(oldSource) !== getUid(newSource)) {
                            ollayer.setSource(newSource);
                            // https://github.com/dlr-eoc/ukis-frontend-libraries/issues/100
                            if (oldSource instanceof olRasterSource) {
                                oldSource.dispose();
                            }
                        }
                    }
                    else if (layer instanceof CustomLayer && layer.custom_layer instanceof olLayerGroup && ollayer instanceof olLayerGroup) {
                        const newLayers = layer.custom_layer.getLayers().getArray();
                        const oldLayers = ollayer.getLayers().getArray();
                        /** assume the order and length of layers is not changing and no more grouping!!! */
                        oldLayers.forEach((l, i) => {
                            const newLayer = newLayers[i];
                            if (l instanceof olLayer && newLayer instanceof olLayer) {
                                const oldSource = l.getSource();
                                const newSource = newLayer.getSource();
                                if (newSource && getUid(oldSource) !== getUid(newSource)) {
                                    l.setSource(newSource);
                                }
                            }
                        });
                    }
                    if (otherlayerslength > 0) {
                        if (ollayer.getZIndex() !== layers.indexOf(layer) + otherlayerslength) {
                            ollayer.setZIndex(layers.indexOf(layer) + otherlayerslength);
                            this.setZIndexForGroup(ollayer, layers, layer, otherlayerslength);
                        }
                    }
                    else {
                        if (ollayer.getZIndex() !== layers.indexOf(layer)) {
                            ollayer.setZIndex(layers.indexOf(layer));
                            this.setZIndexForGroup(ollayer, layers, layer);
                        }
                    }
                    this.updateLayerParamsWith(ollayer, layer);
                }
            }
        }
    }
    /** addresses an issue in openlayers: https://github.com/openlayers/openlayers/issues/6654 */
    setZIndexForGroup(ollayer, layers, layer, otherlayerslength) {
        if (ollayer instanceof olLayerGroup) {
            ollayer.getLayers().forEach(l => {
                if (otherlayerslength) {
                    l.setZIndex(layers.indexOf(layer) + otherlayerslength);
                }
                else {
                    l.setZIndex(layers.indexOf(layer));
                }
            });
        }
    }
    updateLayerParamsWith(oldLayer, newLayer) {
        switch (newLayer.type) {
            case WmsLayertype:
                this.updateWmsLayerParamsWith(oldLayer, newLayer);
                break;
            case WmtsLayertype:
                this.updateWmtsLayerParamsWith(oldLayer, newLayer);
                break;
            case GeojsonLayertype:
                this.updateGeojsonLayerParamsWith(oldLayer, newLayer);
                break;
            case WfsLayertype:
                this.updateWfsLayerParamsWith(oldLayer, newLayer);
                break;
            default:
                break;
        }
    }
    updateWfsLayerParamsWith(oldLayer, newLayer) {
        // step 1: update style
        if (newLayer.options && newLayer.options.style !== oldLayer.getStyle()) {
            oldLayer.setStyle(newLayer.options.style);
        }
        // step 2: update source
        if (oldLayer.getSource().getUrl() !== newLayer.url) {
            oldLayer.getSource().setUrl(newLayer.url);
        }
    }
    /**
     * TODO: set all other props of GeoJsonLayer.options and GeoJsonLayer.cluster (see: IVectorLayerOptions)
     */
    updateGeojsonLayerParamsWith(oldLayer, newGeojsonLayer) {
        var _a;
        const oldSource = oldLayer.getSource();
        if (oldSource) {
            if (newGeojsonLayer.data) {
                const features = this.mapSvc.geoJsonToFeatures(newGeojsonLayer.data);
                if (oldSource instanceof olSourceCluster) {
                    const vectorSource = oldSource.getSource();
                    vectorSource.clear();
                    vectorSource.addFeatures(features);
                }
                else {
                    oldSource.clear();
                    oldSource.addFeatures(features);
                }
            }
            else if (newGeojsonLayer.url) {
                if (oldSource instanceof olSourceCluster) {
                    const vectorSource = oldSource.getSource();
                    vectorSource.setUrl(newGeojsonLayer.url);
                }
                else {
                    oldSource.setUrl(newGeojsonLayer.url);
                }
            }
            // 'distance' in also checks for 0 values
            if (typeof (newGeojsonLayer === null || newGeojsonLayer === void 0 ? void 0 : newGeojsonLayer.cluster) === 'object' && 'distance' in newGeojsonLayer.cluster && oldSource instanceof olSourceCluster) {
                oldSource.setDistance(newGeojsonLayer.cluster.distance);
            }
        }
        if ((_a = newGeojsonLayer === null || newGeojsonLayer === void 0 ? void 0 : newGeojsonLayer.options) === null || _a === void 0 ? void 0 : _a.style) {
            oldLayer.setStyle(newGeojsonLayer.options.style);
        }
    }
    updateWmsLayerParamsWith(oldLayer, newWmsLayer) {
        if (oldLayer instanceof olLayer) {
            const source = oldLayer.getSource();
            const oldParams = source.getParams();
            const newParams = newWmsLayer.params;
            if (!this.shallowEqual(oldParams, newParams)) {
                oldLayer.getSource().updateParams(newParams);
            }
        }
    }
    updateWmtsLayerParamsWith(oldLayer, newWmtsLayer) {
        // contrary to a wms-source, a wmts-source has neither 'getParams' nor 'updateParams', so we need to do this manually.
        if (oldLayer instanceof olLayer) {
            const source = oldLayer.getSource();
            const oldStyle = source.getStyle();
            const oldFormat = source.getFormat();
            const oldVersion = source.getVersion();
            const oldMatrix = source.getMatrixSet();
            const newStyle = newWmtsLayer.params.style;
            const newFormat = newWmtsLayer.params.format;
            const newVersion = newWmtsLayer.params.version;
            const newMatrix = newWmtsLayer.params.matrixSetOptions.matrixSet;
            if (newStyle !== undefined && oldStyle !== newStyle
                || newFormat !== undefined && oldFormat !== newFormat
                || newVersion !== undefined && oldVersion !== newVersion
                || newMatrix !== undefined && oldMatrix !== newMatrix) {
                // console.log(oldStyle, oldFormat, oldVersion, oldMatrix)
                // console.log(newStyle, newFormat, newVersion, newMatrix)
                const olFiltertype = newWmtsLayer.filtertype.toLowerCase();
                // this.mapSvc.setUkisLayer(newWmtsLayer, olFiltertype);
                this.mapSvc.updateUkisLayer(newWmtsLayer, olFiltertype);
            }
        }
    }
    shallowEqual(a, b) {
        // Create arrays of property names
        const aProps = Object.getOwnPropertyNames(a);
        const bProps = Object.getOwnPropertyNames(b);
        // If number of properties is different,
        // objects are not equivalent
        if (aProps.length !== bProps.length) {
            return false;
        }
        for (const propName of aProps) {
            // If values of same property are not equal,
            // objects are not equivalent
            if (a[propName] !== b[propName]) {
                return false;
            }
        }
        // If we made it this far, objects
        // are considered equivalent
        return true;
    }
    addUpdateBaseLayers(layers) {
        /** if length of layers has changed add new layers */
        if (layers.length !== this.mapSvc.getLayers('baselayers').length) {
            // set only one visible at start
            const visiblelayers = layers.filter(l => l.visible === true);
            if (visiblelayers.length === 0) {
                layers[0].visible = true;
            }
            else if (visiblelayers.length > 1) {
                layers.forEach(l => l.visible = false);
                layers[0].visible = true;
            }
            this.mapSvc.setUkisLayers(layers, 'baselayers');
        }
        else {
            /** if layers already on the map -length not changed- update them */
            for (const layer of layers) {
                const bllayer = this.mapSvc.getLayerByKey({ key: ID_KEY, value: layer.id }, 'baselayers');
                if (bllayer) {
                    if (bllayer.getVisible() !== layer.visible) {
                        bllayer.setVisible(layer.visible);
                    }
                    if (bllayer.getZIndex() !== layers.indexOf(layer)) {
                        bllayer.setZIndex(layers.indexOf(layer));
                    }
                    if (bllayer.getOpacity() !== layer.opacity) {
                        bllayer.setOpacity(layer.opacity);
                    }
                }
            }
        }
    }
    subscribeToLayers() {
        // ----------------------
        // add/remove layers
        if (this.layersSvc) {
            const baselayersAddRemoveOn = this.layersSvc.getBaseLayers().subscribe(layers => this.addUpdateBaseLayers(layers));
            this.subs.push(baselayersAddRemoveOn);
            const onLayers = this.layersSvc.getLayers().subscribe(layers => this.addUpdateLayers(layers, 'layers', ['baselayers']));
            this.subs.push(onLayers);
            const onOverlays = this.layersSvc.getOverlays().subscribe(layers => this.addUpdateLayers(layers, 'overlays', ['baselayers', 'layers']));
            this.subs.push(onOverlays);
        }
    }
    setMapState(mapState) {
        const lastAction = this.mapStateSvc.getLastAction().getValue();
        if (mapState.options.notifier === 'user') {
            if (lastAction === 'setExtent') {
                this.mapSvc.setExtent(mapState.extent, true);
            }
            else if (lastAction === 'setState') {
                this.mapSvc.setZoom(mapState.zoom, mapState.options.notifier);
                this.mapSvc.setCenter([mapState.center.lon, mapState.center.lat], true);
            }
        }
        /* else if (mapState.options.notifier === 'map') {
          console.log("--------Map triggered mapState change", mapState);
        } */
    }
    subscribeToMapState() {
        if (this.mapStateSvc) {
            /** .pipe(skip(1)) skips the first, e.g. initial value of the BehaviorSubject!! -- https://www.learnrxjs.io/learn-rxjs/operators/filtering/skip#why-use-skip  */
            const mapStateOn = this.mapStateSvc.getMapState().pipe(skip(1)).subscribe(state => this.setMapState(state));
            this.subs.push(mapStateOn);
        }
    }
    subscribeToMapEvents() {
        this.mapOnMoveend = (evt) => {
            // const zoom = Math.round(this.mapSvc.getZoom());
            const zoom = this.mapSvc.getZoom();
            const center = this.mapSvc.getCenter(true);
            const extent = this.mapSvc.getCurrentExtent(true);
            // const newCenter = { lat: parseFloat(center[1].toFixed(6)), lon: parseFloat(center[0].toFixed(6)) };
            const newCenter = { lat: parseFloat(center[1]), lon: parseFloat(center[0]) };
            const ms = new MapState(zoom, newCenter, { notifier: 'map' }, extent);
            this.mapStateSvc.setMapState(ms);
        };
        this.map.on('moveend', this.mapOnMoveend);
        /** handle click and pointermove/mousemove */
        this.mapOnClickMove = (evt) => {
            this.mapSvc.layersOnMapEvent(evt);
        };
        this.map.on(['click', 'pointermove'], this.mapOnClickMove);
        /** handle double click */
        this.mapOnDclick = (evt) => {
            this.mapSvc.removeAllPopups();
        };
        this.map.on('dblclick', this.mapOnDclick);
    }
    initMap() {
        const olMapView = this.mapSvc.createMap();
        this.map = olMapView.map; //
        this.setControls();
        if (!this.layersSvc) {
            console.log('there is no layersSvc as defined!');
        }
        if (!this.mapStateSvc) {
            console.log('there is no mapStateSvc as defined!');
        }
    }
    setControls() {
        // add Control only if this functions is defined
        const tempControls = [];
        const oldControls = [];
        if (this.map) {
            const controlsArry = this.map.getControls().getArray();
            controlsArry.forEach(i => oldControls.push(i));
            /** fix: The Attribution Control is displayed twice #3 */
            this.map.getControls().clear();
        }
        if (this.controls && this.map) {
            if (this.controls.attribution !== false) {
                let attributionOptions = {
                    collapsible: true,
                    collapsed: false
                };
                if (typeof this.controls.attribution === 'object') {
                    attributionOptions = Object.assign(attributionOptions, this.controls.attribution);
                }
                const attribution = new Attribution(attributionOptions);
                tempControls.push(attribution);
            }
            if (this.controls.scaleLine) {
                let scaleLineOptions = {};
                if (typeof this.controls.scaleLine === 'object') {
                    scaleLineOptions = Object.assign(scaleLineOptions, this.controls.scaleLine);
                }
                const scaleLineControl = new ScaleLine(scaleLineOptions);
                tempControls.push(scaleLineControl);
            }
            if (this.controls.zoom !== false) {
                let zoomOptions = {};
                if (typeof this.controls.zoom === 'object') {
                    zoomOptions = Object.assign(zoomOptions, this.controls.zoom);
                }
                const zoomControl = new Zoom(zoomOptions);
                tempControls.push(zoomControl);
            }
            if (this.controls.mousePosition) {
                let mousePositionOptions = {
                    coordinateFormat: coordinate => {
                        return toStringXY(coordinate, 2);
                    },
                    projection: 'EPSG:4326'
                };
                if (typeof this.controls.mousePosition === 'object') {
                    mousePositionOptions = Object.assign(mousePositionOptions, this.controls.mousePosition);
                }
                const mousePosition = new olMousePosition(mousePositionOptions);
                tempControls.push(mousePosition);
            }
            if (this.controls.fullScreen) {
                let fullScreenOptions = {};
                if (typeof this.controls.fullScreen === 'object') {
                    fullScreenOptions = Object.assign(fullScreenOptions, this.controls.fullScreen);
                }
                const fullScreen = new olFullScreen(fullScreenOptions);
                tempControls.push(fullScreen);
            }
            if (this.controls.overviewMap) {
                const icon = document.createElement('spawn');
                icon.innerHTML = '<clr-icon shape="world"></clr-icon>';
                let overviewMapOptions = {
                    layers: [new olTileLayer({
                            source: new olOSM()
                        })],
                    label: icon
                };
                if (typeof this.controls.overviewMap === 'object') {
                    overviewMapOptions = Object.assign(overviewMapOptions, this.controls.overviewMap);
                }
                const overviewMap = new olOverviewMap(overviewMapOptions);
                tempControls.push(overviewMap);
            }
            if (this.controls.rotate) {
                let rotateOptions = {};
                if (typeof this.controls.rotate === 'object') {
                    rotateOptions = Object.assign(rotateOptions, this.controls.rotate);
                }
                const rotate = new olRotate(rotateOptions);
                tempControls.push(rotate);
            }
            if (tempControls.length) {
                /**
                 * check tempControls dose not include oldControls
                 * https://medium.com/@alvaro.saburido/set-theory-for-arrays-in-es6-eb2f20a61848#f22b
                 */
                const difference = oldControls.filter(x => !tempControls.includes(x));
                difference.forEach(i => tempControls.push(i));
                this.map.getControls().extend(tempControls);
            }
        }
    }
}
MapOlComponent.fac = i0.ngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: MapOlComponent, deps: [{ token: MapOlService }, { token: i0.NgZone }], target: i0.FactoryTarget.Component });
MapOlComponent.cmp = i0.ngDeclareComponent({ minVersion: "12.0.0", version: "13.3.6", type: MapOlComponent, selector: "ukis-map-ol", inputs: { layersSvc: "layersSvc", mapStateSvc: ["mapState", "mapStateSvc"], controls: "controls" }, viewQueries: [{ propertyName: "mapDivView", first: true, predicate: ["mapDiv"], descendants: true }], ngImport: i0, template: "<div #mapDiv id=\"map\" ref=\"map\" class=\"map\">\n  <div *ngIf=\"controls && controls.crosshair\" id=\"crosshair\" class=\"crosshair\">+</div>\n</div>\n", styles: ["@charset \"UTF-8\";.ol-box{box-sizing:border-box;border-radius:2px;border:1.5px solid rgb(179,197,219);background-color:#fff6}.ol-mouse-position{top:8px;right:8px;position:absolute}.ol-scale-line{background:rgba(0,60,136,.3);border-radius:4px;bottom:8px;left:8px;padding:2px;position:absolute}.ol-scale-line-inner{border:1px solid #eee;border-top:none;color:#eee;font-size:10px;text-align:center;margin:1px;will-change:contents,width;transition:all .25s}.ol-scale-bar{position:absolute;bottom:8px;left:8px}.ol-scale-step-marker{width:1px;height:15px;background-color:#000;float:right;z-index:10}.ol-scale-step-text{position:absolute;bottom:-5px;font-size:12px;z-index:11;color:#000;text-shadow:-2px 0 #FFFFFF,0 2px #FFFFFF,2px 0 #FFFFFF,0 -2px #FFFFFF}.ol-scale-text{position:absolute;font-size:14px;text-align:center;bottom:25px;color:#000;text-shadow:-2px 0 #FFFFFF,0 2px #FFFFFF,2px 0 #FFFFFF,0 -2px #FFFFFF}.ol-scale-singlebar{position:relative;height:10px;z-index:9;box-sizing:border-box;border:1px solid black}.ol-unsupported{display:none}.ol-viewport,.ol-unselectable{-webkit-touch-callout:none;-webkit-user-select:none;user-select:none;-webkit-tap-highlight-color:rgba(0,0,0,0)}.ol-viewport canvas{all:unset}.ol-selectable{-webkit-touch-callout:default;-webkit-user-select:text;user-select:text}.ol-grabbing{cursor:grabbing}.ol-grab{cursor:move;cursor:grab}.ol-control{position:absolute;background-color:#fff6;border-radius:4px;padding:2px}.ol-control:hover{background-color:#fff9}.ol-zoom{top:.5em;left:.5em}.ol-rotate{top:.5em;right:.5em;transition:opacity .25s linear,visibility 0s linear}.ol-rotate.ol-hidden{opacity:0;visibility:hidden;transition:opacity .25s linear,visibility 0s linear .25s}.ol-zoom-extent{top:4.643em;left:.5em}.ol-full-screen{right:.5em;top:.5em}.ol-control button{display:block;margin:1px;padding:0;color:#fff;font-weight:700;text-decoration:none;font-size:inherit;text-align:center;height:1.375em;width:1.375em;line-height:.4em;background-color:#003c8880;border:none;border-radius:2px}.ol-control button::-moz-focus-inner{border:none;padding:0}.ol-zoom-extent button{line-height:1.4em}.ol-compass{display:block;font-weight:400;font-size:1.2em;will-change:transform}.ol-touch .ol-control button{font-size:1.5em}.ol-touch .ol-zoom-extent{top:5.5em}.ol-control button:hover,.ol-control button:focus{text-decoration:none;background-color:#003c88b3}.ol-zoom .ol-zoom-in{border-radius:2px 2px 0 0}.ol-zoom .ol-zoom-out{border-radius:0 0 2px 2px}.ol-attribution{text-align:right;bottom:.5em;right:.5em;max-width:calc(100% - 1.3em);display:flex;flex-flow:row-reverse;align-items:center}.ol-attribution a{color:#003c88b3;text-decoration:none}.ol-attribution ul{margin:0;padding:1px .5em;color:#000;text-shadow:0 0 2px #fff;font-size:12px}.ol-attribution li{display:inline;list-style:none}.ol-attribution li:not(:last-child):after{content:\" \"}.ol-attribution img{max-height:2em;max-width:inherit;vertical-align:middle}.ol-attribution button{flex-shrink:0}.ol-attribution.ol-collapsed ul{display:none}.ol-attribution:not(.ol-collapsed){background:rgba(255,255,255,.8)}.ol-attribution.ol-uncollapsible{bottom:0;right:0;border-radius:4px 0 0}.ol-attribution.ol-uncollapsible img{margin-top:-.2em;max-height:1.6em}.ol-attribution.ol-uncollapsible button{display:none}.ol-zoomslider{top:4.5em;left:.5em;height:200px}.ol-zoomslider button{position:relative;height:10px}.ol-touch .ol-zoomslider{top:5.5em}.ol-overviewmap{left:.5em;bottom:.5em}.ol-overviewmap.ol-uncollapsible{bottom:0;left:0;border-radius:0 4px 0 0}.ol-overviewmap .ol-overviewmap-map,.ol-overviewmap button{display:block}.ol-overviewmap .ol-overviewmap-map{border:1px solid #7b98bc;height:150px;margin:2px;width:150px}.ol-overviewmap:not(.ol-collapsed) button{bottom:2px;left:2px;position:absolute}.ol-overviewmap.ol-collapsed .ol-overviewmap-map,.ol-overviewmap.ol-uncollapsible button{display:none}.ol-overviewmap:not(.ol-collapsed){background:rgba(255,255,255,.8)}.ol-overviewmap-box{border:2px dotted rgba(0,60,136,.7)}.ol-overviewmap .ol-overviewmap-box:hover{cursor:move}:root{--ukis-crosshair-color: #ff0004;--ukis-popup-bg-color: rgb(238, 238, 238);--ukis-drop-shadow: drop-shadow(0 1px 4px rgba(0, 0, 0, .2));--ukis-ol-bbox-bg-color: rgba(255, 255, 255, .4);--ukis-ol-bbox-border-color: rgba(87, 87, 87, .4);--ukis-ol-overviewmap-left: .5em;--ukis-ol-overviewmap-bottom: 3em;--ukis-ol-control-bg-color: rgba(87, 87, 87, .6);--ukis-ol-control-border-color: rgba(87, 87, 87, .4)}.map{width:100%;height:100%;position:relative}.ol-popup{position:absolute;background-color:var(--ukis-popup-bg-color);filter:var(--ukis-drop-shadow);padding:15px;border-radius:2px;bottom:12px;left:-50px;min-width:280px;display:none;z-index:1000000}.ol-popup .ol-popup-closer{text-decoration:none;position:absolute;top:0px;right:8px;cursor:pointer}.ol-popup .ol-popup-closer:after{content:\"\\2716\"}.ol-popup:after,.ol-popup:before{top:100%;border:solid transparent;content:\" \";height:0;width:0;position:absolute;pointer-events:none}.ol-popup:after{border-top-color:var(--ukis-popup-bg-color);border-width:10px;left:48px;margin-left:-10px}.ol-popup:before{border-width:11px;left:48px;margin-left:-11px}.crosshair{top:50%;left:50%;font-size:large;color:var(--ukis-crosshair-color);z-index:1;position:absolute;cursor:default}.ol-control button{cursor:pointer;background-color:var(--ukis-ol-control-bg-color)}.ol-control button:focus{background-color:var(--ukis-ol-control-bg-color)}.ol-control button:hover{background-color:var(--ukis-ol-control-border-color)}.ol-scale-line{background:rgba(255,255,255,.4);line-height:1.375em}.ol-scale-line .ol-scale-line-inner{background:var(--ukis-ol-control-bg-color);border-color:var(--ukis-ol-control-bg-color)}.ol-attribution ul{font-size:.5rem}.ol-box{background-color:var(--ukis-ol-bbox-bg-color);border-color:var(--ukis-ol-bbox-border-color)!important}.ol-box.ol-drag-select{border-color:var(--clr-color-action-600, var(--fallback-color-no-clr))!important}.ol-overviewmap{left:var(--ukis-ol-overviewmap-left)!important;bottom:var(--ukis-ol-overviewmap-bottom)!important}\n"], directives: [{ type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], encapsulation: i0.ViewEncapsulation.None });
i0.ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: MapOlComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ukis-map-ol', encapsulation: ViewEncapsulation.None, template: "<div #mapDiv id=\"map\" ref=\"map\" class=\"map\">\n  <div *ngIf=\"controls && controls.crosshair\" id=\"crosshair\" class=\"crosshair\">+</div>\n</div>\n", styles: ["@charset \"UTF-8\";.ol-box{box-sizing:border-box;border-radius:2px;border:1.5px solid rgb(179,197,219);background-color:#fff6}.ol-mouse-position{top:8px;right:8px;position:absolute}.ol-scale-line{background:rgba(0,60,136,.3);border-radius:4px;bottom:8px;left:8px;padding:2px;position:absolute}.ol-scale-line-inner{border:1px solid #eee;border-top:none;color:#eee;font-size:10px;text-align:center;margin:1px;will-change:contents,width;transition:all .25s}.ol-scale-bar{position:absolute;bottom:8px;left:8px}.ol-scale-step-marker{width:1px;height:15px;background-color:#000;float:right;z-index:10}.ol-scale-step-text{position:absolute;bottom:-5px;font-size:12px;z-index:11;color:#000;text-shadow:-2px 0 #FFFFFF,0 2px #FFFFFF,2px 0 #FFFFFF,0 -2px #FFFFFF}.ol-scale-text{position:absolute;font-size:14px;text-align:center;bottom:25px;color:#000;text-shadow:-2px 0 #FFFFFF,0 2px #FFFFFF,2px 0 #FFFFFF,0 -2px #FFFFFF}.ol-scale-singlebar{position:relative;height:10px;z-index:9;box-sizing:border-box;border:1px solid black}.ol-unsupported{display:none}.ol-viewport,.ol-unselectable{-webkit-touch-callout:none;-webkit-user-select:none;user-select:none;-webkit-tap-highlight-color:rgba(0,0,0,0)}.ol-viewport canvas{all:unset}.ol-selectable{-webkit-touch-callout:default;-webkit-user-select:text;user-select:text}.ol-grabbing{cursor:grabbing}.ol-grab{cursor:move;cursor:grab}.ol-control{position:absolute;background-color:#fff6;border-radius:4px;padding:2px}.ol-control:hover{background-color:#fff9}.ol-zoom{top:.5em;left:.5em}.ol-rotate{top:.5em;right:.5em;transition:opacity .25s linear,visibility 0s linear}.ol-rotate.ol-hidden{opacity:0;visibility:hidden;transition:opacity .25s linear,visibility 0s linear .25s}.ol-zoom-extent{top:4.643em;left:.5em}.ol-full-screen{right:.5em;top:.5em}.ol-control button{display:block;margin:1px;padding:0;color:#fff;font-weight:700;text-decoration:none;font-size:inherit;text-align:center;height:1.375em;width:1.375em;line-height:.4em;background-color:#003c8880;border:none;border-radius:2px}.ol-control button::-moz-focus-inner{border:none;padding:0}.ol-zoom-extent button{line-height:1.4em}.ol-compass{display:block;font-weight:400;font-size:1.2em;will-change:transform}.ol-touch .ol-control button{font-size:1.5em}.ol-touch .ol-zoom-extent{top:5.5em}.ol-control button:hover,.ol-control button:focus{text-decoration:none;background-color:#003c88b3}.ol-zoom .ol-zoom-in{border-radius:2px 2px 0 0}.ol-zoom .ol-zoom-out{border-radius:0 0 2px 2px}.ol-attribution{text-align:right;bottom:.5em;right:.5em;max-width:calc(100% - 1.3em);display:flex;flex-flow:row-reverse;align-items:center}.ol-attribution a{color:#003c88b3;text-decoration:none}.ol-attribution ul{margin:0;padding:1px .5em;color:#000;text-shadow:0 0 2px #fff;font-size:12px}.ol-attribution li{display:inline;list-style:none}.ol-attribution li:not(:last-child):after{content:\" \"}.ol-attribution img{max-height:2em;max-width:inherit;vertical-align:middle}.ol-attribution button{flex-shrink:0}.ol-attribution.ol-collapsed ul{display:none}.ol-attribution:not(.ol-collapsed){background:rgba(255,255,255,.8)}.ol-attribution.ol-uncollapsible{bottom:0;right:0;border-radius:4px 0 0}.ol-attribution.ol-uncollapsible img{margin-top:-.2em;max-height:1.6em}.ol-attribution.ol-uncollapsible button{display:none}.ol-zoomslider{top:4.5em;left:.5em;height:200px}.ol-zoomslider button{position:relative;height:10px}.ol-touch .ol-zoomslider{top:5.5em}.ol-overviewmap{left:.5em;bottom:.5em}.ol-overviewmap.ol-uncollapsible{bottom:0;left:0;border-radius:0 4px 0 0}.ol-overviewmap .ol-overviewmap-map,.ol-overviewmap button{display:block}.ol-overviewmap .ol-overviewmap-map{border:1px solid #7b98bc;height:150px;margin:2px;width:150px}.ol-overviewmap:not(.ol-collapsed) button{bottom:2px;left:2px;position:absolute}.ol-overviewmap.ol-collapsed .ol-overviewmap-map,.ol-overviewmap.ol-uncollapsible button{display:none}.ol-overviewmap:not(.ol-collapsed){background:rgba(255,255,255,.8)}.ol-overviewmap-box{border:2px dotted rgba(0,60,136,.7)}.ol-overviewmap .ol-overviewmap-box:hover{cursor:move}:root{--ukis-crosshair-color: #ff0004;--ukis-popup-bg-color: rgb(238, 238, 238);--ukis-drop-shadow: drop-shadow(0 1px 4px rgba(0, 0, 0, .2));--ukis-ol-bbox-bg-color: rgba(255, 255, 255, .4);--ukis-ol-bbox-border-color: rgba(87, 87, 87, .4);--ukis-ol-overviewmap-left: .5em;--ukis-ol-overviewmap-bottom: 3em;--ukis-ol-control-bg-color: rgba(87, 87, 87, .6);--ukis-ol-control-border-color: rgba(87, 87, 87, .4)}.map{width:100%;height:100%;position:relative}.ol-popup{position:absolute;background-color:var(--ukis-popup-bg-color);filter:var(--ukis-drop-shadow);padding:15px;border-radius:2px;bottom:12px;left:-50px;min-width:280px;display:none;z-index:1000000}.ol-popup .ol-popup-closer{text-decoration:none;position:absolute;top:0px;right:8px;cursor:pointer}.ol-popup .ol-popup-closer:after{content:\"\\2716\"}.ol-popup:after,.ol-popup:before{top:100%;border:solid transparent;content:\" \";height:0;width:0;position:absolute;pointer-events:none}.ol-popup:after{border-top-color:var(--ukis-popup-bg-color);border-width:10px;left:48px;margin-left:-10px}.ol-popup:before{border-width:11px;left:48px;margin-left:-11px}.crosshair{top:50%;left:50%;font-size:large;color:var(--ukis-crosshair-color);z-index:1;position:absolute;cursor:default}.ol-control button{cursor:pointer;background-color:var(--ukis-ol-control-bg-color)}.ol-control button:focus{background-color:var(--ukis-ol-control-bg-color)}.ol-control button:hover{background-color:var(--ukis-ol-control-border-color)}.ol-scale-line{background:rgba(255,255,255,.4);line-height:1.375em}.ol-scale-line .ol-scale-line-inner{background:var(--ukis-ol-control-bg-color);border-color:var(--ukis-ol-control-bg-color)}.ol-attribution ul{font-size:.5rem}.ol-box{background-color:var(--ukis-ol-bbox-bg-color);border-color:var(--ukis-ol-bbox-border-color)!important}.ol-box.ol-drag-select{border-color:var(--clr-color-action-600, var(--fallback-color-no-clr))!important}.ol-overviewmap{left:var(--ukis-ol-overviewmap-left)!important;bottom:var(--ukis-ol-overviewmap-bottom)!important}\n"] }]
        }], ctorParameters: function () { return [{ type: MapOlService }, { type: i0.NgZone }]; }, propDecorators: { mapDivView: [{
                type: ViewChild,
                args: ['mapDiv']
            }], layersSvc: [{
                type: Input,
                args: ['layersSvc']
            }], mapStateSvc: [{
                type: Input,
                args: ['mapState']
            }], controls: [{
                type: Input,
                args: ['controls']
            }] } });

class MapOlModule {
}
MapOlModule.fac = i0.ngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: MapOlModule, deps: [], target: i0.FactoryTarget.NgModule });
MapOlModule.mod = i0.ngDeclareNgModule({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: MapOlModule, declarations: [MapOlComponent], imports: [CommonModule], exports: [MapOlComponent] });
MapOlModule.inj = i0.ngDeclareInjector({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: MapOlModule, providers: [MapOlService], imports: [[
            CommonModule
        ]] });
i0.ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: MapOlModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [MapOlComponent],
                    imports: [
                        CommonModule
                    ],
                    exports: [MapOlComponent],
                    providers: [MapOlService]
                }]
        }] });

/*
 * Public API Surface of map-ol
 */

/**
 * Generated bundle index. Do not edit.
 */

export { MapOlComponent, MapOlModule, MapOlService };
//# sourceMappingURL=dlr-eoc-map-ol.mjs.map
