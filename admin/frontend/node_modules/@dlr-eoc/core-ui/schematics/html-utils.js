"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateHtmlFile = void 0;
const RewritingStream = require('parse5-html-rewriting-stream');
const schematics_1 = require("@angular-devkit/schematics");
const stream_1 = require("stream");
/**
 * Update a HTML File with 'parse5-html-rewriting-stream'
 * https://github.com/angular/angular-cli/blob/aedfcc1862afc599ea18c578248d0aa373a947bb/packages/angular_devkit/build_angular/src/utils/index-file/html-rewriting-stream.ts#L11
 */
function updateHtmlFile(path, startTagStr, endTagStr, items) {
    return (tree, context) => {
        const buffer = tree.read(path);
        if (buffer === null) {
            throw new schematics_1.SchematicsException(`Could not read index file: ${path}`);
        }
        const rewriter = new RewritingStream();
        const startTags = [];
        rewriter.on('startTag', (startTag) => {
            startTags.push(startTag);
            rewriter.emitStartTag(startTag);
        });
        const endTags = [];
        rewriter.on('endTag', (endTag) => {
            endTags.push(endTag);
            if (endTag.tagName === endTagStr) {
                if (Array.isArray(items)) {
                    for (const item of items) {
                        rewriter.emitRaw(item);
                    }
                }
                else {
                    rewriter.emitRaw(items);
                }
            }
            rewriter.emitEndTag(endTag);
        });
        // context.logger.info(`INFO: update of some Tags in ${path}`);
        return new Promise(resolve => {
            const input = new stream_1.Readable({
                encoding: 'utf8',
                read() {
                    this.push(buffer);
                    this.push(null);
                },
            });
            const chunks = [];
            const output = new stream_1.Writable({
                write(chunk, encoding, callback) {
                    // https://github.com/microsoft/TypeScript/issues/23155
                    if (typeof chunk === 'string') {
                        chunks.push(Buffer.from(chunk, encoding));
                    }
                    else {
                        chunks.push(chunk);
                    }
                    callback();
                },
                final(callback) {
                    const full = Buffer.concat(chunks);
                    const hasStartTag = startTags.find(i => i.tagName === startTagStr);
                    if (!hasStartTag) {
                        context.logger.warn(`startTag: ${startTagStr} is not in the file ${path}`);
                    }
                    const hasEndTag = endTags.find(i => i.tagName === endTagStr);
                    if (!hasEndTag) {
                        context.logger.warn(`endTag: ${endTagStr} is not in the file ${path}`);
                    }
                    tree.overwrite(path, full.toString());
                    callback();
                    resolve();
                },
            });
            input.pipe(rewriter).pipe(output);
        });
    };
}
exports.updateHtmlFile = updateHtmlFile;
//# sourceMappingURL=html-utils.js.map