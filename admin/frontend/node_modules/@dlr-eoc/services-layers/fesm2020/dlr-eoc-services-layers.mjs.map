{"version":3,"file":"dlr-eoc-services-layers.mjs","sources":["../../../projects/services-layers/src/lib/types/Layers.ts","../../../projects/services-layers/src/lib/types/LayerGroup.ts","../../../projects/services-layers/src/lib/types/RasterLayers.ts","../../../projects/services-layers/src/lib/layers.service.ts","../../../projects/services-layers/src/lib/layers.module.ts","../../../projects/services-layers/src/public-api.ts","../../../projects/services-layers/src/dlr-eoc-services-layers.ts"],"sourcesContent":["import { Type } from '@angular/core';\n\nexport interface IAnyObject {\n  [k: string]: any;\n}\n\ninterface IDynamicComponent {\n  component: Type<any>;\n  inputs?: { [input: string]: any };\n  outputs?: { [inputChange: string]: (value) => void };\n}\n\nexport interface ILayerContent extends IAnyObject {\n  /** MIME type of the Content */\n  type: string;\n  href?: string;\n  title?: string;\n  /** String type, not empty that can contain any text encoded media type */\n  content?: string;\n}\n\nexport interface ILayerStyleSet extends IAnyObject {\n  name: string;\n  title: string;\n  abstract?: string;\n  default?: boolean;\n  legendURL?: string;\n  content?: ILayerContent;\n}\n\nexport interface popup {\n  /** limit layer or feature properties: only those properties of a layer/feature, that are listed in this array, are being passed through to a popup-render-function */\n  filterkeys?: Array<string>;\n  /** To overwrite the keys (and only the keys) of the layer/feature properties. Object has the form {\"oldKey\": \"newKey\"} */\n  properties?: IAnyObject;\n  /** function to create html string - popupobj: nativeLayer */\n  popupFunction?: (popupobj: IAnyObject) => string;\n  /** async function where you can paste a html string to the callback - popupobj: nativeLayer */\n  asyncPopup?: (popupobj: any, cb: (html: any) => void) => void;\n  /** create popup using angular component */\n  dynamicPopup?: {\n    component: Type<any>;\n    getAttributes?: (args: any) => object;\n  };\n  /** default event is click - use move for a popup on hover */\n  event?: 'move' | 'click';\n  /** default is false - removes the other popups if the next is added */\n  single?: boolean;\n  /** options which get assigned on the popup creations e.g. ol/Overlay */\n  options?: IAnyObject;\n  /** If the layer should be filtered out and the popup beneath should be shown e.g. text overlays */\n  filterLayer?: boolean;\n}\n\n\n/**\n * Layer events like rendering or Source events like data load, change, error...\n */\nexport interface ILayerEvent {\n  event: string;\n  listener: (args?: any) => void;\n}\n\n/** can be raster and vector */\nexport const TmsLayertype = 'tms';\nexport const WmsLayertype = 'wms';\nexport const WmtsLayertype = 'wmts';\nexport const XyzLayertype = 'xyz';\nexport const GeojsonLayertype = 'geojson';\nexport const KmlLayertype = 'kml';\nexport const WfsLayertype = 'wfs';\n/** can be raster and vector */\nexport const CustomLayertype = 'custom';\n/** can have multiple layers raster, vector... */\nexport const StackedLayertype = 'stacked';\nexport type TVectorLayertype = typeof GeojsonLayertype | typeof WfsLayertype | typeof TmsLayertype | typeof KmlLayertype | typeof CustomLayertype;\nexport type TRasterLayertype = typeof WmsLayertype | typeof WmtsLayertype | typeof XyzLayertype | typeof TmsLayertype | typeof CustomLayertype;\nexport type TLayertype = TRasterLayertype | TVectorLayertype | string;\n\nexport const Filtertypes = {\n  Baselayers: 'Baselayers',\n  Overlays: 'Overlays',\n  Layers: 'Layers'\n} as const;\nexport type TFiltertypes = keyof typeof Filtertypes;\n\n\n/**\n * @deprecated The method should not be used because it can be false positive\n *\n * CustomLayertype and TmsLayertype can be raster and vector.\n * You have to double check by yourself later!\n */\nexport function isVectorLayertype(inpt: string): inpt is TVectorLayertype {\n  return [GeojsonLayertype, WfsLayertype, CustomLayertype, KmlLayertype, TmsLayertype].includes(inpt);\n}\n\n\n/**\n * @deprecated The method should not be used because it can be false positive\n *\n * CustomLayertype and TmsLayertype can be raster and vector.\n * You have to double check by yourself later!\n */\nexport function isRasterLayertype(inpt: string): inpt is TRasterLayertype {\n  return [WmsLayertype, WmtsLayertype, XyzLayertype, CustomLayertype, TmsLayertype].includes(inpt);\n}\n\nexport function isLayertype(type: string): type is TLayertype {\n  return [TmsLayertype, WmsLayertype, WmtsLayertype, XyzLayertype, GeojsonLayertype, KmlLayertype, WfsLayertype, CustomLayertype].includes(type);\n}\n\n/**\n * geographic coordinates\n * like ol.extent: minX, minY, maxX, maxY\n */\nexport type TGeoExtent = [number, number, number, number] | [number, number, number, number, number, number];\n\n/*\n * There are effectively only two values that we may set for cors:\n * https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/crossorigin\n */\nexport type CrossOriginType = 'anonymous' | 'use-credentials';\n\n\nexport interface ILayerOptions {\n  name: string;\n  id: string;\n  // id: string\n  type: TLayertype;\n\n  filtertype?: TFiltertypes;\n  opacity?: number;\n  visible?: boolean;\n  removable?: boolean;\n  continuousWorld?: boolean;\n  attribution?: string;\n  displayName?: string;\n  description?: string;\n  time?: string;\n  minResolution?: number;\n  maxResolution?: number;\n  minZoom?: number;\n  maxZoom?: number;\n  /** legend for the layer as image or a angular component */\n  legendImg?: string | IDynamicComponent;\n  /** geographic coordinates */\n  bbox?: TGeoExtent;\n  dimensions?: ILayerDimensions;\n  /** true: show popup on click | array: show popup on click and limit properties | or use a popup object to configure the popup\n   * if a popup should be shown on multiple events use an array of popup object (only unique events)\n   */\n  // https://stackoverflow.com/questions/57016728/is-there-a-way-to-define-type-for-array-with-unique-items-in-typescript\n  popup?: boolean | Array<string> | popup | popup[];\n  events?: {\n    /** e.g. https://openlayers.org/en/v6.5.0/apidoc/module-ol_layer_Layer-Layer.html Fires */\n    layer?: ILayerEvent[];\n    /** e.g. https://openlayers.org/en/v6.5.0/apidoc/module-ol_source_Source.html Tile | Image | Raster | Vector */\n    source?: ILayerEvent[];\n  };\n  actions?: [{ title: string, icon: string, action: (Layer) => void }];\n  /** optional angular component that can be used e.g. to change the layer style, filter the data or request new data */\n  action?: IDynamicComponent;\n  /** a layer might have more than one style; eg. true color and false color for the same dataset */\n  styles?: ILayerStyleSet[];\n  /** The crossOrigin attribute for loaded images if you want to access pixel data with the Canvas renderer */\n  crossOrigin?: CrossOriginType;\n  /** UI is expanded */\n  expanded?: boolean;\n  /**\n   * CSS Class for custom styling\n   *\n   * If class 'hide' is included in the string, the layer is not shown in the UI - this can probably bring side effects when Layers are reordered, because the hidden layers could be moved on top off all!\n   */\n  cssClass?: string;\n}\n\nexport interface ILayerDimensions extends IAnyObject {\n  time?: ILayerTimeDimension;\n  elevation?: ILayerElevationDimension;\n}\n\nexport interface ILayerIntervalAndPeriod {\n  /**\n   * Example: \"2016-01-01T00:00:00.000Z/2018-01-01T00:00:00.000Z\"\n   */\n  interval: string;\n  /**\n   * Example: \"P1Y\"\n   */\n  periodicity: string;\n}\n\nexport interface ILayerTimeDimension {\n  values: string[] | ILayerIntervalAndPeriod[] | ILayerIntervalAndPeriod;\n  units: string;\n  display?: {\n    format?: string;\n    period?: string;\n    default?: string;\n  };\n}\n\nexport interface ILayerElevationDimension {\n  /** Default steps to display in elevation slider */\n  units: string;\n  values: string;\n  display?: {\n    format?: string;\n    step?: string;\n    default?: string;\n  };\n}\n\n\nexport interface IRasterLayerOptions extends ILayerOptions {\n  url: string;\n  subdomains?: Array<string>;\n  /** raster params like wms params -> time, layers... depends on the map-library */\n  params?: IRasterLayerParams;\n  /** check if the service supports this tilesize */\n  tileSize?: number;\n  type: TRasterLayertype;\n}\n\nexport interface IVectorLayerOptions extends ILayerOptions {\n  /** data: geojson data */\n  data?: any;\n  url?: string;\n  subdomains?: Array<string>;\n  /** vector options like style, pointToLayer... depends on the map-library */\n  options?: {\n    /** ol/style/Style */\n    style: any;\n    /** styleSource=OpenMapStyle.sourceKey if style is a OpenMapStyle Obj */\n    styleSource?: string;\n    [k: string]: any;\n  };\n  /** if true clusters points | or set a Object with cluster options e.g. distance ... depends on the map-library */\n  cluster?: boolean | IAnyObject;\n  type: TVectorLayertype;\n}\n\n/**\n * The `crossOrigin` property can overwrite the one set in the layersource of the custom_layer if there is such a property e.g. when using OpenLayers as a map-engine\n * It also can be used to disable get color values for a OpenLayers layer in the layer popup when set to crossOrigin: null\n */\nexport interface ICustomLayerOptions<T = any> extends Omit<ILayerOptions, 'type'> {\n  type?: TLayertype;\n  custom_layer: T;\n}\n\n/**\n * Layers is an array of layers which get stacked together and shown as one layer\n */\nexport interface IStackedLayerOptions extends Omit<ILayerOptions, 'type'> {\n  type?: TLayertype;\n  layers: Layer[];\n}\n\n\n/**\n * Classes for layer construction\n */\nexport class Layer implements ILayerOptions {\n  name = '';\n  id = '';\n  type: TLayertype;\n  opacity = 1;\n  visible = true;\n  removable = false;\n\n  filtertype?: TFiltertypes = 'Layers';\n  continuousWorld = false;\n  attribution?: string;\n  displayName?: string;\n  description?: string;\n  protected protTime?: string;\n  minResolution?: number;\n  maxResolution?: number;\n  minZoom?: number;\n  maxZoom?: number;\n  legendImg?: string | IDynamicComponent;\n\n  bbox?: TGeoExtent;\n  dimensions?: ILayerDimensions;\n\n  popup?: ILayerOptions['popup'];\n  events?: ILayerOptions['events'];\n  actions?: [{ title: string, icon: string, action: (Layer) => void }];\n\n  action?: IDynamicComponent;\n\n  styles?: ILayerStyleSet[];\n  crossOrigin?: CrossOriginType;\n  expanded = false;\n  cssClass?: string;\n\n  constructor(options: ILayerOptions) {\n    Object.assign(this, options);\n  }\n\n  get time() {\n    return this.protTime;\n  }\n  set time(time: string) {\n    this.protTime = time;\n  }\n}\n/** raster params like wms params -> time, layers... depends on the map-library */\nexport interface IRasterLayerParams extends IAnyObject {\n  LAYERS?: string;\n  FORMAT?: string;\n  TIME?: string;\n  VERSION?: string;\n  TILED?: string;\n  TRANSPARENT?: boolean;\n  STYLES?: string;\n  /** https://docs.geoserver.org/latest/en/user/tutorials/cql/cql_tutorial.html#cql-tutorial */\n  CQL_FILTER?: string;\n  /** https://docs.geoserver.org/latest/en/user/styling/sld/reference/filters.html */\n  FILTER?: string;\n}\n\nexport class RasterLayer extends Layer implements IRasterLayerOptions {\n  type: TRasterLayertype;\n  url: string;\n  subdomains?: Array<string>;\n  params?: IRasterLayerParams;\n  /** check if the service supports this tilesize */\n  tileSize?: number;\n\n  constructor(options: IRasterLayerOptions) {\n    super(options);\n\n    // if styles are given, set params and legendImg accordingly.\n    if (this.styles && this.styles.length > 0) {\n      let defaultStyle = this.styles.find(s => s.default);\n\n      if (!defaultStyle) {\n        defaultStyle = this.styles[0];\n      }\n\n      this.legendImg = defaultStyle.legendURL;\n      if (this.params) {\n        if (this.type === WmsLayertype) {\n          this.params.STYLES = defaultStyle.name;\n        } else if (this.type === WmtsLayertype) {\n          this.params.style = defaultStyle.name;\n        }\n        this.params.STYLES = defaultStyle.name;\n      } else if (this.type === WmtsLayertype) {\n        if (!this.params) {\n          this.params = {};\n        }\n        this.params.style = defaultStyle.name;\n      }\n    }\n  }\n\n  set time(time: string) {\n    if (this.params) {\n      this.params.TIME = time;\n    }\n    this.protTime = time;\n  }\n\n  get time() {\n    return this.protTime;\n  }\n}\n\n/**\n * @deprecated The method should not be used because it can be false positive\n */\nexport const isRasterLayer = (layer: Layer): layer is RasterLayer => {\n  return isRasterLayertype(layer.type);\n};\n\n\nexport class VectorLayer extends Layer implements IVectorLayerOptions {\n  type: TVectorLayertype;\n  /** data: geojson data */\n  data?: any;\n  url?: string;\n  subdomains?: Array<string>;\n  /** vector options like style, pointToLayer... depend on the map-library, e.g.:\n   * iconUrl: string - to specify icon for points\n   * rotationPropName: string - property containing rotation angle in degrees\n   */\n  options?: IVectorLayerOptions['options'];\n  cluster?: IVectorLayerOptions['cluster'];\n  constructor(options: IVectorLayerOptions) {\n    super(options);\n  }\n}\n\n/**\n * @deprecated The method should not be used because it can be false positive\n */\nexport const isVectorLayer = (layer: Layer): layer is VectorLayer => {\n  return isVectorLayertype(layer.type);\n};\n\nexport class CustomLayer<T = any> extends Layer implements ICustomLayerOptions<T> {\n  type = CustomLayertype;\n  // tslint:disable-next-line: variable-name\n  custom_layer: T = {} as T;\n  constructor(options: ICustomLayerOptions<T>) {\n    super(options as ILayerOptions);\n    Object.assign(this, options);\n  }\n}\n\nexport class StackedLayer extends Layer implements IStackedLayerOptions {\n  type = StackedLayertype;\n  layers: Layer[] = [];\n  constructor(options: IStackedLayerOptions) {\n    super(options as ILayerOptions);\n    Object.assign(this, options);\n  }\n}\n","import { Layer, TGeoExtent, TFiltertypes } from './Layers';\nimport { IDynamicComponent } from '@dlr-eoc/core-ui';\n\n/**\n *  LayerGroups\n */\nexport interface ILayerGroupOptions {\n  id: string;\n  name: string;\n  /** Layers to group - Higher indexes get drawn above lower indexes */\n  layers: Layer[];\n\n  visible?: boolean;\n  displayName?: string;\n  filtertype?: TFiltertypes;\n  removable?: boolean;\n  layerRemovable?: boolean;\n  bbox?: TGeoExtent;\n  description?: string;\n  actions?: [{ title: string, icon: string, action: (LayerGroup) => void }];\n  /** optional angular component that can be used e.g. to change the layer style, filter the data or request new data */\n  action?: IDynamicComponent;\n  /** UI is expanded */\n  expanded?: boolean;\n  /**\n   * CSS Class for custom styling\n   *\n   * If class 'hide' is included in the string, the group is not shown in the UI - this can probably bring side effects when Layers are reordered, because the hidden layers could be moved on top off all!\n   */\n  cssClass?: string;\n}\n\n/**\n * Classes for layer construction\n */\nexport class LayerGroup implements ILayerGroupOptions {\n  id: string;\n  name: string;\n  layers: Layer[];\n\n  protected protVisible?: boolean;\n  displayName?: string;\n  filtertype?: TFiltertypes = 'Layers';\n  removable = true;\n  layerRemovable = true;\n  bbox?: [number, number, number, number];\n  description?: string;\n  actions?: [{ title: string, icon: string, action: (LayerGroup) => void }];\n  action?: IDynamicComponent;\n  expanded = false;\n  cssClass?: string;\n\n  constructor(options: ILayerGroupOptions) {\n    if (options && options.visible !== undefined && options.layers && options.layers.length) {\n      options.layers = options.layers.map(l => {\n        l.visible = options.visible;\n        return l;\n      });\n    }\n    Object.assign(this, options);\n  }\n\n  get visible() {\n    if (this.layers && this.layers.length) {\n      this.protVisible = this.layers.filter(l => l.visible).length > 0;\n    }\n    return this.protVisible;\n  }\n  set visible(value: boolean) {\n    this.protVisible = value;\n    if (this.layers && this.layers.length) {\n      this.layers = this.layers.map(l => {\n        l.visible = value;\n        return l;\n      });\n    }\n  }\n}\n","import { Layer, RasterLayer, IRasterLayerOptions, IRasterLayerParams } from './Layers';\n/**\n * The following classes try to incorporate any information that map-libraries (ol, mapbox, leaflet) might need to display raster-layers.\n * Like Layers.ts, these classes are intended as an abstraction over all map-libraries.\n * However, they were developed with open-layers in mind, and as such might not (yet) contain all information that other map-libraries require.\n * Please extend these classes with any required information you might find.\n */\n\n\n\nexport interface IWmtsOptions extends IRasterLayerOptions {\n  type: 'wmts';\n  params: IWmtsParams;\n  /** check if the service supports this tilesize */\n  tileSize?: number;\n}\n\n\nexport class WmtsLayer extends RasterLayer implements IWmtsOptions {\n  type: 'wmts';\n  params: IWmtsParams;\n  /** check if the service supports this tilesize */\n  tileSize?: number;\n  constructor(options: IWmtsOptions) {\n    super(options);\n  }\n}\n\n\nexport interface IBaseMatrixSet {\n  /** the MatrixSet ID in WMTS Capabilities - used for GetTile Request */\n  matrixSet: string;\n}\nexport interface IListMatrixSet extends IBaseMatrixSet {\n  matrixIds: string[];\n  resolutions: number[];\n}\n\nexport interface ISimpleMatrixSet extends IBaseMatrixSet {\n  /** levels to create resolutions and matrixIds */\n  resolutionLevels?: number;\n  /** Prefix of the matrixId  */\n  tileMatrixPrefix?: string;\n}\n\nexport interface IWmtsParams {\n  /** Layer name as advertised in the WMTS capabilities. */\n  layer: string;\n  /** Style name as advertised in the WMTS capabilities. */\n  style: string;\n  matrixSetOptions?: ISimpleMatrixSet | IListMatrixSet;\n  projection?: string;\n  format?: string;\n  version?: string;\n}\n\nexport const isWmtsLayer = (layer: Layer): layer is WmtsLayer => {\n  return layer.type === 'wmts';\n};\n\nexport interface IWmsOptions extends IRasterLayerOptions {\n  type: 'wms';\n  params: IWmsParams;\n  /** check if the service supports this tilesize */\n  tileSize?: number;\n}\n\nexport class WmsLayer extends RasterLayer implements IWmsOptions {\n  type: 'wms';\n  params: IWmsParams;\n  /** check if the service supports this tilesize */\n  tileSize?: number;\n  constructor(options: IWmsOptions) {\n    super(options);\n  }\n}\n\nexport interface IWmsParams extends IRasterLayerParams {\n  LAYERS: string;\n  FORMAT?: string;\n  TIME?: string;\n  VERSION?: string;\n  TILED?: string;\n  TRANSPARENT?: boolean;\n  STYLES?: string;\n}\n\nexport const isWmsLayer = (layer: Layer): layer is WmsLayer => {\n  return layer.type === 'wms';\n};\n","import { Injectable } from '@angular/core';\nimport { BehaviorSubject, Observable } from 'rxjs';\nimport { Layer, RasterLayer, TFiltertypes } from './types/Layers';\nimport { LayerGroup } from './types/LayerGroup';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class LayersService {\n  private store = new BehaviorSubject(Array<Layer | LayerGroup>());\n\n  private baseLayers = new BehaviorSubject(Array<Layer>());\n\n  private overlays = new BehaviorSubject(Array<Layer>());\n\n  private layers = new BehaviorSubject(Array<Layer>());\n\n  constructor() {\n\n  }\n\n\n  // ----------------------------------------------------------------------------------------------------------------\n  /**\n   * Adds a ukis Layer to the Layerservice Store\n   * filtertype: TFiltertypes\n   * if filtertype is not provided the filtertype of the Layer is used!\n   *\n   * if toGroup is true the layer is not added to the list of Layers and storeItems. Only used  internally.\n   */\n  public addLayer(layer: Layer, filtertype?: TFiltertypes, toGroup?: boolean) {\n    if (!this.isInLayergroups(layer)) {\n\n      if (!filtertype) {\n        filtertype = layer.filtertype;\n      } else {\n        // set filtertype of Layer!!\n        layer.filtertype = filtertype;\n      }\n\n      const storeItems = this.store.getValue();\n\n      if (toGroup) {\n        this.filterFiltertype(filtertype);\n      } else {\n        storeItems.push(layer);\n\n        this.store.next(storeItems);\n        this.filterFiltertype(filtertype);\n      }\n    } else {\n      console.error(`layer or Group with id: ${layer.id} already exists!`);\n    }\n  }\n\n  /**\n   * Removes a ukis Layer from the Layerservice Store\n   * filtertype: TFiltertypes\n   * if filtertype is not provided the filtertype of the Layer is used!\n   *\n   * force = true - removes a LayerGroup even it is not removable\n   */\n  public removeLayer(layer: Layer, filtertype?: TFiltertypes, force?: boolean) {\n    if (this.isInLayergroups(layer)) {\n      if (force) {\n        console.log(`layer: ${layer.id} is removed with force!`);\n        this._removeLayer(layer, filtertype);\n      } else {\n        if (layer.removable) {\n          this._removeLayer(layer, filtertype);\n        } else if (!layer.removable) {\n          console.log(`layer: ${layer.id} is not removable!`);\n        }\n      }\n    } else {\n      console.error(`layer with id: ${layer.id} not in storeItems!`);\n    }\n  }\n\n  private _removeLayer(layer: Layer, filtertype?: TFiltertypes) {\n    if (!filtertype) {\n      filtertype = layer.filtertype;\n    } else {\n      if (filtertype !== layer.filtertype) {\n        console.error(`the layer with id: ${layer.id} you want to remove from ${filtertype} is from filtertype: ${layer.filtertype}`);\n      }\n    }\n\n    // console.log('remove single layer from storeItems!!!!!');\n    const storeItems = this.store.getValue().filter((lg) => {\n      if (lg instanceof Layer) {\n        return lg.id !== layer.id;\n      } else {\n        return lg;\n      }\n    });\n    this.store.next(storeItems);\n    this.filterFiltertype(filtertype);\n  }\n\n  /**\n   * Updates a ukis Layer in the Layerservice Store\n   * filtertype: TFiltertypes\n   * if filtertype is not provided the filtertype of the Layer is used!\n   */\n  public updateLayer(layer: Layer, filtertype?: TFiltertypes) {\n    if (this.isInLayergroups(layer)) {\n\n      if (!filtertype) {\n        filtertype = layer.filtertype;\n      } else {\n        if (filtertype !== layer.filtertype) {\n          console.error(`the layer with id: ${layer.id} you want to update is from filtertype: ${layer.filtertype} and not from ${filtertype} `);\n        }\n      }\n\n      if (layer.filtertype === 'Overlays') {\n        this.updateLayerOrGroupInStore(layer);\n        this.filterFiltertype(layer.filtertype);\n      }\n      if (layer.filtertype === 'Layers') {\n        this.updateLayerOrGroupInStore(layer);\n        this.filterFiltertype(layer.filtertype);\n      }\n      if (layer.filtertype === 'Baselayers') {\n        this.updateLayerOrGroupInStore(layer);\n        this.filterFiltertype(layer.filtertype);\n      }\n\n    } else {\n      console.error(`layer with id: ${layer.id} you want to update not in storeItems!`);\n    }\n  }\n\n  private updateLayerOrGroupInStore(layerOrGroup: Layer | LayerGroup) {\n    this.store.getValue().filter((lg, index, array) => {\n      // check if both from the same type then check same id\n      if (lg instanceof Layer && layerOrGroup instanceof Layer) {\n        if (lg.id === layerOrGroup.id) {\n          array[index] = layerOrGroup;\n          this.store.next(array);\n        }\n      } else if (lg instanceof LayerGroup && layerOrGroup instanceof LayerGroup) {\n        if (lg.id === layerOrGroup.id) {\n          array[index] = layerOrGroup;\n          this.store.next(array);\n        }\n      }\n    });\n  }\n\n  /**\n   * Removes a ukis Layer or a LayerGroup from the Layerservice Store by the Layer.id or LayerGroup.id\n   * if removeNullGroup is set, then it removes the LayerGroup if no layer is in there\n   *\n   * force = true - removes a LayerGroup even it is not removable\n   */\n  public removeLayerOrGroupById(id: string, removeNullGroup?: boolean, force?: boolean) {\n    this.store.getValue().filter((lg) => {\n      if (lg instanceof Layer) {\n        if (lg.id === id) {\n          this.removeLayer(lg, lg.filtertype || 'Layers', force);\n        }\n      } else if (lg instanceof LayerGroup) {\n        // console.log('LayerGroup: ', lg);\n        // console.log('id', id);\n        if (lg.id === id) {\n          this.removeLayerGroup(lg, force);\n        } else {\n          // this.removeLayerFromGroup\n          lg.layers.forEach((layer) => {\n            if (layer.id === id) {\n              this.removeLayerFromGroup(layer, lg, removeNullGroup, force);\n            }\n          });\n        }\n      }\n    });\n  }\n\n  /**\n   * Adds a ukis Layer to a LayerGroup in the Layerservice Store by providing the Layer and LayerGroup\n   */\n  public addLayerToGroup(layer: Layer, layerGroup: LayerGroup) {\n    if (!this.isInLayergroups(layer)) {\n      // convert filtertyle of layer to the same as the group\n      if (layer.filtertype !== layerGroup.filtertype) {\n        layer.filtertype = layerGroup.filtertype;\n      }\n      if (!this.isInLayergroups(layer, [layerGroup])) {\n        layerGroup.layers.push(layer);\n        this.updateLayerGroup(layerGroup);\n      } else {\n        // throw new Error(`layer or Group with id: ${id} already exists!`);\n        console.error(`layer with id: ${layer.id} already exists in ${layerGroup.id}!`, layerGroup);\n      }\n    } else {\n      // throw new Error(`layer or Group with id: ${id} already exists!`);\n      console.error(`layer with id: ${layer.id} already exists!`);\n    }\n  }\n\n  /**\n   * Adds a ukis Layer to a LayerGroup in the Layerservice Store by providing the Layer and LayerGroup.id\n   */\n  public addLayerToGroupById(layer: Layer, GroupId: string) {\n    this.store.getValue().forEach((lg) => {\n      if (lg instanceof LayerGroup && lg.id === GroupId) {\n        this.addLayerToGroup(layer, lg);\n      }\n    });\n  }\n\n  /**\n   * Removes a Layer from a LayerGroup in the Layerservice Store\n   * By default if no layers on the group it will remove it - change this through set removeNullGroup to false\n   *\n   * force = true - removes the Layer even it is not removable\n   */\n  public removeLayerFromGroup(layer: Layer, layergroup: LayerGroup, removeNullGroup: boolean = true, force?: boolean) {\n    layergroup.layers = layergroup.layers.filter(l => l.id !== layer.id);\n    this.updateLayerGroup(layergroup);\n    this.filterFiltertype(layer.filtertype);\n\n    // if no layers on the group remove it\n    if (layergroup.layers.length === 0 && removeNullGroup) {\n      this.removeLayerGroup(layergroup, force);\n    }\n  }\n\n  /**\n   * Set the Layer Index in the Array of Layers in a LayerGroup\n   * down == + 1 and up == - 1\n   */\n  public setLayerIndexInGroup(layer: Layer, dir: 'up' | 'down', layerGroup: LayerGroup) {\n    // console.log(\"move layer in group \" + dir);\n    // console.log(layerGroup);\n    const groupIndex = layerGroup.layers.indexOf(layer);\n\n    switch (dir) {\n      case 'up': {\n        if (groupIndex === 0) {\n          break;\n        } else {\n          this.arrayMove(layerGroup.layers, groupIndex, groupIndex - 1);\n        }\n        break;\n      }\n      case 'down': {\n        if (groupIndex === layerGroup.layers.length - 1) {\n          break;\n        } else {\n          this.arrayMove(layerGroup.layers, groupIndex, groupIndex + 1);\n        }\n        break;\n      }\n    }\n    this.updateLayer(layer, layerGroup.filtertype || 'Layers');\n  }\n\n\n  // ----------------------------------------------------------------------------------------------------------------\n  /**\n   * Adds a ukis LayerGroup to the Layerservice Store\n   * filtertype: TFiltertypes\n   * if filtertype is not provided the filtertype of the LayerGroup is used\n   * All the Layers of the Group are set to filtertype of the Group\n   */\n  public addLayerGroup(layergroup: LayerGroup, filtertype?: TFiltertypes) {\n    if (!this.isInLayergroups(layergroup)) {\n\n      if (!filtertype) {\n        filtertype = layergroup.filtertype;\n      } else {\n        // set filtertype of Group!!\n        layergroup.filtertype = filtertype;\n      }\n\n      const storeItems = this.store.getValue();\n      // remove layers from group with the same id as the group!\n      if (this.isInLayergroups(layergroup, layergroup.layers)) {\n        layergroup.layers = layergroup.layers.filter(l => l.id !== layergroup.id);\n      }\n      // set filtertype of group to layers\n      layergroup.layers = layergroup.layers.map(l => { l.filtertype = layergroup.filtertype; return l; });\n\n      storeItems.push(layergroup);\n      this.store.next(storeItems);\n\n      // update to set visible\n      this.updateLayerGroup(layergroup);\n    }\n  }\n\n  /**\n   * Removes a ukis LayerGroup to the Layerservice Store\n   * force = true - removes a LayerGroup even it is not removable\n   */\n  public removeLayerGroup(layergroup: LayerGroup, force?: boolean) {\n    if (this.isInLayergroups(layergroup)) {\n      if (force) {\n        console.log(`layerGroup: ${layergroup.id} is removed with force!`);\n        this._removeLayerGroup(layergroup);\n      } else {\n        if (layergroup.removable) {\n          this._removeLayerGroup(layergroup);\n        } else if (!layergroup.removable) {\n          console.log(`layerGroup: ${layergroup.id} is not removable!`);\n        }\n      }\n    } else {\n      console.error(`layer or Group with id: ${layergroup.id} not in storeItems!`);\n    }\n  }\n\n  private _removeLayerGroup(layergroup: LayerGroup) {\n    for (const layer of layergroup.layers) {\n      this.removeLayerFromGroup(layer, layergroup);\n    }\n    const storeItems = this.store.getValue();\n\n    const filteredGroups = storeItems.filter(function (layer, index) {\n      return layer.id !== layergroup.id;\n    });\n\n    this.store.next(filteredGroups);\n  }\n\n  /**\n   * Updates a ukis LayerGroup to the Layerservice Store\n   * if sort is set to true the layers of the Group are sort so vectors are above the rasterlayers\n   */\n  public updateLayerGroup(layerGroup: LayerGroup, sort: boolean = false) {\n    if (sort) {\n      layerGroup = this.sortLayerGroup(layerGroup);\n    }\n    this.updateLayerOrGroupInStore(layerGroup);\n    for (const layer of layerGroup.layers) {\n      /** TODO: this triggers a change for every layer efen if no attributes of the layer are changed!!\n       * To check if layer is changed we have to check all attributes, also objects e.g. CustomLayer... this is complicated??\n       */\n      this.updateLayer(layer, layerGroup.filtertype || 'Layers');\n    }\n  }\n\n  /**\n   * Moves a Item in an Array to another Index\n   */\n  public arrayMove(array: Array<any>, fromIndex: number, toIndex: number) {\n    array.splice((toIndex < 0 ? array.length + toIndex : toIndex), 0, array.splice(fromIndex, 1)[0]);\n  }\n\n  /**\n   * Set Group Or Layer Index in the Layerservice Store\n   * down == index + 1 and up == index - 1\n   */\n  public setGroupLayerIndex(group: Layer | LayerGroup, dir: number | 'up' | 'down') {\n    let groupsCount;\n    if (group instanceof Layer && group.filtertype) {\n      groupsCount = this.getNumOfGroups(group.filtertype);\n    } else if (group instanceof LayerGroup) {\n      groupsCount = this.getNumOfGroups(group.filtertype);\n    }\n\n    if (groupsCount > 1) {\n      const storeItems = this.store.getValue();\n\n      const groupIndex = storeItems.indexOf(group);\n\n      if (!this.isGroupFirst(group) || !this.isGroupLast(group)) {\n        if (typeof dir === 'number') {\n          this.arrayMove(storeItems, groupIndex, dir);\n        } else if (dir === 'up') {\n          this.arrayMove(storeItems, groupIndex, groupIndex - 1);\n        } else if (dir === 'down') {\n          this.arrayMove(storeItems, groupIndex, groupIndex + 1);\n        }\n      }\n      // console.log('groupIndex after', group.name, lgroups.indexOf(group));\n      this.store.next(storeItems);\n      this.baseLayers.next(this.filterBaseLayers());\n      this.layers.next(this.filterLayers());\n      this.overlays.next(this.filterOverlays());\n    }\n  }\n\n  /**\n   * Get the Number of Items from Layerservice Store filtered by filtertype\n   * filtertype: TFiltertypes\n   */\n  getNumOfGroups(filtertype: TFiltertypes): number {\n    let num = 0;\n    const storeItems = this.store.getValue();\n    for (const lg of storeItems) {\n      if (lg.filtertype === filtertype) {\n        // console.log(lg.type, type)\n        num++;\n      }\n    }\n    return num;\n  }\n\n  /**\n   * Check if a Layer or LayerGroup is on index 0 of the Layerservice Store or the provided Array\n   * if filtertype is set it only uses the items with this type\n   * filtertype?: TFiltertypes\n   */\n  isGroupFirst(group: Layer | LayerGroup, lgroups?: Array<Layer | LayerGroup>, filtertype?: TFiltertypes): boolean {\n    let value = false;\n\n    let storeItems = this.store.getValue();\n    if (lgroups) {\n      storeItems = lgroups;\n    }\n    if (filtertype) {\n      storeItems = storeItems.filter(l => l.filtertype === filtertype);\n    }\n    if (storeItems.indexOf(group) === 0) {\n      // console.log(group.name, 'isFirst')\n      value = true;\n    }\n    return value;\n  }\n\n  /**\n   * Check if a Layer or LayerGroup is on index (length - 1) of the Layerservice Store or the provided Array\n   * if filtertype is set it only uses the items with this type\n   * filtertype?: TFiltertypes\n   */\n  isGroupLast(group: Layer | LayerGroup, lgroups?: Array<Layer | LayerGroup>, filtertype?: TFiltertypes): boolean {\n    let value = false;\n\n    let storeItems = this.store.getValue();\n    if (lgroups) {\n      storeItems = lgroups;\n    }\n    if (filtertype) {\n      storeItems = storeItems.filter(l => l.filtertype === filtertype);\n    }\n    if (storeItems.indexOf(group) === storeItems.length - 1) {\n      value = true;\n    }\n    return value;\n  }\n  // ----------------------------------------------------------------------------------------------------------------\n\n\n  /**\n   * Check if a Layer or LayerGroup is in the Layerservice Store (or the provided Array) by their ID\n   */\n  public isInLayergroups(layergroup: Layer | LayerGroup | string, groups?: Array<Layer | LayerGroup>): boolean {\n    let value = false;\n    let id;\n    if (layergroup instanceof Layer || layergroup instanceof LayerGroup) {\n      id = layergroup.id;\n    } else {\n      id = layergroup;\n    }\n    const items = this.getLayerOrGroupById(id, groups);\n    if (items && items instanceof Layer || items instanceof LayerGroup) {\n      value = true;\n    }\n    return value;\n  }\n\n  /**\n   * Get a Layer or LayerGroup by ID from the Layerservice Store (or the provided Array)\n   * normal there should only be returned one or zero items in the array otherwise there is a duplicate ID in the Layer Groups!!\n   */\n  public getLayerOrGroupById(id: string, groups?: Array<Layer | LayerGroup>) {\n    const items: Array<Layer | LayerGroup> = [];\n    let storeItems = this.store.getValue();\n    if (groups) {\n      storeItems = groups;\n    }\n    storeItems.map(group => {\n      if (group instanceof LayerGroup) {\n        if (group.id === id) {\n          items.push(group);\n        } else {\n          group.layers.map(layer => {\n            if (layer.id === id) {\n              items.push(layer);\n            }\n          });\n        }\n      } else if (group instanceof Layer) {\n        if (group.id === id) {\n          items.push(group);\n        }\n      }\n    });\n\n    if (!items.length) {\n      return null;\n    } else if (items.length === 1) {\n      return items[0];\n    } else if (items.length > 1) {\n      console.log('there is a duplicate ID in the Layer Groups!');\n    }\n  }\n  /**\n   * Get a Layer by ID from the Layerservice Store (or the provided Array)\n   */\n  public getLayerById(id: string, layers?: Array<Layer>) {\n    let value: Layer;\n    let flatlayers = this.flattenDeepArray(this.store.getValue());\n    if (layers) {\n      flatlayers = layers;\n    }\n    flatlayers.map(layer => {\n      if (layer.id === id) {\n        value = layer;\n      }\n    });\n    return value;\n  }\n\n  /**\n   * Get all Layers with filterrype 'Baselayers' from the Layerservice Store\n   */\n  public getBaseLayers(): Observable<Layer[]> {\n    return this.baseLayers.asObservable();\n  }\n\n  /**\n   * Removes Layers with filtertype 'Baselayers' from the Layerservice Store\n   * Filter is a function to exclude layers\n   */\n  public removeBaseLayers(filter?: (value: Layer, index: number, array: Layer[]) => any): Observable<Layer[]> {\n    let baselayers = this.filterBaseLayers();\n    if (filter) {\n      baselayers = baselayers.filter(filter);\n    }\n    baselayers.forEach((ol) => {\n      this.removeLayerOrGroupById(ol.id);\n    });\n    return this.baseLayers.asObservable();\n  }\n\n  public getBaseLayersCount(): number {\n    return this.baseLayers.getValue().length;\n  }\n\n\n  /**\n   * Get all Layers with filterrype 'Overlays' from the Layerservice Store\n   */\n  public getOverlays(): Observable<Layer[]> {\n    return this.overlays.asObservable();\n  }\n\n  /**\n   * Removes Layers with filtertype 'Overlays' from the Layerservice Store\n   * Filter is a function to exclude layers\n   */\n  public removeOverlays(filter?: (value: Layer, index: number, array: Layer[]) => any): Observable<Layer[]> {\n    let overlays = this.filterOverlays();\n    if (filter) {\n      overlays = overlays.filter(filter);\n    }\n    overlays.forEach((ol) => {\n      this.removeLayerOrGroupById(ol.id);\n    });\n    return this.overlays.asObservable();\n  }\n\n  public getOverlaysCount(): number {\n    return this.overlays.getValue().length;\n  }\n\n  /**\n   * Get all Layers with filterrype 'Layers' from the Layerservice Store\n   *\n   * #### to filter the Observable only on some layer property changes use rxjs filter e.g. see below:\n   * this.layersSub = this.layerSvc.getLayers().pipe(filter(layers => {\n   *   const newVisible = layers.map(l => l.visible).filter(v => v === true).length;\n   *  // subscribe if visible of a layer has changed\n   *  if (newVisible !== this.oldVisibleLayers) {\n   *     return true;\n   *  } else {\n   *     // subscribe only to remove, add layers\n   *     if (this.layers && this.layers.length !== layers.length) {\n   *       return true;\n   *    } else {\n   *       return false;\n   *    }\n   *  }\n   * })).subscribe(layers => {\n   *   this.layers = layers;\n   *   this.oldVisibleLayers = this.layers.map(l => l.visible).filter(v => v === true).length;\n   * });\n   */\n  public getLayers(): Observable<Layer[]> {\n    return this.layers.asObservable();\n  }\n\n  /**\n   * Removes Layers with filtertype 'Layers' from the Layerservice Store\n   * Filter is a function to exclude layers\n   */\n  public removeLayers(filter?: (value: Layer, index: number, array: Layer[]) => any): Observable<Layer[]> {\n    let layers = this.filterLayers();\n    if (filter) {\n      layers = layers.filter(filter);\n    }\n    layers.forEach((ol) => {\n      this.removeLayerOrGroupById(ol.id);\n    });\n    return this.layers.asObservable();\n  }\n\n  public getLayersCount(): number {\n    return this.layers.getValue().length;\n  }\n\n  /**\n   * Get all storeItems from the Layerservice\n   */\n  public getLayerGroups(): Observable<Array<Layer | LayerGroup>> {\n    return this.store.asObservable();\n  }\n\n  /**\n   * Set (Reset) all storeItems from the Layerservice\n   * if filtertype is set then only the slot is used\n   */\n  public setLayerGroups(items: Array<Layer | LayerGroup>, filtertype?: TFiltertypes): Observable<Array<Layer | LayerGroup>> {\n    // set filtertype of group to layers\n    if (items.length > 0) {\n      items.map(group => {\n        if (group instanceof LayerGroup && group.layers.length > 0) {\n          group.layers = group.layers.map(l => { l.filtertype = group.filtertype; return l; });\n        }\n      });\n    }\n\n    if (!filtertype) {\n      this.store.next(items);\n      this.baseLayers.next(this.filterBaseLayers());\n      this.layers.next(this.filterLayers());\n      this.overlays.next(this.filterOverlays());\n    } else {\n      if (filtertype === 'Baselayers') {\n        this.removeBaseLayers();\n      } else if (filtertype === 'Layers') {\n        this.removeLayers();\n      } else if (filtertype === 'Overlays') {\n        this.removeOverlays();\n      }\n\n      items.map(lg => {\n        if (lg instanceof Layer) {\n          this.addLayer(lg, filtertype);\n        } else if (lg instanceof LayerGroup) {\n          this.addLayerGroup(lg, filtertype);\n        }\n      });\n    }\n\n    return this.store.asObservable();\n  }\n\n  /**\n   * Get the Count of all storeItems\n   */\n  public getLayerGroupsCount(): number {\n    return this.store.getValue().length;\n  }\n  // ----------------------------------------------------------------------------------------------------------------\n\n\n  /**\n   * flatten array with Layers and LayerGroups.layers (so you can get the zIndex)\n   */\n  public flattenDeepArray(arr: Array<Layer | LayerGroup>): Layer[] {\n    return arr.reduce((acc, val) => (val instanceof LayerGroup && Array.isArray(val.layers)) ? acc.concat(this.flattenDeepArray(val.layers)) : acc.concat(val), []);\n  }\n\n  /*\n  getZIndexForLayer(layer: Layer): number {\n    let zIndex = null;\n    const baselayers = this.baseLayers.getValue();\n    const layers = this.layers.getValue();\n    const overlays = this.overlays.getValue();\n    let arr = [];\n\n    if (layer.filtertype === 'Overlays') {\n      arr = arr.concat(baselayers).concat(layers).concat(overlays);\n      zIndex = arr.indexOf(layer);\n    } else if (layer.filtertype === 'Layers') {\n      arr = arr.concat(baselayers).concat(layers);\n      zIndex = arr.indexOf(layer);\n    } else if (layer.filtertype === 'Baselayers') {\n      arr = arr.concat(baselayers);\n      zIndex = arr.indexOf(layer);\n    }\n    return zIndex;\n  }\n  */\n\n  private filterOverlays() {\n    const storeItems = this.store.getValue();\n    const overlays = this.flattenDeepArray(storeItems.filter((layer) => layer.filtertype === 'Overlays'));\n    return overlays;\n  }\n\n  private filterBaseLayers() {\n    const storeItems = this.store.getValue();\n    const baselayers = this.flattenDeepArray(storeItems.filter((layer) => layer.filtertype === 'Baselayers'));\n    return baselayers;\n  }\n\n  private filterLayers() {\n    const storeItems = this.store.getValue();\n    const baselayers = this.flattenDeepArray(storeItems.filter((layer) => layer.filtertype === 'Layers'));\n    return baselayers;\n  }\n\n\n  private filterFiltertype(filtertype: TFiltertypes) {\n    if (filtertype === 'Baselayers') {\n      this.baseLayers.next(this.filterBaseLayers());\n    } else if (filtertype === 'Overlays') {\n      this.overlays.next(this.filterOverlays());\n    } else if (filtertype === 'Layers') {\n      this.layers.next(this.filterLayers());\n    }\n  }\n\n\n  // ----------------------------------------------------------------------\n\n  private sortLayerGroup(layerGroup: LayerGroup): LayerGroup {\n\n    // fisrt sort in order to put vectors first and then rasterlayers\n    layerGroup.layers.sort((a, b) => {\n      let comparison = 0;\n      if (a instanceof RasterLayer) {\n        comparison = 1;\n      } else if (b instanceof RasterLayer) {\n        comparison = -1;\n      }\n      return comparison;\n    });\n    return layerGroup;\n  }\n}\n","import { NgModule } from '@angular/core';\nimport { LayersService } from './layers.service';\n\n@NgModule({\n  // components and directives of the module\n  declarations: [],\n  // which other modules are used\n  imports: [],\n  // components and directives of the module\n  exports: [],\n  // Most of the time, these are services that you create and provide\n  providers: [LayersService]\n})\nexport class LayersModule { }\n","/*\n * Public API Surface of services-layers\n */\n\nexport * from './lib/types/Layers';\nexport * from './lib/types/LayerGroup';\nexport * from './lib/types/RasterLayers';\n\nexport * from './lib/layers.service';\nexport * from './lib/layers.module';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":[],"mappings":"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"}