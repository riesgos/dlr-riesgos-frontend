import * as i0 from '@angular/core';
import { Injectable, NgModule } from '@angular/core';
import { BehaviorSubject } from 'rxjs';

/** can be raster and vector */
const TmsLayertype = 'tms';
const WmsLayertype = 'wms';
const WmtsLayertype = 'wmts';
const XyzLayertype = 'xyz';
const GeojsonLayertype = 'geojson';
const KmlLayertype = 'kml';
const WfsLayertype = 'wfs';
/** can be raster and vector */
const CustomLayertype = 'custom';
/** can have multiple layers raster, vector... */
const StackedLayertype = 'stacked';
const Filtertypes = {
    Baselayers: 'Baselayers',
    Overlays: 'Overlays',
    Layers: 'Layers'
};
/**
 * @deprecated The method should not be used because it can be false positive
 *
 * CustomLayertype and TmsLayertype can be raster and vector.
 * You have to double check by yourself later!
 */
function isVectorLayertype(inpt) {
    return [GeojsonLayertype, WfsLayertype, CustomLayertype, KmlLayertype, TmsLayertype].includes(inpt);
}
/**
 * @deprecated The method should not be used because it can be false positive
 *
 * CustomLayertype and TmsLayertype can be raster and vector.
 * You have to double check by yourself later!
 */
function isRasterLayertype(inpt) {
    return [WmsLayertype, WmtsLayertype, XyzLayertype, CustomLayertype, TmsLayertype].includes(inpt);
}
function isLayertype(type) {
    return [TmsLayertype, WmsLayertype, WmtsLayertype, XyzLayertype, GeojsonLayertype, KmlLayertype, WfsLayertype, CustomLayertype].includes(type);
}
/**
 * Classes for layer construction
 */
class Layer {
    constructor(options) {
        this.name = '';
        this.id = '';
        this.opacity = 1;
        this.visible = true;
        this.removable = false;
        this.filtertype = 'Layers';
        this.continuousWorld = false;
        this.expanded = false;
        Object.assign(this, options);
    }
    get time() {
        return this.protTime;
    }
    set time(time) {
        this.protTime = time;
    }
}
class RasterLayer extends Layer {
    constructor(options) {
        super(options);
        // if styles are given, set params and legendImg accordingly.
        if (this.styles && this.styles.length > 0) {
            let defaultStyle = this.styles.find(s => s.default);
            if (!defaultStyle) {
                defaultStyle = this.styles[0];
            }
            this.legendImg = defaultStyle.legendURL;
            if (this.params) {
                if (this.type === WmsLayertype) {
                    this.params.STYLES = defaultStyle.name;
                }
                else if (this.type === WmtsLayertype) {
                    this.params.style = defaultStyle.name;
                }
                this.params.STYLES = defaultStyle.name;
            }
            else if (this.type === WmtsLayertype) {
                if (!this.params) {
                    this.params = {};
                }
                this.params.style = defaultStyle.name;
            }
        }
    }
    set time(time) {
        if (this.params) {
            this.params.TIME = time;
        }
        this.protTime = time;
    }
    get time() {
        return this.protTime;
    }
}
/**
 * @deprecated The method should not be used because it can be false positive
 */
const isRasterLayer = (layer) => {
    return isRasterLayertype(layer.type);
};
class VectorLayer extends Layer {
    constructor(options) {
        super(options);
    }
}
/**
 * @deprecated The method should not be used because it can be false positive
 */
const isVectorLayer = (layer) => {
    return isVectorLayertype(layer.type);
};
class CustomLayer extends Layer {
    constructor(options) {
        super(options);
        this.type = CustomLayertype;
        // tslint:disable-next-line: variable-name
        this.custom_layer = {};
        Object.assign(this, options);
    }
}
class StackedLayer extends Layer {
    constructor(options) {
        super(options);
        this.type = StackedLayertype;
        this.layers = [];
        Object.assign(this, options);
    }
}

/**
 * Classes for layer construction
 */
class LayerGroup {
    constructor(options) {
        this.filtertype = 'Layers';
        this.removable = true;
        this.layerRemovable = true;
        this.expanded = false;
        if (options && options.visible !== undefined && options.layers && options.layers.length) {
            options.layers = options.layers.map(l => {
                l.visible = options.visible;
                return l;
            });
        }
        Object.assign(this, options);
    }
    get visible() {
        if (this.layers && this.layers.length) {
            this.protVisible = this.layers.filter(l => l.visible).length > 0;
        }
        return this.protVisible;
    }
    set visible(value) {
        this.protVisible = value;
        if (this.layers && this.layers.length) {
            this.layers = this.layers.map(l => {
                l.visible = value;
                return l;
            });
        }
    }
}

class WmtsLayer extends RasterLayer {
    constructor(options) {
        super(options);
    }
}
const isWmtsLayer = (layer) => {
    return layer.type === 'wmts';
};
class WmsLayer extends RasterLayer {
    constructor(options) {
        super(options);
    }
}
const isWmsLayer = (layer) => {
    return layer.type === 'wms';
};

class LayersService {
    constructor() {
        this.store = new BehaviorSubject(Array());
        this.baseLayers = new BehaviorSubject(Array());
        this.overlays = new BehaviorSubject(Array());
        this.layers = new BehaviorSubject(Array());
    }
    // ----------------------------------------------------------------------------------------------------------------
    /**
     * Adds a ukis Layer to the Layerservice Store
     * filtertype: TFiltertypes
     * if filtertype is not provided the filtertype of the Layer is used!
     *
     * if toGroup is true the layer is not added to the list of Layers and storeItems. Only used  internally.
     */
    addLayer(layer, filtertype, toGroup) {
        if (!this.isInLayergroups(layer)) {
            if (!filtertype) {
                filtertype = layer.filtertype;
            }
            else {
                // set filtertype of Layer!!
                layer.filtertype = filtertype;
            }
            const storeItems = this.store.getValue();
            if (toGroup) {
                this.filterFiltertype(filtertype);
            }
            else {
                storeItems.push(layer);
                this.store.next(storeItems);
                this.filterFiltertype(filtertype);
            }
        }
        else {
            console.error(`layer or Group with id: ${layer.id} already exists!`);
        }
    }
    /**
     * Removes a ukis Layer from the Layerservice Store
     * filtertype: TFiltertypes
     * if filtertype is not provided the filtertype of the Layer is used!
     *
     * force = true - removes a LayerGroup even it is not removable
     */
    removeLayer(layer, filtertype, force) {
        if (this.isInLayergroups(layer)) {
            if (force) {
                console.log(`layer: ${layer.id} is removed with force!`);
                this._removeLayer(layer, filtertype);
            }
            else {
                if (layer.removable) {
                    this._removeLayer(layer, filtertype);
                }
                else if (!layer.removable) {
                    console.log(`layer: ${layer.id} is not removable!`);
                }
            }
        }
        else {
            console.error(`layer with id: ${layer.id} not in storeItems!`);
        }
    }
    _removeLayer(layer, filtertype) {
        if (!filtertype) {
            filtertype = layer.filtertype;
        }
        else {
            if (filtertype !== layer.filtertype) {
                console.error(`the layer with id: ${layer.id} you want to remove from ${filtertype} is from filtertype: ${layer.filtertype}`);
            }
        }
        // console.log('remove single layer from storeItems!!!!!');
        const storeItems = this.store.getValue().filter((lg) => {
            if (lg instanceof Layer) {
                return lg.id !== layer.id;
            }
            else {
                return lg;
            }
        });
        this.store.next(storeItems);
        this.filterFiltertype(filtertype);
    }
    /**
     * Updates a ukis Layer in the Layerservice Store
     * filtertype: TFiltertypes
     * if filtertype is not provided the filtertype of the Layer is used!
     */
    updateLayer(layer, filtertype) {
        if (this.isInLayergroups(layer)) {
            if (!filtertype) {
                filtertype = layer.filtertype;
            }
            else {
                if (filtertype !== layer.filtertype) {
                    console.error(`the layer with id: ${layer.id} you want to update is from filtertype: ${layer.filtertype} and not from ${filtertype} `);
                }
            }
            if (layer.filtertype === 'Overlays') {
                this.updateLayerOrGroupInStore(layer);
                this.filterFiltertype(layer.filtertype);
            }
            if (layer.filtertype === 'Layers') {
                this.updateLayerOrGroupInStore(layer);
                this.filterFiltertype(layer.filtertype);
            }
            if (layer.filtertype === 'Baselayers') {
                this.updateLayerOrGroupInStore(layer);
                this.filterFiltertype(layer.filtertype);
            }
        }
        else {
            console.error(`layer with id: ${layer.id} you want to update not in storeItems!`);
        }
    }
    updateLayerOrGroupInStore(layerOrGroup) {
        this.store.getValue().filter((lg, index, array) => {
            // check if both from the same type then check same id
            if (lg instanceof Layer && layerOrGroup instanceof Layer) {
                if (lg.id === layerOrGroup.id) {
                    array[index] = layerOrGroup;
                    this.store.next(array);
                }
            }
            else if (lg instanceof LayerGroup && layerOrGroup instanceof LayerGroup) {
                if (lg.id === layerOrGroup.id) {
                    array[index] = layerOrGroup;
                    this.store.next(array);
                }
            }
        });
    }
    /**
     * Removes a ukis Layer or a LayerGroup from the Layerservice Store by the Layer.id or LayerGroup.id
     * if removeNullGroup is set, then it removes the LayerGroup if no layer is in there
     *
     * force = true - removes a LayerGroup even it is not removable
     */
    removeLayerOrGroupById(id, removeNullGroup, force) {
        this.store.getValue().filter((lg) => {
            if (lg instanceof Layer) {
                if (lg.id === id) {
                    this.removeLayer(lg, lg.filtertype || 'Layers', force);
                }
            }
            else if (lg instanceof LayerGroup) {
                // console.log('LayerGroup: ', lg);
                // console.log('id', id);
                if (lg.id === id) {
                    this.removeLayerGroup(lg, force);
                }
                else {
                    // this.removeLayerFromGroup
                    lg.layers.forEach((layer) => {
                        if (layer.id === id) {
                            this.removeLayerFromGroup(layer, lg, removeNullGroup, force);
                        }
                    });
                }
            }
        });
    }
    /**
     * Adds a ukis Layer to a LayerGroup in the Layerservice Store by providing the Layer and LayerGroup
     */
    addLayerToGroup(layer, layerGroup) {
        if (!this.isInLayergroups(layer)) {
            // convert filtertyle of layer to the same as the group
            if (layer.filtertype !== layerGroup.filtertype) {
                layer.filtertype = layerGroup.filtertype;
            }
            if (!this.isInLayergroups(layer, [layerGroup])) {
                layerGroup.layers.push(layer);
                this.updateLayerGroup(layerGroup);
            }
            else {
                // throw new Error(`layer or Group with id: ${id} already exists!`);
                console.error(`layer with id: ${layer.id} already exists in ${layerGroup.id}!`, layerGroup);
            }
        }
        else {
            // throw new Error(`layer or Group with id: ${id} already exists!`);
            console.error(`layer with id: ${layer.id} already exists!`);
        }
    }
    /**
     * Adds a ukis Layer to a LayerGroup in the Layerservice Store by providing the Layer and LayerGroup.id
     */
    addLayerToGroupById(layer, GroupId) {
        this.store.getValue().forEach((lg) => {
            if (lg instanceof LayerGroup && lg.id === GroupId) {
                this.addLayerToGroup(layer, lg);
            }
        });
    }
    /**
     * Removes a Layer from a LayerGroup in the Layerservice Store
     * By default if no layers on the group it will remove it - change this through set removeNullGroup to false
     *
     * force = true - removes the Layer even it is not removable
     */
    removeLayerFromGroup(layer, layergroup, removeNullGroup = true, force) {
        layergroup.layers = layergroup.layers.filter(l => l.id !== layer.id);
        this.updateLayerGroup(layergroup);
        this.filterFiltertype(layer.filtertype);
        // if no layers on the group remove it
        if (layergroup.layers.length === 0 && removeNullGroup) {
            this.removeLayerGroup(layergroup, force);
        }
    }
    /**
     * Set the Layer Index in the Array of Layers in a LayerGroup
     * down == + 1 and up == - 1
     */
    setLayerIndexInGroup(layer, dir, layerGroup) {
        // console.log("move layer in group " + dir);
        // console.log(layerGroup);
        const groupIndex = layerGroup.layers.indexOf(layer);
        switch (dir) {
            case 'up': {
                if (groupIndex === 0) {
                    break;
                }
                else {
                    this.arrayMove(layerGroup.layers, groupIndex, groupIndex - 1);
                }
                break;
            }
            case 'down': {
                if (groupIndex === layerGroup.layers.length - 1) {
                    break;
                }
                else {
                    this.arrayMove(layerGroup.layers, groupIndex, groupIndex + 1);
                }
                break;
            }
        }
        this.updateLayer(layer, layerGroup.filtertype || 'Layers');
    }
    // ----------------------------------------------------------------------------------------------------------------
    /**
     * Adds a ukis LayerGroup to the Layerservice Store
     * filtertype: TFiltertypes
     * if filtertype is not provided the filtertype of the LayerGroup is used
     * All the Layers of the Group are set to filtertype of the Group
     */
    addLayerGroup(layergroup, filtertype) {
        if (!this.isInLayergroups(layergroup)) {
            if (!filtertype) {
                filtertype = layergroup.filtertype;
            }
            else {
                // set filtertype of Group!!
                layergroup.filtertype = filtertype;
            }
            const storeItems = this.store.getValue();
            // remove layers from group with the same id as the group!
            if (this.isInLayergroups(layergroup, layergroup.layers)) {
                layergroup.layers = layergroup.layers.filter(l => l.id !== layergroup.id);
            }
            // set filtertype of group to layers
            layergroup.layers = layergroup.layers.map(l => { l.filtertype = layergroup.filtertype; return l; });
            storeItems.push(layergroup);
            this.store.next(storeItems);
            // update to set visible
            this.updateLayerGroup(layergroup);
        }
    }
    /**
     * Removes a ukis LayerGroup to the Layerservice Store
     * force = true - removes a LayerGroup even it is not removable
     */
    removeLayerGroup(layergroup, force) {
        if (this.isInLayergroups(layergroup)) {
            if (force) {
                console.log(`layerGroup: ${layergroup.id} is removed with force!`);
                this._removeLayerGroup(layergroup);
            }
            else {
                if (layergroup.removable) {
                    this._removeLayerGroup(layergroup);
                }
                else if (!layergroup.removable) {
                    console.log(`layerGroup: ${layergroup.id} is not removable!`);
                }
            }
        }
        else {
            console.error(`layer or Group with id: ${layergroup.id} not in storeItems!`);
        }
    }
    _removeLayerGroup(layergroup) {
        for (const layer of layergroup.layers) {
            this.removeLayerFromGroup(layer, layergroup);
        }
        const storeItems = this.store.getValue();
        const filteredGroups = storeItems.filter(function (layer, index) {
            return layer.id !== layergroup.id;
        });
        this.store.next(filteredGroups);
    }
    /**
     * Updates a ukis LayerGroup to the Layerservice Store
     * if sort is set to true the layers of the Group are sort so vectors are above the rasterlayers
     */
    updateLayerGroup(layerGroup, sort = false) {
        if (sort) {
            layerGroup = this.sortLayerGroup(layerGroup);
        }
        this.updateLayerOrGroupInStore(layerGroup);
        for (const layer of layerGroup.layers) {
            /** TODO: this triggers a change for every layer efen if no attributes of the layer are changed!!
             * To check if layer is changed we have to check all attributes, also objects e.g. CustomLayer... this is complicated??
             */
            this.updateLayer(layer, layerGroup.filtertype || 'Layers');
        }
    }
    /**
     * Moves a Item in an Array to another Index
     */
    arrayMove(array, fromIndex, toIndex) {
        array.splice((toIndex < 0 ? array.length + toIndex : toIndex), 0, array.splice(fromIndex, 1)[0]);
    }
    /**
     * Set Group Or Layer Index in the Layerservice Store
     * down == index + 1 and up == index - 1
     */
    setGroupLayerIndex(group, dir) {
        let groupsCount;
        if (group instanceof Layer && group.filtertype) {
            groupsCount = this.getNumOfGroups(group.filtertype);
        }
        else if (group instanceof LayerGroup) {
            groupsCount = this.getNumOfGroups(group.filtertype);
        }
        if (groupsCount > 1) {
            const storeItems = this.store.getValue();
            const groupIndex = storeItems.indexOf(group);
            if (!this.isGroupFirst(group) || !this.isGroupLast(group)) {
                if (typeof dir === 'number') {
                    this.arrayMove(storeItems, groupIndex, dir);
                }
                else if (dir === 'up') {
                    this.arrayMove(storeItems, groupIndex, groupIndex - 1);
                }
                else if (dir === 'down') {
                    this.arrayMove(storeItems, groupIndex, groupIndex + 1);
                }
            }
            // console.log('groupIndex after', group.name, lgroups.indexOf(group));
            this.store.next(storeItems);
            this.baseLayers.next(this.filterBaseLayers());
            this.layers.next(this.filterLayers());
            this.overlays.next(this.filterOverlays());
        }
    }
    /**
     * Get the Number of Items from Layerservice Store filtered by filtertype
     * filtertype: TFiltertypes
     */
    getNumOfGroups(filtertype) {
        let num = 0;
        const storeItems = this.store.getValue();
        for (const lg of storeItems) {
            if (lg.filtertype === filtertype) {
                // console.log(lg.type, type)
                num++;
            }
        }
        return num;
    }
    /**
     * Check if a Layer or LayerGroup is on index 0 of the Layerservice Store or the provided Array
     * if filtertype is set it only uses the items with this type
     * filtertype?: TFiltertypes
     */
    isGroupFirst(group, lgroups, filtertype) {
        let value = false;
        let storeItems = this.store.getValue();
        if (lgroups) {
            storeItems = lgroups;
        }
        if (filtertype) {
            storeItems = storeItems.filter(l => l.filtertype === filtertype);
        }
        if (storeItems.indexOf(group) === 0) {
            // console.log(group.name, 'isFirst')
            value = true;
        }
        return value;
    }
    /**
     * Check if a Layer or LayerGroup is on index (length - 1) of the Layerservice Store or the provided Array
     * if filtertype is set it only uses the items with this type
     * filtertype?: TFiltertypes
     */
    isGroupLast(group, lgroups, filtertype) {
        let value = false;
        let storeItems = this.store.getValue();
        if (lgroups) {
            storeItems = lgroups;
        }
        if (filtertype) {
            storeItems = storeItems.filter(l => l.filtertype === filtertype);
        }
        if (storeItems.indexOf(group) === storeItems.length - 1) {
            value = true;
        }
        return value;
    }
    // ----------------------------------------------------------------------------------------------------------------
    /**
     * Check if a Layer or LayerGroup is in the Layerservice Store (or the provided Array) by their ID
     */
    isInLayergroups(layergroup, groups) {
        let value = false;
        let id;
        if (layergroup instanceof Layer || layergroup instanceof LayerGroup) {
            id = layergroup.id;
        }
        else {
            id = layergroup;
        }
        const items = this.getLayerOrGroupById(id, groups);
        if (items && items instanceof Layer || items instanceof LayerGroup) {
            value = true;
        }
        return value;
    }
    /**
     * Get a Layer or LayerGroup by ID from the Layerservice Store (or the provided Array)
     * normal there should only be returned one or zero items in the array otherwise there is a duplicate ID in the Layer Groups!!
     */
    getLayerOrGroupById(id, groups) {
        const items = [];
        let storeItems = this.store.getValue();
        if (groups) {
            storeItems = groups;
        }
        storeItems.map(group => {
            if (group instanceof LayerGroup) {
                if (group.id === id) {
                    items.push(group);
                }
                else {
                    group.layers.map(layer => {
                        if (layer.id === id) {
                            items.push(layer);
                        }
                    });
                }
            }
            else if (group instanceof Layer) {
                if (group.id === id) {
                    items.push(group);
                }
            }
        });
        if (!items.length) {
            return null;
        }
        else if (items.length === 1) {
            return items[0];
        }
        else if (items.length > 1) {
            console.log('there is a duplicate ID in the Layer Groups!');
        }
    }
    /**
     * Get a Layer by ID from the Layerservice Store (or the provided Array)
     */
    getLayerById(id, layers) {
        let value;
        let flatlayers = this.flattenDeepArray(this.store.getValue());
        if (layers) {
            flatlayers = layers;
        }
        flatlayers.map(layer => {
            if (layer.id === id) {
                value = layer;
            }
        });
        return value;
    }
    /**
     * Get all Layers with filterrype 'Baselayers' from the Layerservice Store
     */
    getBaseLayers() {
        return this.baseLayers.asObservable();
    }
    /**
     * Removes Layers with filtertype 'Baselayers' from the Layerservice Store
     * Filter is a function to exclude layers
     */
    removeBaseLayers(filter) {
        let baselayers = this.filterBaseLayers();
        if (filter) {
            baselayers = baselayers.filter(filter);
        }
        baselayers.forEach((ol) => {
            this.removeLayerOrGroupById(ol.id);
        });
        return this.baseLayers.asObservable();
    }
    getBaseLayersCount() {
        return this.baseLayers.getValue().length;
    }
    /**
     * Get all Layers with filterrype 'Overlays' from the Layerservice Store
     */
    getOverlays() {
        return this.overlays.asObservable();
    }
    /**
     * Removes Layers with filtertype 'Overlays' from the Layerservice Store
     * Filter is a function to exclude layers
     */
    removeOverlays(filter) {
        let overlays = this.filterOverlays();
        if (filter) {
            overlays = overlays.filter(filter);
        }
        overlays.forEach((ol) => {
            this.removeLayerOrGroupById(ol.id);
        });
        return this.overlays.asObservable();
    }
    getOverlaysCount() {
        return this.overlays.getValue().length;
    }
    /**
     * Get all Layers with filterrype 'Layers' from the Layerservice Store
     *
     * #### to filter the Observable only on some layer property changes use rxjs filter e.g. see below:
     * this.layersSub = this.layerSvc.getLayers().pipe(filter(layers => {
     *   const newVisible = layers.map(l => l.visible).filter(v => v === true).length;
     *  // subscribe if visible of a layer has changed
     *  if (newVisible !== this.oldVisibleLayers) {
     *     return true;
     *  } else {
     *     // subscribe only to remove, add layers
     *     if (this.layers && this.layers.length !== layers.length) {
     *       return true;
     *    } else {
     *       return false;
     *    }
     *  }
     * })).subscribe(layers => {
     *   this.layers = layers;
     *   this.oldVisibleLayers = this.layers.map(l => l.visible).filter(v => v === true).length;
     * });
     */
    getLayers() {
        return this.layers.asObservable();
    }
    /**
     * Removes Layers with filtertype 'Layers' from the Layerservice Store
     * Filter is a function to exclude layers
     */
    removeLayers(filter) {
        let layers = this.filterLayers();
        if (filter) {
            layers = layers.filter(filter);
        }
        layers.forEach((ol) => {
            this.removeLayerOrGroupById(ol.id);
        });
        return this.layers.asObservable();
    }
    getLayersCount() {
        return this.layers.getValue().length;
    }
    /**
     * Get all storeItems from the Layerservice
     */
    getLayerGroups() {
        return this.store.asObservable();
    }
    /**
     * Set (Reset) all storeItems from the Layerservice
     * if filtertype is set then only the slot is used
     */
    setLayerGroups(items, filtertype) {
        // set filtertype of group to layers
        if (items.length > 0) {
            items.map(group => {
                if (group instanceof LayerGroup && group.layers.length > 0) {
                    group.layers = group.layers.map(l => { l.filtertype = group.filtertype; return l; });
                }
            });
        }
        if (!filtertype) {
            this.store.next(items);
            this.baseLayers.next(this.filterBaseLayers());
            this.layers.next(this.filterLayers());
            this.overlays.next(this.filterOverlays());
        }
        else {
            if (filtertype === 'Baselayers') {
                this.removeBaseLayers();
            }
            else if (filtertype === 'Layers') {
                this.removeLayers();
            }
            else if (filtertype === 'Overlays') {
                this.removeOverlays();
            }
            items.map(lg => {
                if (lg instanceof Layer) {
                    this.addLayer(lg, filtertype);
                }
                else if (lg instanceof LayerGroup) {
                    this.addLayerGroup(lg, filtertype);
                }
            });
        }
        return this.store.asObservable();
    }
    /**
     * Get the Count of all storeItems
     */
    getLayerGroupsCount() {
        return this.store.getValue().length;
    }
    // ----------------------------------------------------------------------------------------------------------------
    /**
     * flatten array with Layers and LayerGroups.layers (so you can get the zIndex)
     */
    flattenDeepArray(arr) {
        return arr.reduce((acc, val) => (val instanceof LayerGroup && Array.isArray(val.layers)) ? acc.concat(this.flattenDeepArray(val.layers)) : acc.concat(val), []);
    }
    /*
    getZIndexForLayer(layer: Layer): number {
      let zIndex = null;
      const baselayers = this.baseLayers.getValue();
      const layers = this.layers.getValue();
      const overlays = this.overlays.getValue();
      let arr = [];
  
      if (layer.filtertype === 'Overlays') {
        arr = arr.concat(baselayers).concat(layers).concat(overlays);
        zIndex = arr.indexOf(layer);
      } else if (layer.filtertype === 'Layers') {
        arr = arr.concat(baselayers).concat(layers);
        zIndex = arr.indexOf(layer);
      } else if (layer.filtertype === 'Baselayers') {
        arr = arr.concat(baselayers);
        zIndex = arr.indexOf(layer);
      }
      return zIndex;
    }
    */
    filterOverlays() {
        const storeItems = this.store.getValue();
        const overlays = this.flattenDeepArray(storeItems.filter((layer) => layer.filtertype === 'Overlays'));
        return overlays;
    }
    filterBaseLayers() {
        const storeItems = this.store.getValue();
        const baselayers = this.flattenDeepArray(storeItems.filter((layer) => layer.filtertype === 'Baselayers'));
        return baselayers;
    }
    filterLayers() {
        const storeItems = this.store.getValue();
        const baselayers = this.flattenDeepArray(storeItems.filter((layer) => layer.filtertype === 'Layers'));
        return baselayers;
    }
    filterFiltertype(filtertype) {
        if (filtertype === 'Baselayers') {
            this.baseLayers.next(this.filterBaseLayers());
        }
        else if (filtertype === 'Overlays') {
            this.overlays.next(this.filterOverlays());
        }
        else if (filtertype === 'Layers') {
            this.layers.next(this.filterLayers());
        }
    }
    // ----------------------------------------------------------------------
    sortLayerGroup(layerGroup) {
        // fisrt sort in order to put vectors first and then rasterlayers
        layerGroup.layers.sort((a, b) => {
            let comparison = 0;
            if (a instanceof RasterLayer) {
                comparison = 1;
            }
            else if (b instanceof RasterLayer) {
                comparison = -1;
            }
            return comparison;
        });
        return layerGroup;
    }
}
LayersService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: LayersService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
LayersService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: LayersService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: LayersService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return []; } });

class LayersModule {
}
LayersModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: LayersModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
LayersModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: LayersModule });
LayersModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: LayersModule, providers: [LayersService], imports: [[]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: LayersModule, decorators: [{
            type: NgModule,
            args: [{
                    // components and directives of the module
                    declarations: [],
                    // which other modules are used
                    imports: [],
                    // components and directives of the module
                    exports: [],
                    // Most of the time, these are services that you create and provide
                    providers: [LayersService]
                }]
        }] });

/*
 * Public API Surface of services-layers
 */

/**
 * Generated bundle index. Do not edit.
 */

export { CustomLayer, CustomLayertype, Filtertypes, GeojsonLayertype, KmlLayertype, Layer, LayerGroup, LayersModule, LayersService, RasterLayer, StackedLayer, StackedLayertype, TmsLayertype, VectorLayer, WfsLayertype, WmsLayer, WmsLayertype, WmtsLayer, WmtsLayertype, XyzLayertype, isLayertype, isRasterLayer, isRasterLayertype, isVectorLayer, isVectorLayertype, isWmsLayer, isWmtsLayer };
//# sourceMappingURL=dlr-eoc-services-layers.mjs.map
