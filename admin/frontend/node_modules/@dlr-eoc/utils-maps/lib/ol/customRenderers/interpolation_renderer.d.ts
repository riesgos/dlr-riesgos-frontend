import { FrameState } from 'ol/PluggableMap';
import LayerRenderer from 'ol/renderer/Layer';
import VectorLayer from 'ol/layer/Vector';
import Geometry from 'ol/geom/Geometry';
import Point from 'ol/geom/Point';
import { Vector as VectorSource } from 'ol/source';
export declare type ColorRamp = {
    val: number;
    rgb: [number, number, number];
}[];
export interface InterpolationLayerOptions {
    source: VectorSource<Point>;
    renderSettings: InterpolationRendererSettings;
    [key: string]: any;
}
export interface InterpolationRendererSettings {
    /** maximum distance for interpolation */
    maxEdgeLength: number;
    power: number;
    /** `val`/`color` pairs. a given `color` is used for all values strictly smaller than `val`.  */
    colorRamp: ColorRamp;
    /** show a smooth color-gradient or isolines? */
    smooth: boolean;
    /** which feature-property should be interpolated? */
    valueProperty: string;
    showLabels: boolean;
    /** allows you to read out interpolated pixel values, but bad for performance */
    storeInterpolatedPixelData: boolean;
}
export declare class InterpolationLayer extends VectorLayer<VectorSource<Geometry>> {
    readonly options: InterpolationLayerOptions;
    constructor(options: InterpolationLayerOptions);
    createRenderer(): InterpolationRenderer;
    updateParas(power: number, smooth: boolean, showLabels: boolean): void;
}
/**
 * This renderer runs three shaders in a row.
 *  1. interpolationShader: takes every observation at every pixel and executes the interpolation. The values are stored in `valueFb`.
 *  2. colorizationShader: uses the interpolated values from valueFb to apply the colorization according to the given colorRamp and smoothing-options.
 *  3. arrangementShader: the previous shaders have moved the data in the center of the canvas. this shader now arranges the pixels to the correct position relative to the map.
 *
 * Only the third shader needs to be executed with every frame. This way, the operation-heavy interpolation does not slow down the map.
 * It generally makes sense to arrange shaders in such a way that all openlayers-perspective-operations occur in the last shader.
 *
 * valueFb is also being used to handle click events: from this structure we get the actual value at a pixel when the user clicks.
 *
 * Note a few caveats.
 * This implementation is not really intended for updating observations, maxEdgeLength or colorRamps at runtime. These parameters are rather intended for the developer to set once.
 * While you can change the color-ramp at runtime, it's length is hardcoded in the colorization shader, so you'd have to recompile it to properly reflect the new ramp.
 * In the same way, the interpolation-shader has the number of observations baked into it. When new data becomes available, you must recompile the interpolation shader.
 */
export declare class InterpolationRenderer extends LayerRenderer<VectorLayer<VectorSource<Geometry>>> {
    private settings;
    private container;
    private pointRenderer;
    private webGlCanvas;
    private gl;
    private interpolationShader;
    private valueFb;
    private colorizationShader;
    private colorFb;
    private arrangementShader;
    private interpolatedValues;
    private projection;
    private bbox;
    constructor(layer: VectorLayer<VectorSource<Geometry>>, settings: InterpolationRendererSettings);
    prepareFrame(frameState: FrameState): boolean;
    renderFrame(frameState: FrameState, target: HTMLElement): HTMLElement;
    renderDeclutter(frameState: FrameState): void;
    updateSettings(newSettings: InterpolationRendererSettings): void;
    /**
     * Called at every renderFrame. Fast.
     */
    private updateArrangementShader;
    /**
     * Called at every renderFrame. Fast.
     */
    private runArrangementShader;
    /**
     * Slow! Avoid calling this too often.
     */
    private updateInterpolationShader;
    /**
     * Slow! Avoid calling this too often.
     */
    private runInterpolationShader;
    /**
     * Slow! Avoid calling this too often.
     */
    private updateColorizationShader;
    /**
     * Slow! Avoid calling this too often.
     */
    private runColorizationShader;
    private parseData;
    private parseDataBbox;
}
