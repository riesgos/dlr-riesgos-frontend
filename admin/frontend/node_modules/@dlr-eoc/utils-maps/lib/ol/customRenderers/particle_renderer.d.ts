import { FrameState } from 'ol/PluggableMap';
import LayerRenderer from 'ol/renderer/Layer';
import VectorLayer from 'ol/layer/Vector';
import Geometry from 'ol/geom/Geometry';
import { Vector as VectorSource } from 'ol/source';
import { Shader, Framebuffer } from '../../webgl/engine.core';
export declare class WindFieldLayer extends VectorLayer<VectorSource<Geometry>> {
    constructor(options: any);
    createRenderer(): ParticleRenderer;
    startAnimation(fps: number): void;
}
/**
 * This renderer illustrates how WebGL can be used to to pixel-by-pixel calculations
 * that would be too expensive on a CPU but are easily done on a GPU.
 * In our shader we go through every pixel and calculate its new state from
 * its old state and that of it's environment.
 *
 * Note how similar in principle this is to Conway's Game of Life: one pixel's state is determined
 * by its surroundings from the time-step before.
 *
 * This renderer also illustrates another common technique in WebGL: `framebuffer-ping-pong`.
 * This is where the output of one shader is stored on a framebuffer and then passed to a subsequent shader.
 * With this, we can create a multi-step-pipeline, where each shader uses the previous
 * one's output as its own input.
 */
export declare class ParticleRenderer extends LayerRenderer<VectorLayer<VectorSource<Geometry>>> {
    readonly canvas: HTMLCanvasElement;
    readonly gl: WebGLRenderingContext;
    readonly interpolationShader: Shader;
    readonly particleShader: Shader;
    readonly textureMixShader: Shader;
    readonly interpolFb: Framebuffer;
    readonly particleFb1: Framebuffer;
    readonly particleFb2: Framebuffer;
    private fps;
    constructor(layer: VectorLayer<VectorSource<Geometry>>);
    /**
     * We could also have just started the animation right in the constructor.
     * Instead we created a separate `startAnimation` function so that it can optionally be run outside angular's zone,
     * preventing it from firing too many change cycles.
     * We leave this decision to the user, however, because it is not an ol-renderers duty to handle any angular-logic.
     */
    startAnimation(fps: number): void;
    stopAnimation(): void;
    prepareFrame(frameState: FrameState): boolean;
    renderFrame(frameState: FrameState, target: HTMLElement): HTMLElement;
    renderDeclutter(frameState: FrameState): void;
    private pointsToObservations;
}
