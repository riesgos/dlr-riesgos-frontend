import { Observable } from 'rxjs';
import { Layer, TFiltertypes } from './types/Layers';
import { LayerGroup } from './types/LayerGroup';
import * as i0 from "@angular/core";
export declare class LayersService {
    private store;
    private baseLayers;
    private overlays;
    private layers;
    constructor();
    /**
     * Adds a ukis Layer to the Layerservice Store
     * filtertype: TFiltertypes
     * if filtertype is not provided the filtertype of the Layer is used!
     *
     * if toGroup is true the layer is not added to the list of Layers and storeItems. Only used  internally.
     */
    addLayer(layer: Layer, filtertype?: TFiltertypes, toGroup?: boolean): void;
    /**
     * Removes a ukis Layer from the Layerservice Store
     * filtertype: TFiltertypes
     * if filtertype is not provided the filtertype of the Layer is used!
     *
     * force = true - removes a LayerGroup even it is not removable
     */
    removeLayer(layer: Layer, filtertype?: TFiltertypes, force?: boolean): void;
    private _removeLayer;
    /**
     * Updates a ukis Layer in the Layerservice Store
     * filtertype: TFiltertypes
     * if filtertype is not provided the filtertype of the Layer is used!
     */
    updateLayer(layer: Layer, filtertype?: TFiltertypes): void;
    private updateLayerOrGroupInStore;
    /**
     * Removes a ukis Layer or a LayerGroup from the Layerservice Store by the Layer.id or LayerGroup.id
     * if removeNullGroup is set, then it removes the LayerGroup if no layer is in there
     *
     * force = true - removes a LayerGroup even it is not removable
     */
    removeLayerOrGroupById(id: string, removeNullGroup?: boolean, force?: boolean): void;
    /**
     * Adds a ukis Layer to a LayerGroup in the Layerservice Store by providing the Layer and LayerGroup
     */
    addLayerToGroup(layer: Layer, layerGroup: LayerGroup): void;
    /**
     * Adds a ukis Layer to a LayerGroup in the Layerservice Store by providing the Layer and LayerGroup.id
     */
    addLayerToGroupById(layer: Layer, GroupId: string): void;
    /**
     * Removes a Layer from a LayerGroup in the Layerservice Store
     * By default if no layers on the group it will remove it - change this through set removeNullGroup to false
     *
     * force = true - removes the Layer even it is not removable
     */
    removeLayerFromGroup(layer: Layer, layergroup: LayerGroup, removeNullGroup?: boolean, force?: boolean): void;
    /**
     * Set the Layer Index in the Array of Layers in a LayerGroup
     * down == + 1 and up == - 1
     */
    setLayerIndexInGroup(layer: Layer, dir: 'up' | 'down', layerGroup: LayerGroup): void;
    /**
     * Adds a ukis LayerGroup to the Layerservice Store
     * filtertype: TFiltertypes
     * if filtertype is not provided the filtertype of the LayerGroup is used
     * All the Layers of the Group are set to filtertype of the Group
     */
    addLayerGroup(layergroup: LayerGroup, filtertype?: TFiltertypes): void;
    /**
     * Removes a ukis LayerGroup to the Layerservice Store
     * force = true - removes a LayerGroup even it is not removable
     */
    removeLayerGroup(layergroup: LayerGroup, force?: boolean): void;
    private _removeLayerGroup;
    /**
     * Updates a ukis LayerGroup to the Layerservice Store
     * if sort is set to true the layers of the Group are sort so vectors are above the rasterlayers
     */
    updateLayerGroup(layerGroup: LayerGroup, sort?: boolean): void;
    /**
     * Moves a Item in an Array to another Index
     */
    arrayMove(array: Array<any>, fromIndex: number, toIndex: number): void;
    /**
     * Set Group Or Layer Index in the Layerservice Store
     * down == index + 1 and up == index - 1
     */
    setGroupLayerIndex(group: Layer | LayerGroup, dir: number | 'up' | 'down'): void;
    /**
     * Get the Number of Items from Layerservice Store filtered by filtertype
     * filtertype: TFiltertypes
     */
    getNumOfGroups(filtertype: TFiltertypes): number;
    /**
     * Check if a Layer or LayerGroup is on index 0 of the Layerservice Store or the provided Array
     * if filtertype is set it only uses the items with this type
     * filtertype?: TFiltertypes
     */
    isGroupFirst(group: Layer | LayerGroup, lgroups?: Array<Layer | LayerGroup>, filtertype?: TFiltertypes): boolean;
    /**
     * Check if a Layer or LayerGroup is on index (length - 1) of the Layerservice Store or the provided Array
     * if filtertype is set it only uses the items with this type
     * filtertype?: TFiltertypes
     */
    isGroupLast(group: Layer | LayerGroup, lgroups?: Array<Layer | LayerGroup>, filtertype?: TFiltertypes): boolean;
    /**
     * Check if a Layer or LayerGroup is in the Layerservice Store (or the provided Array) by their ID
     */
    isInLayergroups(layergroup: Layer | LayerGroup | string, groups?: Array<Layer | LayerGroup>): boolean;
    /**
     * Get a Layer or LayerGroup by ID from the Layerservice Store (or the provided Array)
     * normal there should only be returned one or zero items in the array otherwise there is a duplicate ID in the Layer Groups!!
     */
    getLayerOrGroupById(id: string, groups?: Array<Layer | LayerGroup>): Layer | LayerGroup;
    /**
     * Get a Layer by ID from the Layerservice Store (or the provided Array)
     */
    getLayerById(id: string, layers?: Array<Layer>): Layer;
    /**
     * Get all Layers with filterrype 'Baselayers' from the Layerservice Store
     */
    getBaseLayers(): Observable<Layer[]>;
    /**
     * Removes Layers with filtertype 'Baselayers' from the Layerservice Store
     * Filter is a function to exclude layers
     */
    removeBaseLayers(filter?: (value: Layer, index: number, array: Layer[]) => any): Observable<Layer[]>;
    getBaseLayersCount(): number;
    /**
     * Get all Layers with filterrype 'Overlays' from the Layerservice Store
     */
    getOverlays(): Observable<Layer[]>;
    /**
     * Removes Layers with filtertype 'Overlays' from the Layerservice Store
     * Filter is a function to exclude layers
     */
    removeOverlays(filter?: (value: Layer, index: number, array: Layer[]) => any): Observable<Layer[]>;
    getOverlaysCount(): number;
    /**
     * Get all Layers with filterrype 'Layers' from the Layerservice Store
     *
     * #### to filter the Observable only on some layer property changes use rxjs filter e.g. see below:
     * this.layersSub = this.layerSvc.getLayers().pipe(filter(layers => {
     *   const newVisible = layers.map(l => l.visible).filter(v => v === true).length;
     *  // subscribe if visible of a layer has changed
     *  if (newVisible !== this.oldVisibleLayers) {
     *     return true;
     *  } else {
     *     // subscribe only to remove, add layers
     *     if (this.layers && this.layers.length !== layers.length) {
     *       return true;
     *    } else {
     *       return false;
     *    }
     *  }
     * })).subscribe(layers => {
     *   this.layers = layers;
     *   this.oldVisibleLayers = this.layers.map(l => l.visible).filter(v => v === true).length;
     * });
     */
    getLayers(): Observable<Layer[]>;
    /**
     * Removes Layers with filtertype 'Layers' from the Layerservice Store
     * Filter is a function to exclude layers
     */
    removeLayers(filter?: (value: Layer, index: number, array: Layer[]) => any): Observable<Layer[]>;
    getLayersCount(): number;
    /**
     * Get all storeItems from the Layerservice
     */
    getLayerGroups(): Observable<Array<Layer | LayerGroup>>;
    /**
     * Set (Reset) all storeItems from the Layerservice
     * if filtertype is set then only the slot is used
     */
    setLayerGroups(items: Array<Layer | LayerGroup>, filtertype?: TFiltertypes): Observable<Array<Layer | LayerGroup>>;
    /**
     * Get the Count of all storeItems
     */
    getLayerGroupsCount(): number;
    /**
     * flatten array with Layers and LayerGroups.layers (so you can get the zIndex)
     */
    flattenDeepArray(arr: Array<Layer | LayerGroup>): Layer[];
    private filterOverlays;
    private filterBaseLayers;
    private filterLayers;
    private filterFiltertype;
    private sortLayerGroup;
    static ɵfac: i0.ɵɵFactoryDeclaration<LayersService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<LayersService>;
}
