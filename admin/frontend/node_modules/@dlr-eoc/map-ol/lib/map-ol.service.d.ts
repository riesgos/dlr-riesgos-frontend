import { ComponentFactoryResolver, ApplicationRef, Injector } from '@angular/core';
import { Layer, popup, TGeoExtent } from '@dlr-eoc/services-layers';
import olMap from 'ol/Map';
import olView from 'ol/View';
import olBaseLayer from 'ol/layer/Base';
import olLayer from 'ol/layer/Layer';
import olOverlay from 'ol/Overlay';
import olVectorSource from 'ol/source/Vector';
import olFeature from 'ol/Feature';
import olProjection from 'ol/proj/Projection';
import { Options as olProjectionOptions } from 'ol/proj/Projection';
import { DragBox } from 'ol/interaction';
import olMapBrowserEvent from 'ol/MapBrowserEvent';
import olRenderFeature from 'ol/render/Feature';
import olEvent from 'ol/events/Event';
import { Options as DragBoxOptions } from 'ol/interaction/DragBox';
import { Subject } from 'rxjs';
import * as i0 from "@angular/core";
export declare type Tgroupfiltertype = 'baselayers' | 'layers' | 'overlays' | 'Baselayers' | 'Overlays' | 'Layers';
/**
 * While @dlr-eoc/services-layers.popup already contains instructions about how to build a popup,
 * IPopupArgs adds additional, map-ol-specific context like the olLayer, the feature, and the olMapBrowserEvent.
 */
export interface IPopupArgs {
    modelName: string;
    properties: popup['properties'];
    layer: olLayer<any>;
    feature?: olFeature<any> | olRenderFeature;
    event: olMapBrowserEvent<PointerEvent>;
    popupFn?: popup['popupFunction'];
    dynamicPopup?: popup['dynamicPopup'];
}
export interface IDynamicPopupArgs {
    properties: popup['properties'];
    layer: IPopupArgs['layer'];
    feature?: IPopupArgs['feature'];
    event: olMapBrowserEvent<PointerEvent>;
    dynamicPopup: popup['dynamicPopup'];
}
export declare class MapOlService {
    private crf;
    private app;
    private injector;
    map: olMap;
    view: olView;
    private viewOptions;
    EPSG: string;
    private hitTolerance;
    private hitLayerCurr;
    private hitLayerPrev;
    /** 'olProjection' */
    projectionChange: Subject<olProjection>;
    /**
     * This object keeps track of currently bound angular-components that are being used as popups.
     * We keep a reference to them here so that we can remove them again after they are no longer displayed.
     */
    private dynamicPopupComponents;
    constructor(crf: ComponentFactoryResolver, app: ApplicationRef, injector: Injector);
    /**
     * if this is used in an angular component then set the target after the view is created
     * e.g. this.map.setTarget(this.mapDivView.nativeElement) in ngAfterViewInit()
     */
    createMap(target?: HTMLElement): {
        map: olMap;
        view: olView;
    };
    setHitTolerance(tolerance: number): void;
    getHitTolerance(): number;
    /**
     * See this example:
     * https://openlayers.org/en/latest/examples/box-selection.html
     */
    addBboxSelection(conditionForDrawing: (evt: any) => boolean, onBoxStart?: (evt: olEvent) => void, onBoxEnd?: (ext: any, evt: olEvent) => void, dragBoxOptions?: DragBoxOptions): DragBox;
    /**
     * get an array of olLayers from a group type
     */
    getLayers(filtertype: Tgroupfiltertype): olBaseLayer[];
    private getLayersFromGroup;
    getLayerByKey(key: {
        key: string;
        value: string;
    }, filtertype?: Tgroupfiltertype): olBaseLayer;
    /**
     * set a FilterType to a Layer or Group recursively
     *
     * @param key [key='filtertype']
     */
    private setRecursiveKey;
    /**
     * add a olLayer to a group if it is not there
     */
    addLayer(layer: olBaseLayer, filtertype: Tgroupfiltertype): any;
    private isLayerInGroup;
    /**
      * Get all direkt Layer Groups added to the map
      *
      * @param filtertypeKey [filtertypeKey='filtertype']
      */
    private getLayerGroups;
    /**
     * add a array of olLayers to a group if they are not there
     */
    addLayers(layers: olBaseLayer[], filtertype: Tgroupfiltertype): olBaseLayer[];
    /**
     * reset a group with an array of olLayers
     */
    setLayers(layers: olBaseLayer[], filtertype: Tgroupfiltertype): olBaseLayer[];
    /**
     * Clean up event listeners from layers and sources
     *
     * TODO: is this needed? when layers or sources are removed, then there is no Target anymore which listens for events?
     * there are also other functions like removeLayerByKey(), removeAllLayers()
     */
    private cleanUpEventListeners;
    /**
     * on() and un() are functions of olObservable which extends EventTarget
     *
     * https://github.com/openlayers/openlayers/blob/v6.5.0/src/ol/events/Target.js#L145
     * https://github.com/openlayers/openlayers/blob/v6.5.0/src/ol/events/Target.js#L134
     */
    private addEventsToLayer;
    /** TODO: try to remove/replace this function - Property 'disposeInternal' is protected ol function */
    private removeListenersFromOldLayers;
    /**
     * get corresponding Layer Group on which the layer is added
     */
    private getLayerGroupForLayer;
    removeLayerByKey(key: {
        key: string;
        value: string;
    }, filtertype: Tgroupfiltertype): void;
    updateLayerByKey(key: {
        key: string;
        value: string;
    }, newLayer: olBaseLayer, filtertype: Tgroupfiltertype): void;
    removeAllLayers(filtertype: Tgroupfiltertype): void;
    /**
     * This function resets/adds all olLayers of a type with the new UKIS-Layers
     *
     * if only one group of them map is used and setLayers is called then the map flickers!
     * this is because all layers are newly created and each get new ol_uid's
     */
    setUkisLayers(layers: Array<Layer>, filtertype: Tgroupfiltertype): {
        type: Tgroupfiltertype;
        layers: olBaseLayer[];
    };
    /** This function resets/adds a olLayer of a type with the new UKIS-Layer */
    setUkisLayer(newLayer: Layer, filtertype?: Tgroupfiltertype): void;
    updateUkisLayer(newLayer: Layer, filtertype?: Tgroupfiltertype): void;
    private create_layers;
    /**
     * create layeroptions olLayerOptions<OptionSources> & ILayerOptions
     * - id
     * - name
     * - filtertype
     * - type
     * - legendImg
     * - visible
     * - zIndex
     * - opacity
     * - attribution
     * - continuousWorld
     * - set crossOrigin for popup layers
     * - set source on layeroptions
     * - popup
     * - maxResolution/minResolution
     * - maxZoom/minZoom
     * - bbox
     */
    private createOlLayerOptions;
    /**
     * define layer types
     */
    /**
     * https://openlayers.org/en/latest/apidoc/module-ol_layer_Tile-TileLayer.html
     * https://openlayers.org/en/latest/apidoc/module-ol_source_XYZ-XYZ.html
     */
    private create_xyz_layer;
    /**
     * create_xyz_layer for Raster
     *
     * or
     *
     * https://openlayers.org/en/latest/apidoc/module-ol_layer_VectorTile-VectorTileLayer.html
     * https://openlayers.org/en/latest/apidoc/module-ol_source_VectorTile-VectorTile.html
     * https://openlayers.org/en/latest/apidoc/module-ol_format_MVT-MVT.html
     */
    private create_tms_layer;
    private create_wms_layer;
    /**
     * https://openlayers.org/en/latest/apidoc/module-ol_layer_Tile-TileLayer.html
     * https://openlayers.org/en/latest/apidoc/module-ol_source_TileWMS-TileWMS.html
     */
    private create_tiled_wms_layer;
    /**
     * https://openlayers.org/en/latest/apidoc/module-ol_layer_Image-ImageLayer.html
     * https://openlayers.org/en/latest/apidoc/module-ol_source_ImageWMS-ImageWMS.html
     */
    private create_image_wms_layer;
    /**
     * https://openlayers.org/en/latest/apidoc/module-ol_layer_Tile-TileLayer.html
     * https://openlayers.org/en/latest/apidoc/module-ol_source_WMTS-WMTS.html
     */
    private create_wmts_layer;
    /**
     * check projects/demo-maps/src/app/route-components/route-example-olperformance/services/largelayers.service.ts
     * for WFS examples.
     *
     * https://openlayers.org/en/latest/apidoc/module-ol_layer_Vector-VectorLayer.html
     * https://openlayers.org/en/latest/apidoc/module-ol_source_Vector-VectorSource.html
     */
    private create_wfs_layer;
    /**
     * https://openlayers.org/en/latest/apidoc/module-ol_layer_Vector-VectorLayer.html
     * https://openlayers.org/en/latest/apidoc/module-ol_source_Vector-VectorSource.html
     * https://openlayers.org/en/latest/apidoc/module-ol_format_GeoJSON-GeoJSON.html
     */
    private create_geojson_layer;
    /**
     * https://openlayers.org/en/latest/apidoc/module-ol_layer_Vector-VectorLayer.html
     * https://openlayers.org/en/latest/apidoc/module-ol_source_Vector-VectorSource.html
     * https://openlayers.org/en/latest/apidoc/module-ol_format_KML-KML.html
     */
    private create_kml_layer;
    /** bug fix: https://github.com/openlayers/openlayers/issues/10099 */
    private setCrossOrigin;
    /**
     * set cluster source and style for point layers
     */
    private setCluster;
    /** use subdomains to setUrl/s on source */
    private setSubdomains;
    private sourceSetCross;
    /**
     * Use this Layer to add a not supported OpenLayers layer
     *
     * custom_layer: olBaseLayer
     */
    private create_custom_layer;
    /**
     * Use this Layer to stack multiple ukis layers in one.
     * creates a olLayerGroup from create_layers
     */
    private create_stacked_layer;
    private resolutionsFromExtent;
    private matrixIdsFromResolutions;
    getTileGrid<T>(type?: 'wmts' | 'default', resolutionLevels?: number, tileSize?: number, matrixIdPrefix?: string, resolutions?: Array<string | number>, matrixIds?: Array<string | number>): T;
    private isPopupObj;
    private isPopupObjMove;
    private isPopupObjClick;
    private isPopupObjArray;
    private isPopupStringArray;
    private eventIsBrowserEvent;
    /** USED in map-ol.component */
    /**
     * TODO:
     * - check the pointer event
     * - on move event set cursor -> depends on which kind of layer??
     *   layers with features and only color pixel
     *
     * - forEachFeatureAtPixel: Detect features that intersect a pixel on the viewport
     *   Vector Layers???
     *
     * - forEachLayerAtPixel: Detect layers that have a color value at a pixel on the viewport (false positives unless the map layers have had different className)
     *   Raster Layers???
     */
    /**
     *  layers_on_click() and layers_on_pointermove() should be removed
     *  this filtering must be done later
     *
     *  1. on a Map event Filter if map has layers on the pixel
     *  forEachLayerAtPixel: Detect layers that have a color value at a pixel on the viewport (false positives unless the map layers have had different className)
     *  check layer source crossOrigin = anonymous
     *
     *  2. Filter if it is the top visible layer - so no popups are shown for layers beneath https://github.com/dlr-eoc/ukis-frontend-libraries/issues/94#issuecomment-916759628
     *  3. check if the top visible layer has a popup property
     *  4. For this Layer change the cursor on forEachLayerAtPixel -> hit
     *
     *  5. Differentiate between raster and vector to get features or layer.color for the properties passed to the popup
     *  For Features change the cursor on forEachFeatureAtPixel -> hit
     *
     *  6. limit properties if popup property is: Array<string> | popup | popup[] -> popup?.filterkeys
     *  7. overwrite properties if popup property is: popup | popup[]
     *  8. check for popupFunction, asyncPopup and dynamicPopup
     *  9. use addPopup() or addPopupObj()
     *
     *  10. check popup event and if move popup exists => reuse old popup
     *  11. remove move popups if different event or !popup.event
     *  12. create new popup if not 10. or 11.
     *  13. prepare ol overlayoptions
     *  14. remove DynamicPopup if exists
     *  15. createPopupContainer
     *  16. set ol overlay addEvent and type = popup
     *  17. get coordinate from geometry or map.event
     *  18. set Position and map.addOverlay(overlay) if popup not exists
     */
    layersOnMapEvent(evt: olMapBrowserEvent<PointerEvent>): void;
    /**
     * To filtered out layers and show the popup beneath e.g. text overlays
     * in map.forEachLayerAtPixel for raster and map.forEachFeatureAtPixel for vector
     */
    private filterLayerNoPopup;
    private topLayerCheckEvent;
    /**
     * https://openlayers.org/en/latest/apidoc/module-ol_layer_Layer-Layer.html#Subclasses
     */
    private checkIsRaster;
    /**
     * https://openlayers.org/en/latest/apidoc/module-ol_layer_Layer-Layer.html#Subclasses
     */
    private checkIsVector;
    layerOnEvent(evt: olMapBrowserEvent<PointerEvent>, layer: olLayer<any>, color?: Uint8ClampedArray | Uint8Array): void;
    vectorOnEvent(evt: olMapBrowserEvent<PointerEvent>): boolean;
    rasterOnEvent(evt: olMapBrowserEvent<PointerEvent>, layer: olLayer<any>, color?: Uint8ClampedArray | Uint8Array): void;
    private prepareAddPopup;
    addPopup(args: IPopupArgs, popupObj: any, html?: string, event?: 'click' | 'move', removePopups?: boolean): void;
    private createPopupContainer;
    /** USED in map-ol.component */
    removeAllPopups(filter?: (item: olOverlay) => boolean): void;
    createPopupHtml(obj: any): string;
    getPopups(): olOverlay[];
    /**
     * Destroys a popup-component.
     *  - kills the component (with `.destroy()`)
     *  - detaches it from angular-application (with `.destroy()`)
     *  - removes the entry from `this.dynamicPopupComponents`
     * @param id : The string under which the popup-component has been stored in `this.dynamicPopupComponents`
     */
    private destroyDynamicPopupComponent;
    /**
     * Creates an angular component to be used as popup-body.
     *  - creates component
     *  - attaches component-view to angular-application
     *  - keeps reference to component in `this.dynamicPopupComponents` for later removal.
     *
     * @param id : The container-id. Also the id under which the component will be stored in `this.dynamicPopupComponents`.
     * @param anchorElement : The html-element to which the popup-component shall be attached
     * @param args : Must contain `dynamicPopup`
     */
    private createDynamicPopupComponent;
    /**
     *
     * @param extent: [minX, minY, maxX, maxY]
     * @param geographic: boolean
     * @param fitOptions: olFitOptions
     * @returns olExtend: [minX, minY, maxX, maxY]
     */
    setExtent(extent: TGeoExtent, geographic?: boolean, fitOptions?: any): TGeoExtent;
    /** USED in map-ol.component */
    /** ol.Coordinate xy */
    setCenter(center: number[], geographic?: boolean): number[];
    /** USED in map-ol.component */
    getCenter(geographic?: boolean): any;
    /**
     *
     * @param features: olFeature[]
     * @param geographic: boolean
     * @returns olExtend: [minX, minY, maxX, maxY]
     */
    getFeaturesExtent(features: olFeature<any>[], geographic?: boolean): TGeoExtent;
    /** USED in map-ol.component */
    /**
     * @param geographic: boolean
     * @returns olExtend: [minX, minY, maxX, maxY]
     */
    getCurrentExtent(geographic?: boolean): TGeoExtent;
    /** USED in map-ol.component */
    setZoom(zoom: number, notifier?: 'map' | 'user'): void;
    /** USED in map-ol.component */
    getZoom(): number;
    zoomInOut(value: '-' | '+'): void;
    geoJsonToFeature(geojson: any): olFeature<any>;
    geoJsonToFeatures(geojson: any): Array<olFeature<any>>;
    /**
     * @returns 'olProjection'
     */
    getProjection(): olProjection;
    /**
     * function to reproject vector features
     * @param source:  olVectorSource
     * @param srcProj: string (e.g. 'EPSG:4326')
     * @param dstProj: string (e.g. 'EPSG:3857')
     */
    reprojectFeatures(source: olVectorSource<any>, srcProj: string, dstProj: string): void;
    /**
     * vector layers will be reprojected automatically
     * wms layers will be updated with corresponding proj def in the requests.
     * for other raster layers and for those wms layers which backend does not support target projection, please
     * define initial(default) layer projection, so openlayers will reproject on the client side
     * projection is proj~ProjectionLike
     */
    setProjection(projection: olProjection | string): void;
    /**
     * @param projDef.code - e.g.: "EPSG:4326"
     * @param projDef.proj4js - e.g.: "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"
     */
    registerProjection(projDef: {
        code: string;
        proj4js: string;
    }): void;
    /**
     * Returns a OpenLayers Projection from Options
     */
    getOlProjection(projDef: olProjectionOptions): olProjection;
    private keysToUppercase;
    static ɵfac: i0.ɵɵFactoryDeclaration<MapOlService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<MapOlService>;
}
