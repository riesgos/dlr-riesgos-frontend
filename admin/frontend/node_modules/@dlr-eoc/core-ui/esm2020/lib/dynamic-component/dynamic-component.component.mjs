import { Component, ViewChild, Input, EventEmitter, Directive, Output } from '@angular/core';
import * as i0 from "@angular/core";
export class ViewRefDirective {
    constructor(viewContainerRef) {
        this.viewContainerRef = viewContainerRef;
    }
}
ViewRefDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ViewRefDirective, deps: [{ token: i0.ViewContainerRef }], target: i0.ɵɵFactoryTarget.Directive });
ViewRefDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.6", type: ViewRefDirective, selector: "[ukisAddHost]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ViewRefDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ukisAddHost]',
                }]
        }], ctorParameters: function () { return [{ type: i0.ViewContainerRef }]; } });
export class DynamicComponentComponent {
    constructor(componentFactoryResolver) {
        this.componentFactoryResolver = componentFactoryResolver;
        this.dynamicComponentChange = new EventEmitter();
    }
    loadComponent() {
        if (this.dynamicComponent) {
            this.subs = [];
            const componentFactory = this.componentFactoryResolver.resolveComponentFactory(this.dynamicComponent.component);
            const viewContainerRef = this.ukisAddHost.viewContainerRef;
            viewContainerRef.clear();
            this.componentRef = viewContainerRef.createComponent(componentFactory);
            this.setInputOutputs();
        }
    }
    /**
     * Set's the inputs defined in IDynamicComponent
     *
     * To subscribe to the outputs of the IDynamicComponent.component use '<name>Change' as output name in your component.
     * e.g.
     * @Input() set value()...
     *          get value()...
     * @Output() valueChange = new EventEmitter<number>();
     *
     *
     * To reset the Inputs after ngOnInit, change to Object binding for the input 'dynamicComponent' in the parent which creates the dynamic component.
     * e.g.
     * this.Comp.inputs.test = 'value';
     * CustomLayer.action = this.Comp = Object.assign({}, this.Comp);
     */
    setInputOutputs() {
        if (this.componentRef && this.dynamicComponent.inputs) {
            const inputs = Object.keys(this.dynamicComponent.inputs);
            inputs.map(i => {
                const inputname = i;
                if (this.dynamicComponent.inputs) {
                    this.componentRef.instance[inputname] = this.dynamicComponent.inputs[inputname];
                    const outupName = `${inputname}Change`;
                    /** subscribe to output for same name as input */
                    if (this.componentRef.instance[outupName] && this.componentRef.instance[outupName] instanceof EventEmitter) {
                        const sub = this.componentRef.instance[outupName].subscribe((val) => {
                            if (this.dynamicComponent.inputs) {
                                this.dynamicComponent.inputs[inputname] = val;
                                /** if outputs are defined on IDynamicComponent pass the value to there functions */
                            }
                            if (this.dynamicComponent.outputs) {
                                if (this.dynamicComponent.outputs[outupName]) {
                                    this.dynamicComponent.outputs[outupName](val);
                                }
                            }
                            this.dynamicComponentChange.emit(this.dynamicComponent);
                        });
                        this.subs.push(sub);
                    }
                }
            });
        }
    }
    ngOnChanges(changes) {
        if (changes.dynamicComponent) {
            if (Array.isArray(this.subs)) {
                this.subs.map(s => s.unsubscribe());
            }
            this.setInputOutputs();
        }
    }
    ngOnInit() {
        this.loadComponent();
    }
    ngOnDestroy() {
        if (this.componentRef) {
            this.subs.map(s => s.unsubscribe());
            this.componentRef.destroy();
            this.componentRef = null;
        }
    }
}
DynamicComponentComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: DynamicComponentComponent, deps: [{ token: i0.ComponentFactoryResolver }], target: i0.ɵɵFactoryTarget.Component });
DynamicComponentComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.6", type: DynamicComponentComponent, selector: "ukis-dynamic-component", inputs: { dynamicComponent: "dynamicComponent" }, outputs: { dynamicComponentChange: "dynamicComponentChange" }, viewQueries: [{ propertyName: "ukisAddHost", first: true, predicate: ViewRefDirective, descendants: true, static: true }], usesOnChanges: true, ngImport: i0, template: `<ng-template ukisAddHost></ng-template>`, isInline: true, directives: [{ type: ViewRefDirective, selector: "[ukisAddHost]" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: DynamicComponentComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'ukis-dynamic-component',
                    template: `<ng-template ukisAddHost></ng-template>`
                }]
        }], ctorParameters: function () { return [{ type: i0.ComponentFactoryResolver }]; }, propDecorators: { dynamicComponent: [{
                type: Input
            }], dynamicComponentChange: [{
                type: Output
            }], ukisAddHost: [{
                type: ViewChild,
                args: [ViewRefDirective, { static: true }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHluYW1pYy1jb21wb25lbnQuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvY29yZS11aS9zcmMvbGliL2R5bmFtaWMtY29tcG9uZW50L2R5bmFtaWMtY29tcG9uZW50LmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUFVLFNBQVMsRUFBcUQsS0FBSyxFQUN0RixZQUFZLEVBQUUsU0FBUyxFQUEwQixNQUFNLEVBQ3hELE1BQU0sZUFBZSxDQUFDOztBQWF2QixNQUFNLE9BQU8sZ0JBQWdCO0lBQzNCLFlBQW1CLGdCQUFrQztRQUFsQyxxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQWtCO0lBQUksQ0FBQzs7NkdBRC9DLGdCQUFnQjtpR0FBaEIsZ0JBQWdCOzJGQUFoQixnQkFBZ0I7a0JBSDVCLFNBQVM7bUJBQUM7b0JBQ1QsUUFBUSxFQUFFLGVBQWU7aUJBQzFCOztBQVNELE1BQU0sT0FBTyx5QkFBeUI7SUFPcEMsWUFBb0Isd0JBQWtEO1FBQWxELDZCQUF3QixHQUF4Qix3QkFBd0IsQ0FBMEI7UUFMNUQsMkJBQXNCLEdBQUcsSUFBSSxZQUFZLEVBQXFCLENBQUM7SUFLQyxDQUFDO0lBRTNFLGFBQWE7UUFDWCxJQUFJLElBQUksQ0FBQyxnQkFBZ0IsRUFBRTtZQUN6QixJQUFJLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztZQUNmLE1BQU0sZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLHdCQUF3QixDQUFDLHVCQUF1QixDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUNoSCxNQUFNLGdCQUFnQixHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsZ0JBQWdCLENBQUM7WUFDM0QsZ0JBQWdCLENBQUMsS0FBSyxFQUFFLENBQUM7WUFDekIsSUFBSSxDQUFDLFlBQVksR0FBRyxnQkFBZ0IsQ0FBQyxlQUFlLENBQUMsZ0JBQWdC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MkZBUWhCLHlCQUF5QjtrQkFKckMsU0FBUzttQkFBQztvQkFDVCxRQUFRLEVBQUUsd0JBQXdCO29CQUNsQyxRQUFRLEVBQUUseUNBQXlDO2lCQUNwRDsrR0FFVSxnQkFBZ0I7c0JBQXhCLEtBQUs7Z0JBQ0ksc0JBQXNCO3NCQUEvQixNQUFNO2dCQUN3QyxXQUFXO3NCQUF6RCxTQUFTO3VCQUFDLGdCQUFnQixFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENvbXBvbmVudCwgT25Jbml0LCBWaWV3Q2hpbGQsIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgQ29tcG9uZW50UmVmLCBPbkRlc3Ryb3ksIElucHV0LCBTaW1wbGVDaGFuZ2VzLCBPbkNoYW5nZXMsXG4gIEV2ZW50RW1pdHRlciwgRGlyZWN0aXZlLCBWaWV3Q29udGFpbmVyUmVmLCBUeXBlLCBPdXRwdXRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuXG5leHBvcnQgaW50ZXJmYWNlIElEeW5hbWljQ29tcG9uZW50IHtcbiAgY29tcG9uZW50OiBUeXBlPGFueT47XG4gIGlucHV0cz86IHsgW2lucHV0OiBzdHJpbmddOiBhbnkgfTtcbiAgb3V0cHV0cz86IHsgW2lucHV0Q2hhbmdlOiBzdHJpbmddOiAodmFsdWU6IGFueSkgPT4gdm9pZCB9O1xufVxuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbdWtpc0FkZEhvc3RdJyxcbn0pXG5leHBvcnQgY2xhc3MgVmlld1JlZkRpcmVjdGl2ZSB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyB2aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmKSB7IH1cbn1cblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAndWtpcy1keW5hbWljLWNvbXBvbmVudCcsXG4gIHRlbXBsYXRlOiBgPG5nLXRlbXBsYXRlIHVraXNBZGRIb3N0PjwvbmctdGVtcGxhdGU+YFxufSlcbmV4cG9ydCBjbGFzcyBEeW5hbWljQ29tcG9uZW50Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3ksIE9uQ2hhbmdlcyB7XG4gIEBJbnB1dCgpIGR5bmFtaWNDb21wb25lbnQhOiBJRHluYW1pY0NvbXBvbmVudDtcbiAgQE91dHB1dCgpIGR5bmFtaWNDb21wb25lbnRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPElEeW5hbWljQ29tcG9uZW50PigpO1xuICBAVmlld0NoaWxkKFZpZXdSZWZEaXJlY3RpdmUsIHsgc3RhdGljOiB0cnVlIH0pIHVraXNBZGRIb3N0ITogVmlld1JlZkRpcmVjdGl2ZTtcblxuICBjb21wb25lbnRSZWYhOiBDb21wb25lbnRSZWY8YW55PjtcbiAgc3VicyE6IFN1YnNjcmlwdGlvbltdO1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcjogQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyKSB7IH1cblxuICBsb2FkQ29tcG9uZW50KCkge1xuICAgIGlmICh0aGlzLmR5bmFtaWNDb21wb25lbnQpIHtcbiAgICAgIHRoaXMuc3VicyA9IFtdO1xuICAgICAgY29uc3QgY29tcG9uZW50RmFjdG9yeSA9IHRoaXMuY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KHRoaXMuZHluYW1pY0NvbXBvbmVudC5jb21wb25lbnQpO1xuICAgICAgY29uc3Qgdmlld0NvbnRhaW5lclJlZiA9IHRoaXMudWtpc0FkZEhvc3Qudmlld0NvbnRhaW5lclJlZjtcbiAgICAgIHZpZXdDb250YWluZXJSZWYuY2xlYXIoKTtcbiAgICAgIHRoaXMuY29tcG9uZW50UmVmID0gdmlld0NvbnRhaW5lclJlZi5jcmVhdGVDb21wb25lbnQoY29tcG9uZW50RmFjdG9yeSk7XG4gICAgICB0aGlzLnNldElucHV0T3V0cHV0cygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQncyB0aGUgaW5wdXRzIGRlZmluZWQgaW4gSUR5bmFtaWNDb21wb25lbnRcbiAgICpcbiAgICogVG8gc3Vic2NyaWJlIHRvIHRoZSBvdXRwdXRzIG9mIHRoZSBJRHluYW1pY0NvbXBvbmVudC5jb21wb25lbnQgdXNlICc8bmFtZT5DaGFuZ2UnIGFzIG91dHB1dCBuYW1lIGluIHlvdXIgY29tcG9uZW50LlxuICAgKiBlLmcuXG4gICAqIEBJbnB1dCgpIHNldCB2YWx1ZSgpLi4uXG4gICAqICAgICAgICAgIGdldCB2YWx1ZSgpLi4uXG4gICAqIEBPdXRwdXQoKSB2YWx1ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuICAgKlxuICAgKlxuICAgKiBUbyByZXNldCB0aGUgSW5wdXRzIGFmdGVyIG5nT25Jbml0LCBjaGFuZ2UgdG8gT2JqZWN0IGJpbmRpbmcgZm9yIHRoZSBpbnB1dCAnZHluYW1pY0NvbXBvbmVudCcgaW4gdGhlIHBhcmVudCB3aGljaCBjcmVhdGVzIHRoZSBkeW5hbWljIGNvbXBvbmVudC5cbiAgICogZS5nLlxuICAgKiB0aGlzLkNvbXAuaW5wdXRzLnRlc3QgPSAndmFsdWUnO1xuICAgKiBDdXN0b21MYXllci5hY3Rpb24gPSB0aGlzLkNvbXAgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLkNvbXApO1xuICAgKi9cbiAgc2V0SW5wdXRPdXRwdXRzKCkge1xuICAgIGlmICh0aGlzLmNvbXBvbmVudFJlZiAmJiB0aGlzLmR5bmFtaWNDb21wb25lbnQuaW5wdXRzKSB7XG4gICAgICBjb25zdCBpbnB1dHMgPSBPYmplY3Qua2V5cyh0aGlzLmR5bmFtaWNDb21wb25lbnQuaW5wdXRzKTtcbiAgICAgIGlucHV0cy5tYXAoaSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0bmFtZSA9IGk7XG4gICAgICAgIGlmICh0aGlzLmR5bmFtaWNDb21wb25lbnQuaW5wdXRzKSB7XG4gICAgICAgICAgdGhpcy5jb21wb25lbnRSZWYuaW5zdGFuY2VbaW5wdXRuYW1lXSA9IHRoaXMuZHluYW1pY0NvbXBvbmVudC5pbnB1dHNbaW5wdXRuYW1lXTtcbiAgICAgICAgICBjb25zdCBvdXR1cE5hbWUgPSBgJHtpbnB1dG5hbWV9Q2hhbmdlYDtcbiAgICAgICAgICAvKiogc3Vic2NyaWJlIHRvIG91dHB1dCBmb3Igc2FtZSBuYW1lIGFzIGlucHV0ICovXG4gICAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50UmVmLmluc3RhbmNlW291dHVwTmFtZV0gJiYgdGhpcy5jb21wb25lbnRSZWYuaW5zdGFuY2Vbb3V0dXBOYW1lXSBpbnN0YW5jZW9mIEV2ZW50RW1pdHRlcikge1xuICAgICAgICAgICAgY29uc3Qgc3ViID0gdGhpcy5jb21wb25lbnRSZWYuaW5zdGFuY2Vbb3V0dXBOYW1lXS5zdWJzY3JpYmUoKHZhbDogYW55KSA9PiB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmR5bmFtaWNDb21wb25lbnQuaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5keW5hbWljQ29tcG9uZW50LmlucHV0c1tpbnB1dG5hbWVdID0gdmFsO1xuICAgICAgICAgICAgICAgIC8qKiBpZiBvdXRwdXRzIGFyZSBkZWZpbmVkIG9uIElEeW5hbWljQ29tcG9uZW50IHBhc3MgdGhlIHZhbHVlIHRvIHRoZXJlIGZ1bmN0aW9ucyAqL1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0aGlzLmR5bmFtaWNDb21wb25lbnQub3V0cHV0cykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmR5bmFtaWNDb21wb25lbnQub3V0cHV0c1tvdXR1cE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmR5bmFtaWNDb21wb25lbnQub3V0cHV0c1tvdXR1cE5hbWVdKHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuZHluYW1pY0NvbXBvbmVudENoYW5nZS5lbWl0KHRoaXMuZHluYW1pY0NvbXBvbmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc3Vicy5wdXNoKHN1Yik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICBpZiAoY2hhbmdlcy5keW5hbWljQ29tcG9uZW50KSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnN1YnMpKSB7XG4gICAgICAgIHRoaXMuc3Vicy5tYXAocyA9PiBzLnVuc3Vic2NyaWJlKCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRJbnB1dE91dHB1dHMoKTtcbiAgICB9XG4gIH1cblxuXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIHRoaXMubG9hZENvbXBvbmVudCgpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY29tcG9uZW50UmVmKSB7XG4gICAgICB0aGlzLnN1YnMubWFwKHMgPT4gcy51bnN1YnNjcmliZSgpKTtcbiAgICAgIHRoaXMuY29tcG9uZW50UmVmLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuY29tcG9uZW50UmVmID0gbnVsbCBhcyBhbnk7XG4gICAgfVxuICB9XG59XG4iXX0=