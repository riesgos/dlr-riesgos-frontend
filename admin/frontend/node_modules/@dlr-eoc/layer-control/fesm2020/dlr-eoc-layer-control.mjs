import * as i0 from '@angular/core';
import { EventEmitter, Component, HostBinding, Input, Output, Pipe, NgModule } from '@angular/core';
import { Layer, WmsLayer, WmtsLayer, LayerGroup } from '@dlr-eoc/services-layers';
import * as i5 from '@angular/cdk/drag-drop';
import { moveItemInArray, DragDropModule } from '@angular/cdk/drag-drop';
import * as i1 from '@dlr-eoc/core-ui';
import { CoreUiModule } from '@dlr-eoc/core-ui';
import * as i2 from '@clr/angular';
import { ClarityModule } from '@clr/angular';
import * as i3 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i4 from '@angular/forms';
import { FormsModule } from '@angular/forms';

class LayerentryComponent {
    constructor() {
        this.expandable = true;
        this.update = new EventEmitter();
        this.canZoomToLayer = false;
        this.activeTabs = {
            settings: false,
            legend: true,
            description: false,
            changeStyle: false
        };
    }
    get visible() { return this.layer.visible; }
    get cssClass() { return this.layer.cssClass; }
    ;
    set expanded(value) {
        if (this.layer) {
            this.layer.expanded = value;
        }
    }
    get expanded() {
        if (this.layer) {
            return this.layer.expanded;
        }
        else {
            return false;
        }
    }
    /**
     * obj: {any| IDynamicComponent}
     */
    checkIsComponentItem(layer, compProp) {
        // https://stackoverflow.com/a/65347533/10850021
        const obj = layer[compProp];
        let isComp = false;
        if (obj && typeof obj === 'object') {
            if ('component' in obj) {
                if (!obj.inputs) {
                    // https://2ality.com/2014/01/object-assign.html#2.3
                    const layerClone = Object.assign({ __proto__: this.layer['__proto__'] }, layer);
                    console.log(layerClone);
                    if (layerClone && layerClone[compProp]) {
                        delete layerClone[compProp];
                    }
                    obj.inputs = { layer: layerClone };
                }
                else if (obj.inputs && !obj.inputs.layer) {
                    // https://2ality.com/2014/01/object-assign.html#2.3
                    const layerClone = Object.assign({ __proto__: this.layer['__proto__'] }, layer);
                    console.log(layerClone);
                    if (layerClone && layerClone[compProp]) {
                        delete layerClone[compProp];
                    }
                    obj.inputs = Object.assign({ layer: layerClone }, obj.inputs);
                }
                isComp = true;
            }
        }
        return isComp;
    }
    getLayerName(layer) {
        if (layer.displayName) {
            return layer.displayName;
        }
        else {
            return layer.name;
        }
    }
    ngOnInit() {
        if (!this.layersSvc) {
            console.error('you need to provide a layersService!');
        }
        // console.log(this.layer)
        if (!this.layer.legendImg) {
            this.activeTabs.description = true;
            this.activeTabs.legend = false;
            this.activeTabs.settings = false;
            this.activeTabs.changeStyle = false;
        }
        if (!this.layer.legendImg && !this.layer.description) {
            this.activeTabs.description = false;
            this.activeTabs.legend = false;
            this.activeTabs.settings = true;
        }
        if (this.layer.bbox && this.layer.bbox.length >= 4) {
            this.canZoomToLayer = true;
        }
    }
    /**
     * show or hide the layer
     */
    setLayerVisibility(selectedLayer, group) {
        if (!group) {
            if (selectedLayer.filtertype === 'Baselayers') {
                selectedLayer.visible = !selectedLayer.visible;
                const filterdlayers = this.layerGroups.filter((l) => l.filtertype === 'Baselayers');
                // console.log(filterdlayers);
                for (const layer of filterdlayers) {
                    if (layer instanceof Layer && layer.id !== selectedLayer.id) {
                        layer.visible = !selectedLayer.visible;
                        this.layersSvc.updateLayer(layer, layer.filtertype || 'Baselayers');
                    }
                }
            }
            else {
                selectedLayer.visible = !selectedLayer.visible;
                this.layersSvc.updateLayer(selectedLayer, selectedLayer.filtertype || 'Layers'); // TODO check for baselayers!!!!!!
            }
        }
        else {
            if (group.layers.length > 0) {
                /** "radio" for Baselayers */
                if (group.filtertype === 'Baselayers') {
                    for (const layer of group.layers) {
                        layer.visible = layer === selectedLayer;
                    }
                    this.update.emit({
                        layer: this.layer
                    });
                    /** "checkbox" for all other layers */
                }
                else {
                    const tempGroupVisible = group.visible;
                    /** change visibility of the selected layer */
                    selectedLayer.visible = !selectedLayer.visible;
                    /** check if group visibility has changed */
                    if (tempGroupVisible !== group.visible) {
                        this.update.emit({
                            layer: this.layer
                        });
                    }
                    else {
                        /** If the visibility of the group don't changes update only the layer  */
                        this.layersSvc.updateLayer(selectedLayer, selectedLayer.filtertype || 'Layers');
                    }
                }
            }
        }
    }
    /**
     * setLayerIndex
     */
    setLayerIndex(layer, dir, group) {
        // console.log('is First', this.isFirst(layer));
        // console.log('is Last', this.isLast(layer));
        // console.log(layer, group);
        if (group) {
            this.layersSvc.setLayerIndexInGroup(layer, dir, group);
        }
        else {
            this.layersSvc.setGroupLayerIndex(layer, dir);
        }
    }
    /**
     * remove the Layer if possible
     */
    removeLayer(group, selectedLayer) {
        // console.log("delete ", group, selectedLayer)
        if (group) {
            // console.log("delete layer from group")
            this.layersSvc.removeLayerFromGroup(selectedLayer, group);
        }
        else {
            // console.log('delete single layer');
            this.layersSvc.removeLayer(selectedLayer, selectedLayer.filtertype);
        }
    }
    zoomTo(layer) {
        if (this.mapState && layer.bbox && layer.bbox.length >= 4) {
            this.mapState.setExtent(layer.bbox);
        }
    }
    setLayerOpacity(layer) {
        if (!this.group) {
            this.layersSvc.updateLayer(layer, layer.filtertype || 'Layers'); // TODO check for baselayers!!!!!!
        }
        else {
            this.update.emit({
                layer
            });
        }
    }
    checkBaselayer(layer, group) {
        if (layer.filtertype === 'Baselayers' || group && group.filtertype === 'Baselayers') {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * is expandable if layer has legend, description or opacity can be changed
     */
    is_expandable() {
        if (this.group) {
            return !this.layer.legendImg && this.group.filtertype === 'Baselayers';
        }
        else {
            return false; // !this.layer.legendImg; //this.layer.description
        }
    }
    showProperties() {
        if (!this.is_expandable()) {
            this.expanded = !this.expanded;
        }
    }
    switchTab(tabName) {
        for (const key of Object.keys(this.activeTabs)) {
            this.activeTabs[key] = tabName === key;
        }
    }
    isSelectedStyle(styleName) {
        if (this.layer instanceof WmsLayer) {
            return this.layer.params.STYLES === styleName;
        }
        else if (this.layer instanceof WmtsLayer) {
            return this.layer.params.style === styleName;
        }
        else {
            // TODO: how to compare styles for vector layers and custom layers?
            return false;
        }
    }
    executeChangeStyle(evt) {
        const newStyleName = evt.target.value;
        if (this.layer.styles) {
            const newStyle = this.layer.styles.find(s => s.name === newStyleName);
            if (newStyle) {
                this.layer.legendImg = newStyle.legendURL;
                if (this.layer instanceof WmsLayer) {
                    this.layer.params.STYLES = newStyle.name;
                }
                else if (this.layer instanceof WmtsLayer) {
                    this.layer.params.style = newStyle.name;
                }
                this.layersSvc.updateLayer(this.layer, this.layer.filtertype);
            }
        }
    }
    isFirst(layer) {
        if (this.group) {
            return this.layersSvc.isGroupFirst(layer, this.group.layers);
        }
        else {
            return this.layersSvc.isGroupFirst(layer, null, layer.filtertype);
        }
    }
    isLast(layer) {
        if (this.group) {
            return this.layersSvc.isGroupLast(layer, this.group.layers);
        }
        else {
            return this.layersSvc.isGroupLast(layer, null, layer.filtertype);
        }
    }
    getExpandShape() {
        // return this.openProperties ? 'down' : 'right';
        return this.expanded ? { transform: 'rotate(180deg)' } : { transform: 'rotate(90deg)' };
    }
}
LayerentryComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: LayerentryComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
LayerentryComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.6", type: LayerentryComponent, selector: "ukis-layerentry", inputs: { layersSvc: "layersSvc", mapState: "mapState", layer: "layer", group: "group", layerGroups: "layerGroups", expanded: "expanded", expandable: "expandable" }, outputs: { update: "update" }, host: { properties: { "class.layer-visible": "this.visible", "class": "this.cssClass" } }, ngImport: i0, template: "<div class=\"layer\">\n  <div class=\"head\">\n    <!-- layer expand icon -->\n    <clr-icon shape=\"angle\" [ngStyle]=\"getExpandShape()\" class=\"iconButton\" [ngClass]=\"{'disabled': is_expandable()}\"\n      (click)=\"showProperties()\" title=\"Details\"></clr-icon>\n\n    <!-- layer title -->\n    <div #ref class=\"item-title-replacement title\" (click)=\"showProperties()\" [title]=\"getLayerName(layer)\">\n      <ng-content></ng-content>\n    </div>\n    <span *ngIf=\"ref.children.length == 0\" class=\"title\" [title]=\"getLayerName(layer)\" (click)=\"showProperties()\">\n      {{getLayerName(layer)}}\n    </span>\n\n    <!-- setLayerIndex // for reversed layergroups on ngFor up is down -->\n    <span *ngIf=\"!checkBaselayer(layer,group)\">\n      <clr-icon [hidden]=\"layerGroups && layerGroups.length == 1\" class=\"iconButton\" shape=\"arrow\"\n        [ngClass]=\"{'disabled': isLast(layer)}\" (click)=\"setLayerIndex(layer, 'down', group)\" title=\"up\"></clr-icon>\n      <clr-icon [hidden]=\"layerGroups && layerGroups.length == 1\" class=\"iconButton\" shape=\"arrow\"\n        [ngClass]=\"{'disabled': isFirst(layer)}\" (click)=\"setLayerIndex(layer, 'up', group)\" title=\"down\" dir=\"down\">\n      </clr-icon>\n    </span>\n\n    <!-- setLayerVisibility -->\n    <input class=\"hide\" [type]=\"(checkBaselayer(layer,group))?'radio':'checkbox'\" [name]=\"'layer'\" [id]=\"layer.id\"\n      [checked]=\"layer.visible\" (change)=\"setLayerVisibility(layer, group)\">\n    <label [for]=\"layer.id\">\n      <clr-icon *ngIf=\"checkBaselayer(layer,group); else notBaselayer\" class=\"iconButton\"\n        [ngClass]=\"{'is-solid':layer.visible}\" [attr.shape]=\"(layer.visible)?'dot-circle':'circle'\"\n        title=\"{{layer.visible?'Choose another layer':'Show layer'}}\">\n      </clr-icon>\n      <ng-template #notBaselayer>\n        <clr-icon class=\"iconButton\" [ngClass]=\"{'is-solid':layer.visible}\"\n          [attr.shape]=\"(layer.visible)?'eye':'eye-hide'\" title=\"{{layer.visible?'Hide layer':'Show layer'}}\">\n        </clr-icon>\n      </ng-template>\n    </label>\n\n  </div>\n  <div *ngIf=\"expandable && expanded\" class=\"body\">\n    <!-- tools: zoomTo, remove, switch Tab -->\n    <div class=\"tools\">\n      <clr-icon *ngIf=\"!checkBaselayer(layer, group)\" title=\"Layer settings\" shape=\"cog\" class=\"iconButton\"\n        [ngClass]=\"{'active': activeTabs['settings']}\" (click)=\"switchTab('settings')\"></clr-icon>\n      <clr-icon *ngIf=\"layer.legendImg\" title=\"Layer Legend\" shape=\"image\" class=\"iconButton\"\n        [ngClass]=\"{'active': activeTabs['legend']}\" (click)=\"switchTab('legend')\"></clr-icon>\n      <clr-icon *ngIf=\"layer.description\" title=\"Layer info\" shape=\"info-standard\" class=\"iconButton\"\n        [ngClass]=\"{'active': activeTabs['description']}\" (click)=\"switchTab('description')\"></clr-icon>\n      <clr-icon *ngIf=\"layer.styles?.length > 1\" title=\"Change style\" shape=\"cloud-chart\" class=\"iconButton\"\n        [ngClass]=\"{'active': activeTabs['changeStyle']}\" (click)=\"switchTab('changeStyle')\"></clr-icon>\n\n      <clr-icon *ngFor=\"let item of layer.actions\" [attr.shape]=\"item.icon\" class=\"iconButton\"\n        (click)=\"item.action(layer)\" [title]=\"item.title\">\n      </clr-icon>\n\n\n      <span></span>\n      <clr-icon *ngIf=\"canZoomToLayer\" shape=\"zoom-in\" class=\"iconButton\" title=\"Zoom to layer\" (click)=\"zoomTo(layer)\">\n      </clr-icon>\n      <clr-icon *ngIf=\"layer.removable\" shape=\"trash\" class=\"iconButton\" (click)=\"removeLayer(group, layer)\"\n        title=\"Remove layer\"></clr-icon>\n    </div>\n    <div class=\"tabsbody\">\n      <div *ngIf=\"activeTabs.settings\" class=\"layersettings\">\n        <!-- setLayerOpacity -->\n        <div class=\"form-group\">\n          <label [for]=\"'layer_transparency_slider_'+layer.id\">Opacity:</label>\n          <input [id]=\"'layer_transparency_slider_'+layer.id\" type=\"range\" class=\"ukis-range-input opacity-input\"\n            name=\"points\" [value]=\"layer.opacity\" [min]=\"0.0\" [max]=\"1.0\" [step]=\"0.1\" (change)=\"setLayerOpacity(layer)\"\n            [(ngModel)]=\"layer.opacity\" />\n          <span>{{\" \"+layer.opacity}}</span>\n        </div>\n        <ng-container *ngIf=\"checkIsComponentItem(layer, 'action');\">\n          <ukis-dynamic-component [(dynamicComponent)]=\"layer.action\">\n          </ukis-dynamic-component>\n        </ng-container>\n      </div>\n      <!-- show Legend -->\n      <div *ngIf=\"activeTabs.legend && layer.legendImg\">\n        <ng-container *ngIf=\"checkIsComponentItem(layer,'legendImg'); else imageUrl\">\n          <ukis-dynamic-component [(dynamicComponent)]=\"layer.legendImg\"></ukis-dynamic-component>\n        </ng-container>\n\n        <ng-template #imageUrl>\n          <a [href]=\"layer.legendImg\" target=\"_blank\" title=\"Show full Image\"><img [src]=\"layer.legendImg\" /></a>\n        </ng-template>\n      </div>\n      <!-- show Description -->\n      <div *ngIf=\"activeTabs.description && layer.description\">\n        <span [innerHTML]=\"layer.description\"></span>\n      </div>\n      <!-- show style-switcher -->\n      <div *ngIf=\"activeTabs.changeStyle && layer.styles && layer.styles?.length > 1\">\n        <select clrSelect (change)=\"executeChangeStyle($event)\">\n          <option *ngFor=\"let style of layer.styles\" [value]=\"style.name\"\n            [attr.selected]=\"isSelectedStyle(style.name) ? true : null\">{{style.title}}</option>\n        </select>\n      </div>\n    </div>\n\n  </div>\n\n</div>\n", styles: [".title{cursor:pointer}.item-title-replacement:empty{display:none}.body{cursor:default}.tabsbody{overflow:hidden;word-break:break-all}.tabsbody img{height:auto;max-width:100%}\n"], components: [{ type: i1.DynamicComponentComponent, selector: "ukis-dynamic-component", inputs: ["dynamicComponent"], outputs: ["dynamicComponentChange"] }], directives: [{ type: i2.ClrIconCustomTag, selector: "clr-icon" }, { type: i3.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2.ClrLabel, selector: "label", inputs: ["for"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i4.RangeValueAccessor, selector: "input[type=range][formControlName],input[type=range][formControl],input[type=range][ngModel]" }, { type: i4.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { type: i4.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i4.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { type: i2.ClrSelect, selector: "[clrSelect]" }, { type: i4.NgSelectOption, selector: "option", inputs: ["ngValue", "value"] }, { type: i4.ɵNgSelectMultipleOption, selector: "option", inputs: ["ngValue", "value"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: LayerentryComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ukis-layerentry', template: "<div class=\"layer\">\n  <div class=\"head\">\n    <!-- layer expand icon -->\n    <clr-icon shape=\"angle\" [ngStyle]=\"getExpandShape()\" class=\"iconButton\" [ngClass]=\"{'disabled': is_expandable()}\"\n      (click)=\"showProperties()\" title=\"Details\"></clr-icon>\n\n    <!-- layer title -->\n    <div #ref class=\"item-title-replacement title\" (click)=\"showProperties()\" [title]=\"getLayerName(layer)\">\n      <ng-content></ng-content>\n    </div>\n    <span *ngIf=\"ref.children.length == 0\" class=\"title\" [title]=\"getLayerName(layer)\" (click)=\"showProperties()\">\n      {{getLayerName(layer)}}\n    </span>\n\n    <!-- setLayerIndex // for reversed layergroups on ngFor up is down -->\n    <span *ngIf=\"!checkBaselayer(layer,group)\">\n      <clr-icon [hidden]=\"layerGroups && layerGroups.length == 1\" class=\"iconButton\" shape=\"arrow\"\n        [ngClass]=\"{'disabled': isLast(layer)}\" (click)=\"setLayerIndex(layer, 'down', group)\" title=\"up\"></clr-icon>\n      <clr-icon [hidden]=\"layerGroups && layerGroups.length == 1\" class=\"iconButton\" shape=\"arrow\"\n        [ngClass]=\"{'disabled': isFirst(layer)}\" (click)=\"setLayerIndex(layer, 'up', group)\" title=\"down\" dir=\"down\">\n      </clr-icon>\n    </span>\n\n    <!-- setLayerVisibility -->\n    <input class=\"hide\" [type]=\"(checkBaselayer(layer,group))?'radio':'checkbox'\" [name]=\"'layer'\" [id]=\"layer.id\"\n      [checked]=\"layer.visible\" (change)=\"setLayerVisibility(layer, group)\">\n    <label [for]=\"layer.id\">\n      <clr-icon *ngIf=\"checkBaselayer(layer,group); else notBaselayer\" class=\"iconButton\"\n        [ngClass]=\"{'is-solid':layer.visible}\" [attr.shape]=\"(layer.visible)?'dot-circle':'circle'\"\n        title=\"{{layer.visible?'Choose another layer':'Show layer'}}\">\n      </clr-icon>\n      <ng-template #notBaselayer>\n        <clr-icon class=\"iconButton\" [ngClass]=\"{'is-solid':layer.visible}\"\n          [attr.shape]=\"(layer.visible)?'eye':'eye-hide'\" title=\"{{layer.visible?'Hide layer':'Show layer'}}\">\n        </clr-icon>\n      </ng-template>\n    </label>\n\n  </div>\n  <div *ngIf=\"expandable && expanded\" class=\"body\">\n    <!-- tools: zoomTo, remove, switch Tab -->\n    <div class=\"tools\">\n      <clr-icon *ngIf=\"!checkBaselayer(layer, group)\" title=\"Layer settings\" shape=\"cog\" class=\"iconButton\"\n        [ngClass]=\"{'active': activeTabs['settings']}\" (click)=\"switchTab('settings')\"></clr-icon>\n      <clr-icon *ngIf=\"layer.legendImg\" title=\"Layer Legend\" shape=\"image\" class=\"iconButton\"\n        [ngClass]=\"{'active': activeTabs['legend']}\" (click)=\"switchTab('legend')\"></clr-icon>\n      <clr-icon *ngIf=\"layer.description\" title=\"Layer info\" shape=\"info-standard\" class=\"iconButton\"\n        [ngClass]=\"{'active': activeTabs['description']}\" (click)=\"switchTab('description')\"></clr-icon>\n      <clr-icon *ngIf=\"layer.styles?.length > 1\" title=\"Change style\" shape=\"cloud-chart\" class=\"iconButton\"\n        [ngClass]=\"{'active': activeTabs['changeStyle']}\" (click)=\"switchTab('changeStyle')\"></clr-icon>\n\n      <clr-icon *ngFor=\"let item of layer.actions\" [attr.shape]=\"item.icon\" class=\"iconButton\"\n        (click)=\"item.action(layer)\" [title]=\"item.title\">\n      </clr-icon>\n\n\n      <span></span>\n      <clr-icon *ngIf=\"canZoomToLayer\" shape=\"zoom-in\" class=\"iconButton\" title=\"Zoom to layer\" (click)=\"zoomTo(layer)\">\n      </clr-icon>\n      <clr-icon *ngIf=\"layer.removable\" shape=\"trash\" class=\"iconButton\" (click)=\"removeLayer(group, layer)\"\n        title=\"Remove layer\"></clr-icon>\n    </div>\n    <div class=\"tabsbody\">\n      <div *ngIf=\"activeTabs.settings\" class=\"layersettings\">\n        <!-- setLayerOpacity -->\n        <div class=\"form-group\">\n          <label [for]=\"'layer_transparency_slider_'+layer.id\">Opacity:</label>\n          <input [id]=\"'layer_transparency_slider_'+layer.id\" type=\"range\" class=\"ukis-range-input opacity-input\"\n            name=\"points\" [value]=\"layer.opacity\" [min]=\"0.0\" [max]=\"1.0\" [step]=\"0.1\" (change)=\"setLayerOpacity(layer)\"\n            [(ngModel)]=\"layer.opacity\" />\n          <span>{{\" \"+layer.opacity}}</span>\n        </div>\n        <ng-container *ngIf=\"checkIsComponentItem(layer, 'action');\">\n          <ukis-dynamic-component [(dynamicComponent)]=\"layer.action\">\n          </ukis-dynamic-component>\n        </ng-container>\n      </div>\n      <!-- show Legend -->\n      <div *ngIf=\"activeTabs.legend && layer.legendImg\">\n        <ng-container *ngIf=\"checkIsComponentItem(layer,'legendImg'); else imageUrl\">\n          <ukis-dynamic-component [(dynamicComponent)]=\"layer.legendImg\"></ukis-dynamic-component>\n        </ng-container>\n\n        <ng-template #imageUrl>\n          <a [href]=\"layer.legendImg\" target=\"_blank\" title=\"Show full Image\"><img [src]=\"layer.legendImg\" /></a>\n        </ng-template>\n      </div>\n      <!-- show Description -->\n      <div *ngIf=\"activeTabs.description && layer.description\">\n        <span [innerHTML]=\"layer.description\"></span>\n      </div>\n      <!-- show style-switcher -->\n      <div *ngIf=\"activeTabs.changeStyle && layer.styles && layer.styles?.length > 1\">\n        <select clrSelect (change)=\"executeChangeStyle($event)\">\n          <option *ngFor=\"let style of layer.styles\" [value]=\"style.name\"\n            [attr.selected]=\"isSelectedStyle(style.name) ? true : null\">{{style.title}}</option>\n        </select>\n      </div>\n    </div>\n\n  </div>\n\n</div>\n", styles: [".title{cursor:pointer}.item-title-replacement:empty{display:none}.body{cursor:default}.tabsbody{overflow:hidden;word-break:break-all}.tabsbody img{height:auto;max-width:100%}\n"] }]
        }], ctorParameters: function () { return []; }, propDecorators: { visible: [{
                type: HostBinding,
                args: ['class.layer-visible']
            }], cssClass: [{
                type: HostBinding,
                args: ['class']
            }], layersSvc: [{
                type: Input,
                args: ['layersSvc']
            }], mapState: [{
                type: Input,
                args: ['mapState']
            }], layer: [{
                type: Input,
                args: ['layer']
            }], group: [{
                type: Input,
                args: ['group']
            }], layerGroups: [{
                type: Input,
                args: ['layerGroups']
            }], expanded: [{
                type: Input,
                args: ['expanded']
            }], expandable: [{
                type: Input,
                args: ['expandable']
            }], update: [{
                type: Output
            }] } });

class ReversePipe {
    transform(input) {
        if (typeof input === 'string') {
            return input
                .split('')
                .reverse()
                .join('');
        }
        return Array.isArray(input) ? input.slice().reverse() : input;
    }
}
ReversePipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ReversePipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
ReversePipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ReversePipe, name: "reverse", pure: false });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ReversePipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'reverse',
                    pure: false
                }]
        }] });

class ObjTypePipe {
    transform(observations, type) {
        /* TODO: check layerlist for purity console.log("reevaluated"); */
        return observations.filter((o) => o.type === type);
    }
}
ObjTypePipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ObjTypePipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
ObjTypePipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ObjTypePipe, name: "type", pure: false });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ObjTypePipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'type', pure: false
                }]
        }] });
/**
 * e.g. usage *ngFor="let item of items | itemsfilter: callbackfn"
 */
class ItemsFilterPipe {
    transform(items, callbackfn) {
        /* TODO: check layerlist for purity console.log("reevaluated"); */
        return items.filter(callbackfn);
    }
}
ItemsFilterPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ItemsFilterPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
ItemsFilterPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ItemsFilterPipe, name: "itemsfilter", pure: false });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ItemsFilterPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'itemsfilter', pure: false
                }]
        }] });

class LayerentryGroupComponent {
    constructor() {
        // public visible: boolean = true;
        this.canZoomToGroup = false;
        this.showInfo = false;
        this.showAction = true;
    }
    get visible() { return this.group.visible; }
    get cssClass() { return this.group.cssClass; }
    set openAllLayersProperties(value) {
        if (this.group && this.group.layers.length) {
            this.group.layers.forEach(l => l.expanded = value);
        }
    }
    get openAllLayersProperties() {
        if (this.group && this.group.layers.length) {
            return this.group.layers.filter(l => l.expanded === true).length === this.group.layers.length;
        }
        else {
            return false;
        }
    }
    ngOnInit() {
        if (this.group.bbox && this.group.bbox.length >= 4) {
            this.canZoomToGroup = true;
        }
        if (!this.group?.action) {
            this.showAction = false;
        }
    }
    /**
     * obj: {any| IDynamicComponent}
     */
    checkIsComponentItem(group, compProp) {
        const obj = group[compProp];
        let isComp = false;
        if (obj && typeof obj === 'object') {
            if ('component' in obj) {
                if (!obj.inputs) {
                    // https://2ality.com/2014/01/object-assign.html#2.3
                    const groupClone = Object.assign({ __proto__: this.group['__proto__'] }, group);
                    if (groupClone && groupClone[compProp]) {
                        delete groupClone[compProp];
                    }
                    obj.inputs = { group: groupClone };
                }
                else if (obj.inputs && !obj.inputs.group) {
                    // https://2ality.com/2014/01/object-assign.html#2.3
                    const groupClone = Object.assign({ __proto__: this.group['__proto__'] }, group);
                    if (groupClone && groupClone[compProp]) {
                        delete groupClone[compProp];
                    }
                    obj.inputs = Object.assign({ group: groupClone }, obj.inputs);
                }
                isComp = true;
            }
        }
        return isComp;
    }
    checkBaselayer(group) {
        if (group && group.filtertype === 'Baselayers') {
            return true;
        }
        else {
            return false;
        }
    }
    checkClassHide(layer) {
        const hasHide = layer?.cssClass?.includes('hide') || false;
        return !hasHide;
    }
    getLayerName(group) {
        if (group.displayName) {
            return group.displayName;
        }
        else {
            return group.name;
        }
    }
    setLayerGroupIndex(group, dir) {
        this.layersSvc.setGroupLayerIndex(group, dir);
    }
    setGroupLayersVisibility() {
        this.group.visible = !this.group.visible;
        this.layersSvc.updateLayerGroup(this.group);
    }
    removeLayerGroup(group) {
        this.layersSvc.removeLayerGroup(group);
    }
    zoomTo(group) {
        if (this.mapState && group.bbox && group.bbox.length >= 4) {
            this.mapState.setExtent(group.bbox);
        }
    }
    layerUpdate(event, group) {
        const layer = event.layer;
        /** update event layer in the group... this is done by object reference!! */
        /* const updateLayerIndex = group.layers.findIndex(l => l.id === layer.id);
        if (updateLayerIndex !== -1) {
          group.layers[updateLayerIndex] = layer;
        } */
        this.layersSvc.updateLayerGroup(group);
    }
    showProperties() {
        this.group.expanded = !this.group.expanded;
    }
    showHideAllDetails() {
        this.openAllLayersProperties = !this.openAllLayersProperties;
        this.showAction = this.openAllLayersProperties;
        this.showInfo = this.openAllLayersProperties;
    }
    isFirst(group) {
        return this.layersSvc.isGroupFirst(group, this.layerGroups, group.filtertype);
    }
    isLast(group) {
        return this.layersSvc.isGroupLast(group, this.layerGroups, group.filtertype);
    }
    // CDKDRagAndDrop -------------------------------------------------------------
    // https://material.angular.io/cdk/drag-drop/api
    drop(event) {
        const groupLayers = this.group.layers;
        const groupLeng = groupLayers.length;
        const fiteredLayers = event.container.data; // filtered by [cdkDropListData]
        const groupFiteredLeng = fiteredLayers.length;
        let previousIFinal, newIFinal;
        /**
         * calc index with pipe reverse order
         */
        if (groupLeng === groupFiteredLeng) {
            const previousIndex = groupLeng - event.previousIndex - 1;
            const newIndex = groupLeng - event.currentIndex - 1;
            previousIFinal = previousIndex;
            newIFinal = newIndex;
        }
        else {
            /**
             * If array is filtered get previousIndex by item.data and try to calculate ne index
             * get layers for cdk indexes - 'connect' 'event.container.data' and the original not filtered data
             */
            const newLayer = fiteredLayers[event.currentIndex];
            const previousIndex = groupLayers.findIndex(l => l.id === event.item.data.id);
            let newIndex = groupLayers.findIndex(l => l.id === newLayer.id);
            // Item is not moved
            if (event.previousIndex === event.currentIndex) {
                newIndex = previousIndex;
            }
            previousIFinal = previousIndex;
            newIFinal = newIndex;
        }
        moveItemInArray(this.group.layers, previousIFinal, newIFinal);
        this.layersSvc.updateLayerGroup(this.group);
    }
}
LayerentryGroupComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: LayerentryGroupComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
LayerentryGroupComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.6", type: LayerentryGroupComponent, selector: "ukis-layerentry-group", inputs: { layersSvc: "layersSvc", mapState: "mapState", group: "group", layerGroups: "layerGroups" }, host: { properties: { "class.group-visible": "this.visible", "class": "this.cssClass" } }, ngImport: i0, template: "<div class=\"layergroup\">\n  <div class=\"head\">\n    <!-- layer expand icon -->\n    <clr-icon [attr.shape]=\"group.expanded?'folder-open':'folder'\" class=\"iconButton\" (click)=\"showProperties()\"\n      title=\"{{group.expanded?'Close':'Open'}}\"></clr-icon>\n\n\n    <!-- layer title -->\n    <div #ref class=\"item-title-replacement title\" (click)=\"showProperties()\" [title]=\"getLayerName(group)\">\n      <ng-content></ng-content>\n    </div>\n    <span *ngIf=\"ref.children.length == 0\" class=\"title\" [title]=\"getLayerName(group)\" (click)=\"showProperties()\">\n      {{getLayerName(group)}}\n    </span>\n\n    <!-- setLayerGroupIndex // for reversed layergroups on ngFor up is down -->\n    <span *ngIf=\"layerGroups.length>1\">\n      <clr-icon class=\"iconButton move-item\" [ngClass]=\"{'disabled':isLast(group)}\" shape=\"arrow\"\n        (click)=\"setLayerGroupIndex(group, 'down')\" title=\"up\"></clr-icon>\n      <clr-icon class=\"iconButton move-item\" [ngClass]=\"{'disabled':isFirst(group)}\" shape=\"arrow\"\n        (click)=\"setLayerGroupIndex(group, 'up')\" title=\"down\" dir=\"down\"></clr-icon>\n    </span>\n\n    <!-- setGroupLayersVisibility -->\n    <span *ngIf=\"!checkBaselayer(group)\">\n      <input class=\"hide\" [type]=\"'checkbox'\" [checked]=\"group.visible\" [name]=\"'group'\" [id]=\"group.id\"\n        (change)=\"setGroupLayersVisibility()\">\n      <label [for]=\"group.id\">\n        <clr-icon class=\"iconButton\" [ngClass]=\"{'is-solid':group.visible}\"\n          [attr.shape]=\"group.visible?'eye':'eye-hide'\" title=\"{{group.visible?'Hide Group':'Show Group'}}\"></clr-icon>\n      </label>\n    </span>\n  </div>\n\n  <div *ngIf=\"group.expanded\" class=\"body\">\n    <!-- tools: zoomTo, remove, open all Tabs -->\n    <div class=\"tools\">\n      <clr-icon *ngFor=\"let item of group.actions\" [attr.shape]=\"item.icon\" class=\"iconButton\"\n        (click)=\"item.action(group)\" [title]=\"item.title\">\n      </clr-icon>\n\n      <clr-icon *ngIf=\"group.action\" shape=\"cog\" class=\"iconButton\" [ngClass]=\"{'is-solid':showAction}\"\n        (click)=\"showAction = !showAction\" title=\"{{!showAction?'Show settings': 'Hide settings'}}\"></clr-icon>\n\n      <clr-icon *ngIf=\"group.description\" shape=\"info-standard\" class=\"iconButton\" [ngClass]=\"{'is-solid':showInfo}\"\n        (click)=\"showInfo = !showInfo\" title=\"{{!showInfo?'Show Info': 'Hide Info'}}\"></clr-icon>\n      <clr-icon shape=\"details\" class=\"iconButton\" [ngClass]=\"{'is-solid':openAllLayersProperties}\"\n        (click)=\"showHideAllDetails()\"\n        title=\"{{!openAllLayersProperties?'Show all layers details': 'Hide all layers details'}}\"></clr-icon>\n\n      <span></span>\n      <clr-icon *ngIf=\"canZoomToGroup\" shape=\"zoom-in\" class=\"iconButton\" (click)=\"zoomTo(group)\" title=\"Zoom to group\">\n      </clr-icon>\n      <clr-icon *ngIf=\"group.removable\" shape=\"trash\" class=\"iconButton\" (click)=\"removeLayerGroup(group)\"\n        title=\"Remove group\"></clr-icon>\n    </div>\n\n    <div class=\"info\" *ngIf=\"showInfo\">\n      <span [innerHTML]=\"group.description\"></span>\n    </div>\n    <div *ngIf=\"group.action && showAction\" class=\"tabsbody\">\n      <ng-container *ngIf=\"checkIsComponentItem(group, 'action');\">\n        <ukis-dynamic-component [(dynamicComponent)]=\"group.action\">\n        </ukis-dynamic-component>\n      </ng-container>\n    </div>\n\n\n    <!-- (cdkDropListSorted)=\"sort($event)\"  -->\n    <div cdkDropList (cdkDropListDropped)=\"drop($event)\"\n      [cdkDropListData]=\"group.layers | itemsfilter: checkClassHide | reverse\">\n      <ng-container *ngFor=\"let layer of group.layers | itemsfilter: checkClassHide | reverse\">\n        <div class=\"sublayers\" cdkDragLockAxis=\"y\" cdkDrag [cdkDragData]=\"{id:layer.id}\">\n          <ukis-layerentry [expanded]=\"openAllLayersProperties\" [layersSvc]=\"layersSvc\" [mapState]=\"mapState\"\n            [layer]=\"layer\" [group]=\"group\" (update)=\"layerUpdate($event, group)\">\n            <span class=\"move-item\" cdkDragHandle>\n              {{layer.displayName || layer.name}}\n            </span>\n          </ukis-layerentry>\n        </div>\n      </ng-container>\n    </div>\n  </div>\n</div>\n", styles: [".title{cursor:pointer}.item-title-replacement:empty{display:none}.cdk-drag-preview{display:flex;align-items:center;padding:0 10px;box-sizing:border-box;border-radius:2px;box-shadow:0 5px 5px -3px #0003,0 8px 10px 1px #00000024,0 3px 14px 2px #0000001f;overflow:hidden}.cdk-drag-placeholder{opacity:.2}.cdk-drag-animating{transition:transform .25s cubic-bezier(0,0,.2,1)}.example-box:last-child{border:none}.cdk-drop-list-dragging .sublayers:not(.cdk-drag-placeholder){transition:transform .25s cubic-bezier(0,0,.2,1)}.info{padding-left:.2rem}\n"], components: [{ type: i1.DynamicComponentComponent, selector: "ukis-dynamic-component", inputs: ["dynamicComponent"], outputs: ["dynamicComponentChange"] }, { type: LayerentryComponent, selector: "ukis-layerentry", inputs: ["layersSvc", "mapState", "layer", "group", "layerGroups", "expanded", "expandable"], outputs: ["update"] }], directives: [{ type: i2.ClrIconCustomTag, selector: "clr-icon" }, { type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i2.ClrLabel, selector: "label", inputs: ["for"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i5.CdkDropList, selector: "[cdkDropList], cdk-drop-list", inputs: ["cdkDropListConnectedTo", "cdkDropListData", "cdkDropListOrientation", "id", "cdkDropListLockAxis", "cdkDropListDisabled", "cdkDropListSortingDisabled", "cdkDropListEnterPredicate", "cdkDropListSortPredicate", "cdkDropListAutoScrollDisabled", "cdkDropListAutoScrollStep"], outputs: ["cdkDropListDropped", "cdkDropListEntered", "cdkDropListExited", "cdkDropListSorted"], exportAs: ["cdkDropList"] }, { type: i5.CdkDrag, selector: "[cdkDrag]", inputs: ["cdkDragData", "cdkDragLockAxis", "cdkDragRootElement", "cdkDragBoundary", "cdkDragStartDelay", "cdkDragFreeDragPosition", "cdkDragDisabled", "cdkDragConstrainPosition", "cdkDragPreviewClass", "cdkDragPreviewContainer"], outputs: ["cdkDragStarted", "cdkDragReleased", "cdkDragEnded", "cdkDragEntered", "cdkDragExited", "cdkDragDropped", "cdkDragMoved"], exportAs: ["cdkDrag"] }, { type: i5.CdkDragHandle, selector: "[cdkDragHandle]", inputs: ["cdkDragHandleDisabled"] }], pipes: { "reverse": ReversePipe, "itemsfilter": ItemsFilterPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: LayerentryGroupComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ukis-layerentry-group', template: "<div class=\"layergroup\">\n  <div class=\"head\">\n    <!-- layer expand icon -->\n    <clr-icon [attr.shape]=\"group.expanded?'folder-open':'folder'\" class=\"iconButton\" (click)=\"showProperties()\"\n      title=\"{{group.expanded?'Close':'Open'}}\"></clr-icon>\n\n\n    <!-- layer title -->\n    <div #ref class=\"item-title-replacement title\" (click)=\"showProperties()\" [title]=\"getLayerName(group)\">\n      <ng-content></ng-content>\n    </div>\n    <span *ngIf=\"ref.children.length == 0\" class=\"title\" [title]=\"getLayerName(group)\" (click)=\"showProperties()\">\n      {{getLayerName(group)}}\n    </span>\n\n    <!-- setLayerGroupIndex // for reversed layergroups on ngFor up is down -->\n    <span *ngIf=\"layerGroups.length>1\">\n      <clr-icon class=\"iconButton move-item\" [ngClass]=\"{'disabled':isLast(group)}\" shape=\"arrow\"\n        (click)=\"setLayerGroupIndex(group, 'down')\" title=\"up\"></clr-icon>\n      <clr-icon class=\"iconButton move-item\" [ngClass]=\"{'disabled':isFirst(group)}\" shape=\"arrow\"\n        (click)=\"setLayerGroupIndex(group, 'up')\" title=\"down\" dir=\"down\"></clr-icon>\n    </span>\n\n    <!-- setGroupLayersVisibility -->\n    <span *ngIf=\"!checkBaselayer(group)\">\n      <input class=\"hide\" [type]=\"'checkbox'\" [checked]=\"group.visible\" [name]=\"'group'\" [id]=\"group.id\"\n        (change)=\"setGroupLayersVisibility()\">\n      <label [for]=\"group.id\">\n        <clr-icon class=\"iconButton\" [ngClass]=\"{'is-solid':group.visible}\"\n          [attr.shape]=\"group.visible?'eye':'eye-hide'\" title=\"{{group.visible?'Hide Group':'Show Group'}}\"></clr-icon>\n      </label>\n    </span>\n  </div>\n\n  <div *ngIf=\"group.expanded\" class=\"body\">\n    <!-- tools: zoomTo, remove, open all Tabs -->\n    <div class=\"tools\">\n      <clr-icon *ngFor=\"let item of group.actions\" [attr.shape]=\"item.icon\" class=\"iconButton\"\n        (click)=\"item.action(group)\" [title]=\"item.title\">\n      </clr-icon>\n\n      <clr-icon *ngIf=\"group.action\" shape=\"cog\" class=\"iconButton\" [ngClass]=\"{'is-solid':showAction}\"\n        (click)=\"showAction = !showAction\" title=\"{{!showAction?'Show settings': 'Hide settings'}}\"></clr-icon>\n\n      <clr-icon *ngIf=\"group.description\" shape=\"info-standard\" class=\"iconButton\" [ngClass]=\"{'is-solid':showInfo}\"\n        (click)=\"showInfo = !showInfo\" title=\"{{!showInfo?'Show Info': 'Hide Info'}}\"></clr-icon>\n      <clr-icon shape=\"details\" class=\"iconButton\" [ngClass]=\"{'is-solid':openAllLayersProperties}\"\n        (click)=\"showHideAllDetails()\"\n        title=\"{{!openAllLayersProperties?'Show all layers details': 'Hide all layers details'}}\"></clr-icon>\n\n      <span></span>\n      <clr-icon *ngIf=\"canZoomToGroup\" shape=\"zoom-in\" class=\"iconButton\" (click)=\"zoomTo(group)\" title=\"Zoom to group\">\n      </clr-icon>\n      <clr-icon *ngIf=\"group.removable\" shape=\"trash\" class=\"iconButton\" (click)=\"removeLayerGroup(group)\"\n        title=\"Remove group\"></clr-icon>\n    </div>\n\n    <div class=\"info\" *ngIf=\"showInfo\">\n      <span [innerHTML]=\"group.description\"></span>\n    </div>\n    <div *ngIf=\"group.action && showAction\" class=\"tabsbody\">\n      <ng-container *ngIf=\"checkIsComponentItem(group, 'action');\">\n        <ukis-dynamic-component [(dynamicComponent)]=\"group.action\">\n        </ukis-dynamic-component>\n      </ng-container>\n    </div>\n\n\n    <!-- (cdkDropListSorted)=\"sort($event)\"  -->\n    <div cdkDropList (cdkDropListDropped)=\"drop($event)\"\n      [cdkDropListData]=\"group.layers | itemsfilter: checkClassHide | reverse\">\n      <ng-container *ngFor=\"let layer of group.layers | itemsfilter: checkClassHide | reverse\">\n        <div class=\"sublayers\" cdkDragLockAxis=\"y\" cdkDrag [cdkDragData]=\"{id:layer.id}\">\n          <ukis-layerentry [expanded]=\"openAllLayersProperties\" [layersSvc]=\"layersSvc\" [mapState]=\"mapState\"\n            [layer]=\"layer\" [group]=\"group\" (update)=\"layerUpdate($event, group)\">\n            <span class=\"move-item\" cdkDragHandle>\n              {{layer.displayName || layer.name}}\n            </span>\n          </ukis-layerentry>\n        </div>\n      </ng-container>\n    </div>\n  </div>\n</div>\n", styles: [".title{cursor:pointer}.item-title-replacement:empty{display:none}.cdk-drag-preview{display:flex;align-items:center;padding:0 10px;box-sizing:border-box;border-radius:2px;box-shadow:0 5px 5px -3px #0003,0 8px 10px 1px #00000024,0 3px 14px 2px #0000001f;overflow:hidden}.cdk-drag-placeholder{opacity:.2}.cdk-drag-animating{transition:transform .25s cubic-bezier(0,0,.2,1)}.example-box:last-child{border:none}.cdk-drop-list-dragging .sublayers:not(.cdk-drag-placeholder){transition:transform .25s cubic-bezier(0,0,.2,1)}.info{padding-left:.2rem}\n"] }]
        }], ctorParameters: function () { return []; }, propDecorators: { visible: [{
                type: HostBinding,
                args: ['class.group-visible']
            }], cssClass: [{
                type: HostBinding,
                args: ['class']
            }], layersSvc: [{
                type: Input,
                args: ['layersSvc']
            }], mapState: [{
                type: Input,
                args: ['mapState']
            }], group: [{
                type: Input,
                args: ['group']
            }], layerGroups: [{
                type: Input,
                args: ['layerGroups']
            }] } });

class LayerControlComponent {
    constructor() {
        this.layerfilter = 'Layers';
        this.layergroups = [];
    }
    ngOnInit() {
        this.layerGroupsSubscription = this.layersSvc.getLayerGroups().subscribe(layergroups => {
            this.layergroups = layergroups;
            /**
             * filter only in template so reordering of layers with set layergroups is working
             */
            // this.layergroups = layergroups.filter((group) => group.filtertype === this.layerfilter || group.filtertype === this.layerfilter);
        });
    }
    isLayerGroup(group) {
        if (group instanceof LayerGroup) {
            return true;
        }
        else {
            return false;
        }
    }
    ngOnDestroy() {
        this.layerGroupsSubscription.unsubscribe();
    }
    // CDKDRagAndDrop -------------------------------------------------------------
    // https://material.angular.io/cdk/drag-drop/api
    drop(event) {
        const groupLayers = this.layergroups;
        const groupLeng = groupLayers.length;
        const fiteredLayers = event.container.data; // filtered by [cdkDropListData]
        const groupFiteredLeng = fiteredLayers.length;
        let previousIFinal, newIFinal;
        /**
         * calc index with pipe reverse order
         */
        if (groupLeng === groupFiteredLeng) {
            const previousIndex = groupLeng - event.previousIndex - 1;
            const newIndex = groupLeng - event.currentIndex - 1;
            previousIFinal = previousIndex;
            newIFinal = newIndex;
        }
        else {
            /**
             * If array is filtered get previousIndex by item.data and try to calculate ne index
             * get layers for cdk indexes - 'connect' 'event.container.data' and the original not filtered data
             */
            const newLayer = fiteredLayers[event.currentIndex];
            const previousIndex = groupLayers.findIndex(l => l.id === event.item.data.id);
            let newIndex = groupLayers.findIndex(l => l.id === newLayer.id);
            // Item is not moved
            if (event.previousIndex === event.currentIndex) {
                newIndex = previousIndex;
            }
            previousIFinal = previousIndex;
            newIFinal = newIndex;
        }
        this.layersSvc.arrayMove(this.layergroups, previousIFinal, newIFinal);
        this.layersSvc.setLayerGroups(this.layergroups);
    }
    checkBaselayer(layer, group) {
        if (layer.filtertype === 'Baselayers' || group && group.filtertype === 'Baselayers') {
            return true;
        }
        else {
            return false;
        }
    }
    checkClassHide(layerOrGroup) {
        const hasHide = layerOrGroup?.cssClass?.includes('hide') || false;
        return !hasHide;
    }
}
LayerControlComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: LayerControlComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
LayerControlComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.6", type: LayerControlComponent, selector: "ukis-layer-control", inputs: { layersSvc: "layersSvc", mapStateSvc: "mapStateSvc", layerfilter: "layerfilter" }, ngImport: i0, template: "<div cdkDropList (cdkDropListDropped)=\"drop($event)\"\n  [cdkDropListData]=\"layergroups | itemsfilter: checkClassHide | reverse\">\n  <ng-container *ngFor=\"let group of layergroups | itemsfilter: checkClassHide | reverse\">\n    <div class=\"list-item\" cdkDragLockAxis=\"y\" cdkDrag [cdkDragData]=\"{id:group.id}\">\n      <ukis-layerentry-group *ngIf=\" isLayerGroup(group) && group.filtertype===layerfilter\" [layersSvc]=\"layersSvc\"\n        [mapState]=\"mapStateSvc\" [group]=\"group\" [layerGroups]=\"layergroups\">\n        <span class=\"move-item\" cdkDragHandle>\n          {{group.displayName || group.name}}\n        </span>\n      </ukis-layerentry-group>\n      <ukis-layerentry *ngIf=\"!isLayerGroup(group) && group.filtertype === layerfilter\" [layerGroups]=\"layergroups\"\n        [expanded]=\"false\" [layersSvc]=\"layersSvc\" [mapState]=\"mapStateSvc\" [layer]=\"group\" [group]=\"null\">\n        <span class=\"move-item\" cdkDragHandle>\n          {{group.displayName || group.name}}\n        </span>\n      </ukis-layerentry>\n    </div>\n  </ng-container>\n\n</div>\n", styles: [".list-item{cursor:pointer}.move-item{cursor:move}.cdk-drag-preview{display:flex;align-items:center;padding:15px 10px;box-sizing:border-box;border-radius:2px;box-shadow:0 5px 5px -3px #0003,0 8px 10px 1px #00000024,0 3px 14px 2px #0000001f;overflow:hidden}.cdk-drag-placeholder{opacity:.2}.cdk-drag-animating{transition:transform .25s cubic-bezier(0,0,.2,1)}.example-box:last-child{border:none}.cdk-drop-list-dragging .list-item:not(.cdk-drag-placeholder){transition:transform .25s cubic-bezier(0,0,.2,1)}\n"], components: [{ type: LayerentryGroupComponent, selector: "ukis-layerentry-group", inputs: ["layersSvc", "mapState", "group", "layerGroups"] }, { type: LayerentryComponent, selector: "ukis-layerentry", inputs: ["layersSvc", "mapState", "layer", "group", "layerGroups", "expanded", "expandable"], outputs: ["update"] }], directives: [{ type: i5.CdkDropList, selector: "[cdkDropList], cdk-drop-list", inputs: ["cdkDropListConnectedTo", "cdkDropListData", "cdkDropListOrientation", "id", "cdkDropListLockAxis", "cdkDropListDisabled", "cdkDropListSortingDisabled", "cdkDropListEnterPredicate", "cdkDropListSortPredicate", "cdkDropListAutoScrollDisabled", "cdkDropListAutoScrollStep"], outputs: ["cdkDropListDropped", "cdkDropListEntered", "cdkDropListExited", "cdkDropListSorted"], exportAs: ["cdkDropList"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i5.CdkDrag, selector: "[cdkDrag]", inputs: ["cdkDragData", "cdkDragLockAxis", "cdkDragRootElement", "cdkDragBoundary", "cdkDragStartDelay", "cdkDragFreeDragPosition", "cdkDragDisabled", "cdkDragConstrainPosition", "cdkDragPreviewClass", "cdkDragPreviewContainer"], outputs: ["cdkDragStarted", "cdkDragReleased", "cdkDragEnded", "cdkDragEntered", "cdkDragExited", "cdkDragDropped", "cdkDragMoved"], exportAs: ["cdkDrag"] }, { type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i5.CdkDragHandle, selector: "[cdkDragHandle]", inputs: ["cdkDragHandleDisabled"] }], pipes: { "reverse": ReversePipe, "itemsfilter": ItemsFilterPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: LayerControlComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ukis-layer-control', template: "<div cdkDropList (cdkDropListDropped)=\"drop($event)\"\n  [cdkDropListData]=\"layergroups | itemsfilter: checkClassHide | reverse\">\n  <ng-container *ngFor=\"let group of layergroups | itemsfilter: checkClassHide | reverse\">\n    <div class=\"list-item\" cdkDragLockAxis=\"y\" cdkDrag [cdkDragData]=\"{id:group.id}\">\n      <ukis-layerentry-group *ngIf=\" isLayerGroup(group) && group.filtertype===layerfilter\" [layersSvc]=\"layersSvc\"\n        [mapState]=\"mapStateSvc\" [group]=\"group\" [layerGroups]=\"layergroups\">\n        <span class=\"move-item\" cdkDragHandle>\n          {{group.displayName || group.name}}\n        </span>\n      </ukis-layerentry-group>\n      <ukis-layerentry *ngIf=\"!isLayerGroup(group) && group.filtertype === layerfilter\" [layerGroups]=\"layergroups\"\n        [expanded]=\"false\" [layersSvc]=\"layersSvc\" [mapState]=\"mapStateSvc\" [layer]=\"group\" [group]=\"null\">\n        <span class=\"move-item\" cdkDragHandle>\n          {{group.displayName || group.name}}\n        </span>\n      </ukis-layerentry>\n    </div>\n  </ng-container>\n\n</div>\n", styles: [".list-item{cursor:pointer}.move-item{cursor:move}.cdk-drag-preview{display:flex;align-items:center;padding:15px 10px;box-sizing:border-box;border-radius:2px;box-shadow:0 5px 5px -3px #0003,0 8px 10px 1px #00000024,0 3px 14px 2px #0000001f;overflow:hidden}.cdk-drag-placeholder{opacity:.2}.cdk-drag-animating{transition:transform .25s cubic-bezier(0,0,.2,1)}.example-box:last-child{border:none}.cdk-drop-list-dragging .list-item:not(.cdk-drag-placeholder){transition:transform .25s cubic-bezier(0,0,.2,1)}\n"] }]
        }], ctorParameters: function () { return []; }, propDecorators: { layersSvc: [{
                type: Input,
                args: ['layersSvc']
            }], mapStateSvc: [{
                type: Input,
                args: ['mapStateSvc']
            }], layerfilter: [{
                type: Input,
                args: ['layerfilter']
            }] } });

class BaseLayerControlComponent {
    constructor() {
        this.layergroups = [];
    }
    ngOnInit() {
        this.layerGroupsSubscription = this.layersSvc.getLayerGroups().subscribe(layergroups => {
            this.layergroups = layergroups.filter((group) => group.filtertype === 'Baselayers');
            // console.log(this.layergroups)
        });
    }
    isLayerGroup(group) {
        if (group instanceof LayerGroup) {
            return true;
        }
        else {
            return false;
        }
    }
    ngOnDestroy() {
        this.layerGroupsSubscription.unsubscribe();
    }
}
BaseLayerControlComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: BaseLayerControlComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
BaseLayerControlComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.6", type: BaseLayerControlComponent, selector: "ukis-base-layer-control", inputs: { layersSvc: "layersSvc", mapStateSvc: "mapStateSvc" }, ngImport: i0, template: "<div class=\"list-item\" *ngFor=\"let group of layergroups | reverse;\">\n  <ukis-layerentry-group *ngIf=\"isLayerGroup(group)\" [layersSvc]=\"layersSvc\" [mapState]=\"mapStateSvc\" [group]=\"group\"\n    [layerGroups]=\"layergroups\"></ukis-layerentry-group>\n\n  <ukis-layerentry *ngIf=\"!isLayerGroup(group)\" [layerGroups]=\"layergroups\" [expanded]=\"false\" [layersSvc]=\"layersSvc\"\n    [mapState]=\"mapStateSvc\" [layer]=\"group\" [group]=\"null\"></ukis-layerentry>\n</div>\n", styles: [""], components: [{ type: LayerentryGroupComponent, selector: "ukis-layerentry-group", inputs: ["layersSvc", "mapState", "group", "layerGroups"] }, { type: LayerentryComponent, selector: "ukis-layerentry", inputs: ["layersSvc", "mapState", "layer", "group", "layerGroups", "expanded", "expandable"], outputs: ["update"] }], directives: [{ type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "reverse": ReversePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: BaseLayerControlComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ukis-base-layer-control', template: "<div class=\"list-item\" *ngFor=\"let group of layergroups | reverse;\">\n  <ukis-layerentry-group *ngIf=\"isLayerGroup(group)\" [layersSvc]=\"layersSvc\" [mapState]=\"mapStateSvc\" [group]=\"group\"\n    [layerGroups]=\"layergroups\"></ukis-layerentry-group>\n\n  <ukis-layerentry *ngIf=\"!isLayerGroup(group)\" [layerGroups]=\"layergroups\" [expanded]=\"false\" [layersSvc]=\"layersSvc\"\n    [mapState]=\"mapStateSvc\" [layer]=\"group\" [group]=\"null\"></ukis-layerentry>\n</div>\n", styles: [""] }]
        }], ctorParameters: function () { return []; }, propDecorators: { layersSvc: [{
                type: Input,
                args: ['layersSvc']
            }], mapStateSvc: [{
                type: Input,
                args: ['mapStateSvc']
            }] } });

class LayerControlModule {
}
LayerControlModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: LayerControlModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
LayerControlModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: LayerControlModule, declarations: [LayerControlComponent, LayerentryComponent, LayerentryGroupComponent, ObjTypePipe, ItemsFilterPipe, ReversePipe, BaseLayerControlComponent], imports: [CommonModule, ClarityModule, FormsModule, DragDropModule, CoreUiModule], exports: [LayerControlComponent, LayerentryComponent, LayerentryGroupComponent, ObjTypePipe, ItemsFilterPipe, ReversePipe, BaseLayerControlComponent] });
LayerControlModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: LayerControlModule, imports: [[CommonModule, ClarityModule, FormsModule, DragDropModule, CoreUiModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: LayerControlModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [LayerControlComponent, LayerentryComponent, LayerentryGroupComponent, ObjTypePipe, ItemsFilterPipe, ReversePipe, BaseLayerControlComponent],
                    imports: [CommonModule, ClarityModule, FormsModule, DragDropModule, CoreUiModule],
                    exports: [LayerControlComponent, LayerentryComponent, LayerentryGroupComponent, ObjTypePipe, ItemsFilterPipe, ReversePipe, BaseLayerControlComponent],
                }]
        }] });

/*
 * Public API Surface of layer-control
 */

/**
 * Generated bundle index. Do not edit.
 */

export { BaseLayerControlComponent, ItemsFilterPipe, LayerControlComponent, LayerControlModule, LayerentryComponent, LayerentryGroupComponent, ObjTypePipe, ReversePipe };
//# sourceMappingURL=dlr-eoc-layer-control.mjs.map
