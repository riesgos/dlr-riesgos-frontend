import LayerGroup from 'ol/layer/Group';
import { unByKey } from 'ol/Observable';
export function flattenLayers(layers) {
    let flattenedLayers = [];
    for (const layer of layers) {
        if (layer instanceof LayerGroup) {
            const subLayers = layer.getLayers().getArray();
            const flattenedSubLayers = flattenLayers(subLayers);
            flattenedLayers = Array.prototype.concat(flattenedLayers, flattenedSubLayers);
        }
        else {
            // this cast is ok: since `layer` is no LayerGroup, it must be a Layer.
            // See the `Subclasses` section here: https://openlayers.org/en/latest/apidoc/module-ol_layer_Base-BaseLayer.html
            flattenedLayers.push(layer);
        }
    }
    return flattenedLayers;
}
/** Experimental: This is an experimental technology Check the Browser compatibility table carefully before using this in production. */
/**
 * Merges all layers of a map into one canvas image.
 * Assumes that the ``targetCanvas`` has the same size as the map! If it doesn't, use `scaledMapToSingleCanvas` instead.
 * Create a target-canvas of an appropriate size.
 *  1. Trigger a layer-re-render.
 *  2. For each layer, we capture the 'postrender' event ...
 *  3. ... and copy the canvas-bitmap into the target.
 *
 * Note: if the user moves the original map while the render-process is still ongoing, this can distort the output.
 * We would suggest to deactivate user-interactions until the 'onDone' callback has been received.
 *
 * Note also: Before passing the canvas, set its drawing-buffer size: `canvas.width` and `canvas.height`.
 * This is the size of the actually drawn image in pixels.
 * Note that this value may differ from clientWidth/clientHeight: that is the size to which the actual image is scaled to in the DOM.
 */
export function mapToSingleCanvas(map, targetCanvas, onDone, keepSynced = false) {
    // Step 0: inspecting targetCanvas
    const targetContext = targetCanvas.getContext('2d');
    if (!targetContext) {
        throw new Error('The target-canvas needs to use a 2d-context.');
    }
    if (!targetCanvas.width || !targetCanvas.height) {
        throw new Error('TargetCanvas: width or height have not been set.');
    }
    targetContext.clearRect(0, 0, targetCanvas.width, targetCanvas.height);
    const mapSize = map.getSize();
    const mapResolution = map.getView().getResolution();
    targetCanvas.width = mapSize[0];
    targetCanvas.height = mapSize[1];
    const layers = flattenLayers(map.getLayers().getArray());
    const subscriptions = [];
    for (const layer of layers) {
        if (layer.getVisible() && layer.getOpacity() > 0.0) {
            // Step 2: catch each layer's postrender event.
            // Note that ol/renderer/webgl/* does not call `this.postRender(context, frameState)`
            // in `renderFrame` - so heatmaps won't be copied here!
            const key = layer.on('postrender', (event) => {
                const sourceContext = event.context;
                const sourceCanvas = sourceContext.canvas;
                // Step 3: copy source bitmap to target-canvas.
                targetContext.drawImage(sourceCanvas, 0, 0, sourceCanvas.clientWidth, sourceCanvas.clientHeight, 0, 0, targetCanvas.width, targetCanvas.height);
            });
            if (Array.isArray(key)) {
                key.map(k => subscriptions.push(k));
            }
            else {
                subscriptions.push(key);
            }
        }
    }
    if (keepSynced) {
        map.on('rendercomplete', (evt) => {
            onDone(targetCanvas);
        });
    }
    else {
        // if we don't want the canvas to remain in sync with the map, we unsubscribe to further changes here.
        map.once('rendercomplete', (evt) => {
            // note that a map-render-event does not have a context ... contrary to a layer-render-event.
            for (const key of subscriptions) {
                unByKey(key);
            }
            onDone(targetCanvas);
        });
    }
    // Step 1: trigger a re-render of the map.
    map.renderSync();
}
/**
 * Copies a map's layers onto a single canvas.
 * For this, we ...
 *  1. Update the original map's size to match the target-canvas.
 *  2. Get an image of the scaled map
 *  3. Reset the map's dimensions to the initial values.
 *
 * Note: if the user moves the original map while the render-process is still ongoing, this can distort the output.
 * We would suggest to deactivate user-interactions until the 'done' callback has been received.
 *
 * Note also: Before passing the canvas, set its drawing-buffer size: `canvas.width` and `canvas.height`.
 * This is the size of the actually drawn image in pixels.
 * Note that this value may differ from clientWidth/clientHeight: that is the size to which the actual image is scaled to in the DOM.
 */
export function scaledMapToSingleCanvas(map, targetCanvas, onDone, keepSynced = false) {
    /* An alternative approach would be to create a new map with the desired size and copies of the old map's layers.
     * This way we wouldn't have to mess with the original map's size.
     * But unfortunately openlayers provides no means of cloning a layer.
     * I could not find one, either: neither of JSON.parse, lodash.cloneDeep, ramda.clone or rfdc works here.
     */
    // Step 1: adjust map-size to match targetCanvas.
    const initialMapSize = map.getSize();
    const initialMapResolution = map.getView().getResolution();
    map.setSize([targetCanvas.width, targetCanvas.height]);
    const scale = Math.min(targetCanvas.width / initialMapSize[0], targetCanvas.height / initialMapSize[1]);
    map.getView().setResolution(initialMapResolution / scale);
    // Step 2: get image of scaled map
    mapToSingleCanvas(map, targetCanvas, (updatedTargetCanvas) => {
        // Step 3: set map-size back to initial values.
        map.setSize(initialMapSize);
        map.getView().setResolution(initialMapResolution);
        onDone(updatedTargetCanvas);
    }, keepSynced);
}
/**
 * A comfort-function for getting a snapshot of a map into a canvas.
 * Halts all map-interactions to prevent the user from panning the map during rendering.
 * Sets the canvas' internal drawing-buffer-size: this way, the canvas' contents can be exported
 * in the drawing-buffer-size, which may differ from the display-size (the latter is set by the DOM/CSS).
 *
 * Example usage:
 * ```
 *   previewButton.addEventListener('click', () => {
 *   simpleMapToCanvas(map, previewCanvas, paper.widthPx, paper.heightPx, (updated) => {
 *       console.log('done');
 *   });
 *   downloadButton.addEventListener('click', () => {
 *      downloadUrl(previewCanvas.toDataURL('image/png'), 'full');
 *   });
 * ```
 */
export function simpleMapToCanvas(map, targetCanvas, drawingBufferWidth, drawingBufferHeight, onDone, keepSynced = false) {
    // Halting interactions: prevents user from panning map during drawing process.
    const interactions = map.getInteractions();
    interactions.forEach((interaction) => {
        interaction.setActive(false);
    });
    if (drawingBufferHeight && drawingBufferWidth) {
        // Before passing the canvas, set its drawing-buffer size: `canvas.width` and `canvas.height`.
        // This is the size of the actually drawn image in pixels.
        // Note that this value may differ from clientWidth/clientHeight:
        // that is the size to which the actual image is scaled to in the DOM.
        targetCanvas.width = drawingBufferWidth;
        targetCanvas.height = drawingBufferHeight;
    }
    scaledMapToSingleCanvas(map, targetCanvas, (updatedCanvas) => {
        // reactivating interactions
        interactions.forEach((interaction) => {
            interaction.setActive(true);
        });
        if (onDone) {
            onDone(updatedCanvas);
        }
    }, keepSynced);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMtb2wuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy91dGlscy1tYXBzL3NyYy9saWIvb2wvdXRpbHMtb2wudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBR0EsT0FBTyxVQUFVLE1BQU0sZ0JBQWdCLENBQUM7QUFHeEMsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQU94QyxNQUFNLFVBQVUsYUFBYSxDQUFDLE1BQW1CO0lBQzdDLElBQUksZUFBZSxHQUFpQixFQUFFLENBQUM7SUFDdkMsS0FBSyxNQUFNLEtBQUssSUFBSSxNQUFNLEVBQUU7UUFDeEIsSUFBSSxLQUFLLFlBQVksVUFBVSxFQUFFO1lBQzdCLE1BQU0sU0FBUyxHQUFHLEtBQUssQ0FBQyxTQUFTLEVBQUUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUMvQyxNQUFNLGtCQUFrQixHQUFHLGFBQWEsQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUNwRCxlQUFlLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsZUFBZSxFQUFFLGtCQUFrQixDQUFDLENBQUM7U0FDakY7YUFBTTtZQUNILHVFQUF1RTtZQUN2RSxpSEFBaUg7WUFDakgsZUFBZSxDQUFDLElBQUksQ0FBQyxLQUFtQixDQUFDLENBQUM7U0FDN0M7S0FDSjtJQUNELE9BQU8sZUFBZSxDQUFDO0FBQzNCLENBQUM7QUFJRCx3SUFBd0k7QUFDeEk7Ozs7Ozs7Ozs7Ozs7O0dBY0c7QUFDSCxNQUFNLFVBQVUsaUJBQWlCLENBQUMsR0FBUSxFQUFFLFlBQWlELEVBQ3pGLE1BQTBFLEVBQUUsVUFBVSxHQUFHLEtBQUs7SUFFOUYsa0NBQWtDO0lBQ2xDLE1BQU0sYUFBYSxHQUFHLFlBQVksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDcEQsSUFBSSxDQUFDLGFBQWEsRUFBRTtRQUNoQixNQUFNLElBQUksS0FBSyxDQUFDLDhDQUE4QyxDQUFDLENBQUM7S0FDbkU7SUFDRCxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLEVBQUU7UUFDN0MsTUFBTSxJQUFJLEtBQUssQ0FBQyxrREFBa0QsQ0FBQyxDQUFDO0tBQ3ZFO0lBQ0QsYUFBYSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLFlBQVksQ0FBQyxLQUFLLEVBQUUsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBRXZFLE1BQU0sT0FBTyxHQUFHLEdBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUM5QixNQUFNLGFBQWEsR0FBRyxHQUFHLENBQUMsT0FBTyxFQUFFLENBQUMsYUFBYSxFQUFFLENBQUM7SUFDcEQsWUFBWSxDQUFDLEtBQUssR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDaEMsWUFBWSxDQUFDLE1BQU0sR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFakMsTUFBTSxNQUFNLEdBQUcsYUFBYSxDQUFDLEdBQUcsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO0lBQ3pELE1BQU0sYUFBYSxHQUFnQixFQUFFLENBQUM7SUFDdEMsS0FBSyxNQUFNLEtBQUssSUFBSSxNQUFNLEVBQUU7UUFDeEIsSUFBSSxLQUFLLENBQUMsVUFBVSxFQUFFLElBQUksS0FBSyxDQUFDLFVBQVUsRUFBRSxHQUFHLEdBQUcsRUFBRTtZQUNoRCwrQ0FBK0M7WUFDL0MscUZBQXFGO1lBQ3JGLHVEQUF1RDtZQUN2RCxNQUFNLEdBQUcsR0FBRyxLQUFLLENBQUMsRUFBRSxDQUFDLFlBQVksRUFBRSxDQUFDLEtBQWtCLEVBQUUsRUFBRTtnQkFDdEQsTUFBTSxhQUFhLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQztnQkFDcEMsTUFBTSxZQUFZLEdBQUcsYUFBYSxDQUFDLE1BQTJCLENBQUM7Z0JBQy9ELCtDQUErQztnQkFDL0MsYUFBYSxDQUFDLFNBQVMsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxZQUFZLENBQUMsV0FBVyxFQUFFLFlBQVksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxZQUFZLENBQUMsS0FBSyxFQUFFLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUNwSixDQUFDLENBQUMsQ0FBQztZQUNILElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBQztnQkFDckIsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUNyQztpQkFBSTtnQkFDSCxhQUFhLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQ3pCO1NBQ0o7S0FDSjtJQUVELElBQUksVUFBVSxFQUFFO1FBQ1osR0FBRyxDQUFDLEVBQUUsQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDLEdBQWdCLEVBQUUsRUFBRTtZQUMxQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDekIsQ0FBQyxDQUFDLENBQUM7S0FDTjtTQUFNO1FBQ0gsc0dBQXNHO1FBQ3RHLEdBQUcsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQyxHQUFnQixFQUFFLEVBQUU7WUFDNUMsNkZBQTZGO1lBQzdGLEtBQUssTUFBTSxHQUFHLElBQUksYUFBYSxFQUFFO2dCQUM3QixPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7YUFDaEI7WUFDRCxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDekIsQ0FBQyxDQUFDLENBQUM7S0FDTjtJQUVELDBDQUEwQztJQUMxQyxHQUFHLENBQUMsVUFBVSxFQUFFLENBQUM7QUFFckIsQ0FBQztBQUdEOzs7Ozs7Ozs7Ozs7O0dBYUc7QUFDSCxNQUFNLFVBQVUsdUJBQXVCLENBQUMsR0FBUSxFQUFFLFlBQWlELEVBQy9GLE1BQTBFLEVBQUUsVUFBVSxHQUFHLEtBQUs7SUFDOUY7Ozs7T0FJRztJQUVILGlEQUFpRDtJQUNqRCxNQUFNLGNBQWMsR0FBRyxHQUFHLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDckMsTUFBTSxvQkFBb0IsR0FBRyxHQUFHLENBQUMsT0FBTyxFQUFFLENBQUMsYUFBYSxFQUFFLENBQUM7SUFDM0QsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLFlBQVksQ0FBQyxLQUFLLEVBQUUsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDdkQsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsS0FBSyxHQUFHLGNBQWMsQ0FBQyxDQUFDLENBQUMsRUFBRSxZQUFZLENBQUMsTUFBTSxHQUFHLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3hHLEdBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxhQUFhLENBQUMsb0JBQW9CLEdBQUcsS0FBSyxDQUFDLENBQUM7SUFFMUQsa0NBQWtDO0lBQ2xDLGlCQUFpQixDQUFDLEdBQUcsRUFBRSxZQUFZLEVBQUUsQ0FBQyxtQkFBc0MsRUFBRSxFQUFFO1FBQzVFLCtDQUErQztRQUMvQyxHQUFHLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQzVCLEdBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxhQUFhLENBQUMsb0JBQW9CLENBQUMsQ0FBQztRQUNsRCxNQUFNLENBQUMsbUJBQW1CLENBQUMsQ0FBQztJQUNoQyxDQUFDLEVBQUUsVUFBVSxDQUFDLENBQUM7QUFDbkIsQ0FBQztBQUdEOzs7Ozs7Ozs7Ozs7Ozs7O0dBZ0JHO0FBQ0gsTUFBTSxVQUFVLGlCQUFpQixDQUFDLEdBQVEsRUFBRSxZQUFpRCxFQUFFLGtCQUEyQixFQUFFLG1CQUE0QixFQUNwSixNQUE4RCxFQUFFLFVBQVUsR0FBRyxLQUFLO0lBRWxGLCtFQUErRTtJQUMvRSxNQUFNLFlBQVksR0FBRyxHQUFHLENBQUMsZUFBZSxFQUFFLENBQUM7SUFDM0MsWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDLFdBQXdCLEVBQUUsRUFBRTtRQUM5QyxXQUFXLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ2pDLENBQUMsQ0FBQyxDQUFDO0lBRUgsSUFBSSxtQkFBbUIsSUFBSSxrQkFBa0IsRUFBRTtRQUMzQyw4RkFBOEY7UUFDOUYsMERBQTBEO1FBQzFELGlFQUFpRTtRQUNqRSxzRUFBc0U7UUFDdEUsWUFBWSxDQUFDLEtBQUssR0FBRyxrQkFBa0IsQ0FBQztRQUN4QyxZQUFZLENBQUMsTUFBTSxHQUFHLG1CQUFtQixDQUFDO0tBQzdDO0lBRUQsdUJBQXVCLENBQUMsR0FBRyxFQUFFLFlBQVksRUFBRSxDQUFDLGFBQWEsRUFBRSxFQUFFO1FBRXpELDRCQUE0QjtRQUM1QixZQUFZLENBQUMsT0FBTyxDQUFDLENBQUMsV0FBd0IsRUFBRSxFQUFFO1lBQzlDLFdBQVcsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDaEMsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFJLE1BQU0sRUFBRTtZQUNSLE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBQztTQUN6QjtJQUNMLENBQUMsRUFBRSxVQUFVLENBQUMsQ0FBQztBQUNuQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWFwLCBWaWV3IH0gZnJvbSAnb2wnO1xuaW1wb3J0IHsgTGF5ZXIgfSBmcm9tICdvbC9sYXllcic7XG5pbXBvcnQgQmFzZUxheWVyIGZyb20gJ29sL2xheWVyL0Jhc2UnO1xuaW1wb3J0IExheWVyR3JvdXAgZnJvbSAnb2wvbGF5ZXIvR3JvdXAnO1xuaW1wb3J0IFJlbmRlckV2ZW50IGZyb20gJ29sL3JlbmRlci9FdmVudCc7XG5pbXBvcnQgeyBFdmVudHNLZXkgfSBmcm9tICdvbC9ldmVudHMnO1xuaW1wb3J0IHsgdW5CeUtleSB9IGZyb20gJ29sL09ic2VydmFibGUnO1xuaW1wb3J0IEludGVyYWN0aW9uIGZyb20gJ29sL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uJztcblxuXG5cblxuXG5leHBvcnQgZnVuY3Rpb24gZmxhdHRlbkxheWVycyhsYXllcnM6IEJhc2VMYXllcltdKTogTGF5ZXI8YW55PltdIHtcbiAgICBsZXQgZmxhdHRlbmVkTGF5ZXJzOiBMYXllcjxhbnk+W10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIGxheWVycykge1xuICAgICAgICBpZiAobGF5ZXIgaW5zdGFuY2VvZiBMYXllckdyb3VwKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJMYXllcnMgPSBsYXllci5nZXRMYXllcnMoKS5nZXRBcnJheSgpO1xuICAgICAgICAgICAgY29uc3QgZmxhdHRlbmVkU3ViTGF5ZXJzID0gZmxhdHRlbkxheWVycyhzdWJMYXllcnMpO1xuICAgICAgICAgICAgZmxhdHRlbmVkTGF5ZXJzID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdChmbGF0dGVuZWRMYXllcnMsIGZsYXR0ZW5lZFN1YkxheWVycyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGlzIGNhc3QgaXMgb2s6IHNpbmNlIGBsYXllcmAgaXMgbm8gTGF5ZXJHcm91cCwgaXQgbXVzdCBiZSBhIExheWVyLlxuICAgICAgICAgICAgLy8gU2VlIHRoZSBgU3ViY2xhc3Nlc2Agc2VjdGlvbiBoZXJlOiBodHRwczovL29wZW5sYXllcnMub3JnL2VuL2xhdGVzdC9hcGlkb2MvbW9kdWxlLW9sX2xheWVyX0Jhc2UtQmFzZUxheWVyLmh0bWxcbiAgICAgICAgICAgIGZsYXR0ZW5lZExheWVycy5wdXNoKGxheWVyIGFzIExheWVyPGFueT4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmbGF0dGVuZWRMYXllcnM7XG59XG5cblxuXG4vKiogRXhwZXJpbWVudGFsOiBUaGlzIGlzIGFuIGV4cGVyaW1lbnRhbCB0ZWNobm9sb2d5IENoZWNrIHRoZSBCcm93c2VyIGNvbXBhdGliaWxpdHkgdGFibGUgY2FyZWZ1bGx5IGJlZm9yZSB1c2luZyB0aGlzIGluIHByb2R1Y3Rpb24uICovXG4vKipcbiAqIE1lcmdlcyBhbGwgbGF5ZXJzIG9mIGEgbWFwIGludG8gb25lIGNhbnZhcyBpbWFnZS5cbiAqIEFzc3VtZXMgdGhhdCB0aGUgYGB0YXJnZXRDYW52YXNgYCBoYXMgdGhlIHNhbWUgc2l6ZSBhcyB0aGUgbWFwISBJZiBpdCBkb2Vzbid0LCB1c2UgYHNjYWxlZE1hcFRvU2luZ2xlQ2FudmFzYCBpbnN0ZWFkLlxuICogQ3JlYXRlIGEgdGFyZ2V0LWNhbnZhcyBvZiBhbiBhcHByb3ByaWF0ZSBzaXplLlxuICogIDEuIFRyaWdnZXIgYSBsYXllci1yZS1yZW5kZXIuXG4gKiAgMi4gRm9yIGVhY2ggbGF5ZXIsIHdlIGNhcHR1cmUgdGhlICdwb3N0cmVuZGVyJyBldmVudCAuLi5cbiAqICAzLiAuLi4gYW5kIGNvcHkgdGhlIGNhbnZhcy1iaXRtYXAgaW50byB0aGUgdGFyZ2V0LlxuICpcbiAqIE5vdGU6IGlmIHRoZSB1c2VyIG1vdmVzIHRoZSBvcmlnaW5hbCBtYXAgd2hpbGUgdGhlIHJlbmRlci1wcm9jZXNzIGlzIHN0aWxsIG9uZ29pbmcsIHRoaXMgY2FuIGRpc3RvcnQgdGhlIG91dHB1dC5cbiAqIFdlIHdvdWxkIHN1Z2dlc3QgdG8gZGVhY3RpdmF0ZSB1c2VyLWludGVyYWN0aW9ucyB1bnRpbCB0aGUgJ29uRG9uZScgY2FsbGJhY2sgaGFzIGJlZW4gcmVjZWl2ZWQuXG4gKlxuICogTm90ZSBhbHNvOiBCZWZvcmUgcGFzc2luZyB0aGUgY2FudmFzLCBzZXQgaXRzIGRyYXdpbmctYnVmZmVyIHNpemU6IGBjYW52YXMud2lkdGhgIGFuZCBgY2FudmFzLmhlaWdodGAuXG4gKiBUaGlzIGlzIHRoZSBzaXplIG9mIHRoZSBhY3R1YWxseSBkcmF3biBpbWFnZSBpbiBwaXhlbHMuXG4gKiBOb3RlIHRoYXQgdGhpcyB2YWx1ZSBtYXkgZGlmZmVyIGZyb20gY2xpZW50V2lkdGgvY2xpZW50SGVpZ2h0OiB0aGF0IGlzIHRoZSBzaXplIHRvIHdoaWNoIHRoZSBhY3R1YWwgaW1hZ2UgaXMgc2NhbGVkIHRvIGluIHRoZSBET00uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBUb1NpbmdsZUNhbnZhcyhtYXA6IE1hcCwgdGFyZ2V0Q2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCB8IE9mZnNjcmVlbkNhbnZhcyxcbiAgICBvbkRvbmU6ICh1cGRhdGVkVGFyZ2V0Q2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCB8IE9mZnNjcmVlbkNhbnZhcykgPT4gdm9pZCwga2VlcFN5bmNlZCA9IGZhbHNlKTogdm9pZCB7XG5cbiAgICAvLyBTdGVwIDA6IGluc3BlY3RpbmcgdGFyZ2V0Q2FudmFzXG4gICAgY29uc3QgdGFyZ2V0Q29udGV4dCA9IHRhcmdldENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGlmICghdGFyZ2V0Q29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB0YXJnZXQtY2FudmFzIG5lZWRzIHRvIHVzZSBhIDJkLWNvbnRleHQuJyk7XG4gICAgfVxuICAgIGlmICghdGFyZ2V0Q2FudmFzLndpZHRoIHx8ICF0YXJnZXRDYW52YXMuaGVpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGFyZ2V0Q2FudmFzOiB3aWR0aCBvciBoZWlnaHQgaGF2ZSBub3QgYmVlbiBzZXQuJyk7XG4gICAgfVxuICAgIHRhcmdldENvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRhcmdldENhbnZhcy53aWR0aCwgdGFyZ2V0Q2FudmFzLmhlaWdodCk7XG5cbiAgICBjb25zdCBtYXBTaXplID0gbWFwLmdldFNpemUoKTtcbiAgICBjb25zdCBtYXBSZXNvbHV0aW9uID0gbWFwLmdldFZpZXcoKS5nZXRSZXNvbHV0aW9uKCk7XG4gICAgdGFyZ2V0Q2FudmFzLndpZHRoID0gbWFwU2l6ZVswXTtcbiAgICB0YXJnZXRDYW52YXMuaGVpZ2h0ID0gbWFwU2l6ZVsxXTtcblxuICAgIGNvbnN0IGxheWVycyA9IGZsYXR0ZW5MYXllcnMobWFwLmdldExheWVycygpLmdldEFycmF5KCkpO1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbnM6IEV2ZW50c0tleVtdID0gW107XG4gICAgZm9yIChjb25zdCBsYXllciBvZiBsYXllcnMpIHtcbiAgICAgICAgaWYgKGxheWVyLmdldFZpc2libGUoKSAmJiBsYXllci5nZXRPcGFjaXR5KCkgPiAwLjApIHtcbiAgICAgICAgICAgIC8vIFN0ZXAgMjogY2F0Y2ggZWFjaCBsYXllcidzIHBvc3RyZW5kZXIgZXZlbnQuXG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgb2wvcmVuZGVyZXIvd2ViZ2wvKiBkb2VzIG5vdCBjYWxsIGB0aGlzLnBvc3RSZW5kZXIoY29udGV4dCwgZnJhbWVTdGF0ZSlgXG4gICAgICAgICAgICAvLyBpbiBgcmVuZGVyRnJhbWVgIC0gc28gaGVhdG1hcHMgd29uJ3QgYmUgY29waWVkIGhlcmUhXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBsYXllci5vbigncG9zdHJlbmRlcicsIChldmVudDogUmVuZGVyRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VDb250ZXh0ID0gZXZlbnQuY29udGV4dDtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VDYW52YXMgPSBzb3VyY2VDb250ZXh0LmNhbnZhcyBhcyBIVE1MQ2FudmFzRWxlbWVudDtcbiAgICAgICAgICAgICAgICAvLyBTdGVwIDM6IGNvcHkgc291cmNlIGJpdG1hcCB0byB0YXJnZXQtY2FudmFzLlxuICAgICAgICAgICAgICAgIHRhcmdldENvbnRleHQuZHJhd0ltYWdlKHNvdXJjZUNhbnZhcywgMCwgMCwgc291cmNlQ2FudmFzLmNsaWVudFdpZHRoLCBzb3VyY2VDYW52YXMuY2xpZW50SGVpZ2h0LCAwLCAwLCB0YXJnZXRDYW52YXMud2lkdGgsIHRhcmdldENhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShrZXkpKXtcbiAgICAgICAgICAgICAga2V5Lm1hcChrID0+IHN1YnNjcmlwdGlvbnMucHVzaChrKSk7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgc3Vic2NyaXB0aW9ucy5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2VlcFN5bmNlZCkge1xuICAgICAgICBtYXAub24oJ3JlbmRlcmNvbXBsZXRlJywgKGV2dDogUmVuZGVyRXZlbnQpID0+IHtcbiAgICAgICAgICAgIG9uRG9uZSh0YXJnZXRDYW52YXMpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiB3ZSBkb24ndCB3YW50IHRoZSBjYW52YXMgdG8gcmVtYWluIGluIHN5bmMgd2l0aCB0aGUgbWFwLCB3ZSB1bnN1YnNjcmliZSB0byBmdXJ0aGVyIGNoYW5nZXMgaGVyZS5cbiAgICAgICAgbWFwLm9uY2UoJ3JlbmRlcmNvbXBsZXRlJywgKGV2dDogUmVuZGVyRXZlbnQpID0+IHtcbiAgICAgICAgICAgIC8vIG5vdGUgdGhhdCBhIG1hcC1yZW5kZXItZXZlbnQgZG9lcyBub3QgaGF2ZSBhIGNvbnRleHQgLi4uIGNvbnRyYXJ5IHRvIGEgbGF5ZXItcmVuZGVyLWV2ZW50LlxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2Ygc3Vic2NyaXB0aW9ucykge1xuICAgICAgICAgICAgICAgIHVuQnlLZXkoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uRG9uZSh0YXJnZXRDYW52YXMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBTdGVwIDE6IHRyaWdnZXIgYSByZS1yZW5kZXIgb2YgdGhlIG1hcC5cbiAgICBtYXAucmVuZGVyU3luYygpO1xuXG59XG5cblxuLyoqXG4gKiBDb3BpZXMgYSBtYXAncyBsYXllcnMgb250byBhIHNpbmdsZSBjYW52YXMuXG4gKiBGb3IgdGhpcywgd2UgLi4uXG4gKiAgMS4gVXBkYXRlIHRoZSBvcmlnaW5hbCBtYXAncyBzaXplIHRvIG1hdGNoIHRoZSB0YXJnZXQtY2FudmFzLlxuICogIDIuIEdldCBhbiBpbWFnZSBvZiB0aGUgc2NhbGVkIG1hcFxuICogIDMuIFJlc2V0IHRoZSBtYXAncyBkaW1lbnNpb25zIHRvIHRoZSBpbml0aWFsIHZhbHVlcy5cbiAqXG4gKiBOb3RlOiBpZiB0aGUgdXNlciBtb3ZlcyB0aGUgb3JpZ2luYWwgbWFwIHdoaWxlIHRoZSByZW5kZXItcHJvY2VzcyBpcyBzdGlsbCBvbmdvaW5nLCB0aGlzIGNhbiBkaXN0b3J0IHRoZSBvdXRwdXQuXG4gKiBXZSB3b3VsZCBzdWdnZXN0IHRvIGRlYWN0aXZhdGUgdXNlci1pbnRlcmFjdGlvbnMgdW50aWwgdGhlICdkb25lJyBjYWxsYmFjayBoYXMgYmVlbiByZWNlaXZlZC5cbiAqXG4gKiBOb3RlIGFsc286IEJlZm9yZSBwYXNzaW5nIHRoZSBjYW52YXMsIHNldCBpdHMgZHJhd2luZy1idWZmZXIgc2l6ZTogYGNhbnZhcy53aWR0aGAgYW5kIGBjYW52YXMuaGVpZ2h0YC5cbiAqIFRoaXMgaXMgdGhlIHNpemUgb2YgdGhlIGFjdHVhbGx5IGRyYXduIGltYWdlIGluIHBpeGVscy5cbiAqIE5vdGUgdGhhdCB0aGlzIHZhbHVlIG1heSBkaWZmZXIgZnJvbSBjbGllbnRXaWR0aC9jbGllbnRIZWlnaHQ6IHRoYXQgaXMgdGhlIHNpemUgdG8gd2hpY2ggdGhlIGFjdHVhbCBpbWFnZSBpcyBzY2FsZWQgdG8gaW4gdGhlIERPTS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlZE1hcFRvU2luZ2xlQ2FudmFzKG1hcDogTWFwLCB0YXJnZXRDYW52YXM6IEhUTUxDYW52YXNFbGVtZW50IHwgT2Zmc2NyZWVuQ2FudmFzLFxuICAgIG9uRG9uZTogKHVwZGF0ZWRUYXJnZXRDYW52YXM6IEhUTUxDYW52YXNFbGVtZW50IHwgT2Zmc2NyZWVuQ2FudmFzKSA9PiB2b2lkLCBrZWVwU3luY2VkID0gZmFsc2UpOiB2b2lkIHtcbiAgICAvKiBBbiBhbHRlcm5hdGl2ZSBhcHByb2FjaCB3b3VsZCBiZSB0byBjcmVhdGUgYSBuZXcgbWFwIHdpdGggdGhlIGRlc2lyZWQgc2l6ZSBhbmQgY29waWVzIG9mIHRoZSBvbGQgbWFwJ3MgbGF5ZXJzLlxuICAgICAqIFRoaXMgd2F5IHdlIHdvdWxkbid0IGhhdmUgdG8gbWVzcyB3aXRoIHRoZSBvcmlnaW5hbCBtYXAncyBzaXplLlxuICAgICAqIEJ1dCB1bmZvcnR1bmF0ZWx5IG9wZW5sYXllcnMgcHJvdmlkZXMgbm8gbWVhbnMgb2YgY2xvbmluZyBhIGxheWVyLlxuICAgICAqIEkgY291bGQgbm90IGZpbmQgb25lLCBlaXRoZXI6IG5laXRoZXIgb2YgSlNPTi5wYXJzZSwgbG9kYXNoLmNsb25lRGVlcCwgcmFtZGEuY2xvbmUgb3IgcmZkYyB3b3JrcyBoZXJlLlxuICAgICAqL1xuXG4gICAgLy8gU3RlcCAxOiBhZGp1c3QgbWFwLXNpemUgdG8gbWF0Y2ggdGFyZ2V0Q2FudmFzLlxuICAgIGNvbnN0IGluaXRpYWxNYXBTaXplID0gbWFwLmdldFNpemUoKTtcbiAgICBjb25zdCBpbml0aWFsTWFwUmVzb2x1dGlvbiA9IG1hcC5nZXRWaWV3KCkuZ2V0UmVzb2x1dGlvbigpO1xuICAgIG1hcC5zZXRTaXplKFt0YXJnZXRDYW52YXMud2lkdGgsIHRhcmdldENhbnZhcy5oZWlnaHRdKTtcbiAgICBjb25zdCBzY2FsZSA9IE1hdGgubWluKHRhcmdldENhbnZhcy53aWR0aCAvIGluaXRpYWxNYXBTaXplWzBdLCB0YXJnZXRDYW52YXMuaGVpZ2h0IC8gaW5pdGlhbE1hcFNpemVbMV0pO1xuICAgIG1hcC5nZXRWaWV3KCkuc2V0UmVzb2x1dGlvbihpbml0aWFsTWFwUmVzb2x1dGlvbiAvIHNjYWxlKTtcblxuICAgIC8vIFN0ZXAgMjogZ2V0IGltYWdlIG9mIHNjYWxlZCBtYXBcbiAgICBtYXBUb1NpbmdsZUNhbnZhcyhtYXAsIHRhcmdldENhbnZhcywgKHVwZGF0ZWRUYXJnZXRDYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSA9PiB7XG4gICAgICAgIC8vIFN0ZXAgMzogc2V0IG1hcC1zaXplIGJhY2sgdG8gaW5pdGlhbCB2YWx1ZXMuXG4gICAgICAgIG1hcC5zZXRTaXplKGluaXRpYWxNYXBTaXplKTtcbiAgICAgICAgbWFwLmdldFZpZXcoKS5zZXRSZXNvbHV0aW9uKGluaXRpYWxNYXBSZXNvbHV0aW9uKTtcbiAgICAgICAgb25Eb25lKHVwZGF0ZWRUYXJnZXRDYW52YXMpO1xuICAgIH0sIGtlZXBTeW5jZWQpO1xufVxuXG5cbi8qKlxuICogQSBjb21mb3J0LWZ1bmN0aW9uIGZvciBnZXR0aW5nIGEgc25hcHNob3Qgb2YgYSBtYXAgaW50byBhIGNhbnZhcy5cbiAqIEhhbHRzIGFsbCBtYXAtaW50ZXJhY3Rpb25zIHRvIHByZXZlbnQgdGhlIHVzZXIgZnJvbSBwYW5uaW5nIHRoZSBtYXAgZHVyaW5nIHJlbmRlcmluZy5cbiAqIFNldHMgdGhlIGNhbnZhcycgaW50ZXJuYWwgZHJhd2luZy1idWZmZXItc2l6ZTogdGhpcyB3YXksIHRoZSBjYW52YXMnIGNvbnRlbnRzIGNhbiBiZSBleHBvcnRlZFxuICogaW4gdGhlIGRyYXdpbmctYnVmZmVyLXNpemUsIHdoaWNoIG1heSBkaWZmZXIgZnJvbSB0aGUgZGlzcGxheS1zaXplICh0aGUgbGF0dGVyIGlzIHNldCBieSB0aGUgRE9NL0NTUykuXG4gKlxuICogRXhhbXBsZSB1c2FnZTpcbiAqIGBgYFxuICogICBwcmV2aWV3QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICogICBzaW1wbGVNYXBUb0NhbnZhcyhtYXAsIHByZXZpZXdDYW52YXMsIHBhcGVyLndpZHRoUHgsIHBhcGVyLmhlaWdodFB4LCAodXBkYXRlZCkgPT4ge1xuICogICAgICAgY29uc29sZS5sb2coJ2RvbmUnKTtcbiAqICAgfSk7XG4gKiAgIGRvd25sb2FkQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICogICAgICBkb3dubG9hZFVybChwcmV2aWV3Q2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyksICdmdWxsJyk7XG4gKiAgIH0pO1xuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaW1wbGVNYXBUb0NhbnZhcyhtYXA6IE1hcCwgdGFyZ2V0Q2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCB8IE9mZnNjcmVlbkNhbnZhcywgZHJhd2luZ0J1ZmZlcldpZHRoPzogbnVtYmVyLCBkcmF3aW5nQnVmZmVySGVpZ2h0PzogbnVtYmVyLFxuICAgIG9uRG9uZT86IChjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50IHwgT2Zmc2NyZWVuQ2FudmFzKSA9PiB2b2lkLCBrZWVwU3luY2VkID0gZmFsc2UpIHtcblxuICAgIC8vIEhhbHRpbmcgaW50ZXJhY3Rpb25zOiBwcmV2ZW50cyB1c2VyIGZyb20gcGFubmluZyBtYXAgZHVyaW5nIGRyYXdpbmcgcHJvY2Vzcy5cbiAgICBjb25zdCBpbnRlcmFjdGlvbnMgPSBtYXAuZ2V0SW50ZXJhY3Rpb25zKCk7XG4gICAgaW50ZXJhY3Rpb25zLmZvckVhY2goKGludGVyYWN0aW9uOiBJbnRlcmFjdGlvbikgPT4ge1xuICAgICAgICBpbnRlcmFjdGlvbi5zZXRBY3RpdmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgaWYgKGRyYXdpbmdCdWZmZXJIZWlnaHQgJiYgZHJhd2luZ0J1ZmZlcldpZHRoKSB7XG4gICAgICAgIC8vIEJlZm9yZSBwYXNzaW5nIHRoZSBjYW52YXMsIHNldCBpdHMgZHJhd2luZy1idWZmZXIgc2l6ZTogYGNhbnZhcy53aWR0aGAgYW5kIGBjYW52YXMuaGVpZ2h0YC5cbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgc2l6ZSBvZiB0aGUgYWN0dWFsbHkgZHJhd24gaW1hZ2UgaW4gcGl4ZWxzLlxuICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyB2YWx1ZSBtYXkgZGlmZmVyIGZyb20gY2xpZW50V2lkdGgvY2xpZW50SGVpZ2h0OlxuICAgICAgICAvLyB0aGF0IGlzIHRoZSBzaXplIHRvIHdoaWNoIHRoZSBhY3R1YWwgaW1hZ2UgaXMgc2NhbGVkIHRvIGluIHRoZSBET00uXG4gICAgICAgIHRhcmdldENhbnZhcy53aWR0aCA9IGRyYXdpbmdCdWZmZXJXaWR0aDtcbiAgICAgICAgdGFyZ2V0Q2FudmFzLmhlaWdodCA9IGRyYXdpbmdCdWZmZXJIZWlnaHQ7XG4gICAgfVxuXG4gICAgc2NhbGVkTWFwVG9TaW5nbGVDYW52YXMobWFwLCB0YXJnZXRDYW52YXMsICh1cGRhdGVkQ2FudmFzKSA9PiB7XG5cbiAgICAgICAgLy8gcmVhY3RpdmF0aW5nIGludGVyYWN0aW9uc1xuICAgICAgICBpbnRlcmFjdGlvbnMuZm9yRWFjaCgoaW50ZXJhY3Rpb246IEludGVyYWN0aW9uKSA9PiB7XG4gICAgICAgICAgICBpbnRlcmFjdGlvbi5zZXRBY3RpdmUodHJ1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChvbkRvbmUpIHtcbiAgICAgICAgICAgIG9uRG9uZSh1cGRhdGVkQ2FudmFzKTtcbiAgICAgICAgfVxuICAgIH0sIGtlZXBTeW5jZWQpO1xufVxuIl19