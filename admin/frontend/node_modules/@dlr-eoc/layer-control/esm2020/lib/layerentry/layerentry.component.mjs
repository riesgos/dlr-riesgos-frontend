import { Component, Input, Output, EventEmitter, HostBinding } from '@angular/core';
// imports only for typings...
import { Layer, WmsLayer, WmtsLayer } from '@dlr-eoc/services-layers';
import * as i0 from "@angular/core";
import * as i1 from "@dlr-eoc/core-ui";
import * as i2 from "@clr/angular";
import * as i3 from "@angular/common";
import * as i4 from "@angular/forms";
export class LayerentryComponent {
    constructor() {
        this.expandable = true;
        this.update = new EventEmitter();
        this.canZoomToLayer = false;
        this.activeTabs = {
            settings: false,
            legend: true,
            description: false,
            changeStyle: false
        };
    }
    get visible() { return this.layer.visible; }
    get cssClass() { return this.layer.cssClass; }
    ;
    set expanded(value) {
        if (this.layer) {
            this.layer.expanded = value;
        }
    }
    get expanded() {
        if (this.layer) {
            return this.layer.expanded;
        }
        else {
            return false;
        }
    }
    /**
     * obj: {any| IDynamicComponent}
     */
    checkIsComponentItem(layer, compProp) {
        // https://stackoverflow.com/a/65347533/10850021
        const obj = layer[compProp];
        let isComp = false;
        if (obj && typeof obj === 'object') {
            if ('component' in obj) {
                if (!obj.inputs) {
                    // https://2ality.com/2014/01/object-assign.html#2.3
                    const layerClone = Object.assign({ __proto__: this.layer['__proto__'] }, layer);
                    console.log(layerClone);
                    if (layerClone && layerClone[compProp]) {
                        delete layerClone[compProp];
                    }
                    obj.inputs = { layer: layerClone };
                }
                else if (obj.inputs && !obj.inputs.layer) {
                    // https://2ality.com/2014/01/object-assign.html#2.3
                    const layerClone = Object.assign({ __proto__: this.layer['__proto__'] }, layer);
                    console.log(layerClone);
                    if (layerClone && layerClone[compProp]) {
                        delete layerClone[compProp];
                    }
                    obj.inputs = Object.assign({ layer: layerClone }, obj.inputs);
                }
                isComp = true;
            }
        }
        return isComp;
    }
    getLayerName(layer) {
        if (layer.displayName) {
            return layer.displayName;
        }
        else {
            return layer.name;
        }
    }
    ngOnInit() {
        if (!this.layersSvc) {
            console.error('you need to provide a layersService!');
        }
        // console.log(this.layer)
        if (!this.layer.legendImg) {
            this.activeTabs.description = true;
            this.activeTabs.legend = false;
            this.activeTabs.settings = false;
            this.activeTabs.changeStyle = false;
        }
        if (!this.layer.legendImg && !this.layer.description) {
            this.activeTabs.description = false;
            this.activeTabs.legend = false;
            this.activeTabs.settings = true;
        }
        if (this.layer.bbox && this.layer.bbox.length >= 4) {
            this.canZoomToLayer = true;
        }
    }
    /**
     * show or hide the layer
     */
    setLayerVisibility(selectedLayer, group) {
        if (!group) {
            if (selectedLayer.filtertype === 'Baselayers') {
                selectedLayer.visible = !selectedLayer.visible;
                const filterdlayers = this.layerGroups.filter((l) => l.filtertype === 'Baselayers');
                // console.log(filterdlayers);
                for (const layer of filterdlayers) {
                    if (layer instanceof Layer && layer.id !== selectedLayer.id) {
                        layer.visible = !selectedLayer.visible;
                        this.layersSvc.updateLayer(layer, layer.filtertype || 'Baselayers');
                    }
                }
            }
            else {
                selectedLayer.visible = !selectedLayer.visible;
                this.layersSvc.updateLayer(selectedLayer, selectedLayer.filtertype || 'Layers'); // TODO check for baselayers!!!!!!
            }
        }
        else {
            if (group.layers.length > 0) {
                /** "radio" for Baselayers */
                if (group.filtertype === 'Baselayers') {
                    for (const layer of group.layers) {
                        layer.visible = layer === selectedLayer;
                    }
                    this.update.emit({
                        layer: this.layer
                    });
                    /** "checkbox" for all other layers */
                }
                else {
                    const tempGroupVisible = group.visible;
                    /** change visibility of the selected layer */
                    selectedLayer.visible = !selectedLayer.visible;
                    /** check if group visibility has changed */
                    if (tempGroupVisible !== group.visible) {
                        this.update.emit({
                            layer: this.layer
                        });
                    }
                    else {
                        /** If the visibility of the group don't changes update only the layer  */
                        this.layersSvc.updateLayer(selectedLayer, selectedLayer.filtertype || 'Layers');
                    }
                }
            }
        }
    }
    /**
     * setLayerIndex
     */
    setLayerIndex(layer, dir, group) {
        // console.log('is First', this.isFirst(layer));
        // console.log('is Last', this.isLast(layer));
        // console.log(layer, group);
        if (group) {
            this.layersSvc.setLayerIndexInGroup(layer, dir, group);
        }
        else {
            this.layersSvc.setGroupLayerIndex(layer, dir);
        }
    }
    /**
     * remove the Layer if possible
     */
    removeLayer(group, selectedLayer) {
        // console.log("delete ", group, selectedLayer)
        if (group) {
            // console.log("delete layer from group")
            this.layersSvc.removeLayerFromGroup(selectedLayer, group);
        }
        else {
            // console.log('delete single layer');
            this.layersSvc.removeLayer(selectedLayer, selectedLayer.filtertype);
        }
    }
    zoomTo(layer) {
        if (this.mapState && layer.bbox && layer.bbox.length >= 4) {
            this.mapState.setExtent(layer.bbox);
        }
    }
    setLayerOpacity(layer) {
        if (!this.group) {
            this.layersSvc.updateLayer(layer, layer.filtertype || 'Layers'); // TODO check for baselayers!!!!!!
        }
        else {
            this.update.emit({
                layer
            });
        }
    }
    checkBaselayer(layer, group) {
        if (layer.filtertype === 'Baselayers' || group && group.filtertype === 'Baselayers') {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * is expandable if layer has legend, description or opacity can be changed
     */
    is_expandable() {
        if (this.group) {
            return !this.layer.legendImg && this.group.filtertype === 'Baselayers';
        }
        else {
            return false; // !this.layer.legendImg; //this.layer.description
        }
    }
    showProperties() {
        if (!this.is_expandable()) {
            this.expanded = !this.expanded;
        }
    }
    switchTab(tabName) {
        for (const key of Object.keys(this.activeTabs)) {
            this.activeTabs[key] = tabName === key;
        }
    }
    isSelectedStyle(styleName) {
        if (this.layer instanceof WmsLayer) {
            return this.layer.params.STYLES === styleName;
        }
        else if (this.layer instanceof WmtsLayer) {
            return this.layer.params.style === styleName;
        }
        else {
            // TODO: how to compare styles for vector layers and custom layers?
            return false;
        }
    }
    executeChangeStyle(evt) {
        const newStyleName = evt.target.value;
        if (this.layer.styles) {
            const newStyle = this.layer.styles.find(s => s.name === newStyleName);
            if (newStyle) {
                this.layer.legendImg = newStyle.legendURL;
                if (this.layer instanceof WmsLayer) {
                    this.layer.params.STYLES = newStyle.name;
                }
                else if (this.layer instanceof WmtsLayer) {
                    this.layer.params.style = newStyle.name;
                }
                this.layersSvc.updateLayer(this.layer, this.layer.filtertype);
            }
        }
    }
    isFirst(layer) {
        if (this.group) {
            return this.layersSvc.isGroupFirst(layer, this.group.layers);
        }
        else {
            return this.layersSvc.isGroupFirst(layer, null, layer.filtertype);
        }
    }
    isLast(layer) {
        if (this.group) {
            return this.layersSvc.isGroupLast(layer, this.group.layers);
        }
        else {
            return this.layersSvc.isGroupLast(layer, null, layer.filtertype);
        }
    }
    getExpandShape() {
        // return this.openProperties ? 'down' : 'right';
        return this.expanded ? { transform: 'rotate(180deg)' } : { transform: 'rotate(90deg)' };
    }
}
LayerentryComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: LayerentryComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
LayerentryComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.6", type: LayerentryComponent, selector: "ukis-layerentry", inputs: { layersSvc: "layersSvc", mapState: "mapState", layer: "layer", group: "group", layerGroups: "layerGroups", expanded: "expanded", expandable: "expandable" }, outputs: { update: "update" }, host: { properties: { "class.layer-visible": "this.visible", "class": "this.cssClass" } }, ngImport: i0, template: "<div class=\"layer\">\n  <div class=\"head\">\n    <!-- layer expand icon -->\n    <clr-icon shape=\"angle\" [ngStyle]=\"getExpandShape()\" class=\"iconButton\" [ngClass]=\"{'disabled': is_expandable()}\"\n      (click)=\"showProperties()\" title=\"Details\"></clr-icon>\n\n    <!-- layer title -->\n    <div #ref class=\"item-title-replacement title\" (click)=\"showProperties()\" [title]=\"getLayerName(layer)\">\n      <ng-content></ng-content>\n    </div>\n    <span *ngIf=\"ref.children.length == 0\" class=\"title\" [title]=\"getLayerName(layer)\" (click)=\"showProperties()\">\n      {{getLayerName(layer)}}\n    </span>\n\n    <!-- setLayerIndex // for reversed layergroups on ngFor up is down -->\n    <span *ngIf=\"!checkBaselayer(layer,group)\">\n      <clr-icon [hidden]=\"layerGroups && layerGroups.length == 1\" class=\"iconButton\" shape=\"arrow\"\n        [ngClass]=\"{'disabled': isLast(layer)}\" (click)=\"setLayerIndex(layer, 'down', group)\" title=\"up\"></clr-icon>\n      <clr-icon [hidden]=\"layerGroups && layerGroups.length == 1\" class=\"iconButton\" shape=\"arrow\"\n        [ngClass]=\"{'disabled': isFirst(layer)}\" (click)=\"setLayerIndex(layer, 'up', group)\" title=\"down\" dir=\"down\">\n      </clr-icon>\n    </span>\n\n    <!-- setLayerVisibility -->\n    <input class=\"hide\" [type]=\"(checkBaselayer(layer,group))?'radio':'checkbox'\" [name]=\"'layer'\" [id]=\"layer.id\"\n      [checked]=\"layer.visible\" (change)=\"setLayerVisibility(layer, group)\">\n    <label [for]=\"layer.id\">\n      <clr-icon *ngIf=\"checkBaselayer(layer,group); else notBaselayer\" class=\"iconButton\"\n        [ngClass]=\"{'is-solid':layer.visible}\" [attr.shape]=\"(layer.visible)?'dot-circle':'circle'\"\n        title=\"{{layer.visible?'Choose another layer':'Show layer'}}\">\n      </clr-icon>\n      <ng-template #notBaselayer>\n        <clr-icon class=\"iconButton\" [ngClass]=\"{'is-solid':layer.visible}\"\n          [attr.shape]=\"(layer.visible)?'eye':'eye-hide'\" title=\"{{layer.visible?'Hide layer':'Show layer'}}\">\n        </clr-icon>\n      </ng-template>\n    </label>\n\n  </div>\n  <div *ngIf=\"expandable && expanded\" class=\"body\">\n    <!-- tools: zoomTo, remove, switch Tab -->\n    <div class=\"tools\">\n      <clr-icon *ngIf=\"!checkBaselayer(layer, group)\" title=\"Layer settings\" shape=\"cog\" class=\"iconButton\"\n        [ngClass]=\"{'active': activeTabs['settings']}\" (click)=\"switchTab('settings')\"></clr-icon>\n      <clr-icon *ngIf=\"layer.legendImg\" title=\"Layer Legend\" shape=\"image\" class=\"iconButton\"\n        [ngClass]=\"{'active': activeTabs['legend']}\" (click)=\"switchTab('legend')\"></clr-icon>\n      <clr-icon *ngIf=\"layer.description\" title=\"Layer info\" shape=\"info-standard\" class=\"iconButton\"\n        [ngClass]=\"{'active': activeTabs['description']}\" (click)=\"switchTab('description')\"></clr-icon>\n      <clr-icon *ngIf=\"layer.styles?.length > 1\" title=\"Change style\" shape=\"cloud-chart\" class=\"iconButton\"\n        [ngClass]=\"{'active': activeTabs['changeStyle']}\" (click)=\"switchTab('changeStyle')\"></clr-icon>\n\n      <clr-icon *ngFor=\"let item of layer.actions\" [attr.shape]=\"item.icon\" class=\"iconButton\"\n        (click)=\"item.action(layer)\" [title]=\"item.title\">\n      </clr-icon>\n\n\n      <span></span>\n      <clr-icon *ngIf=\"canZoomToLayer\" shape=\"zoom-in\" class=\"iconButton\" title=\"Zoom to layer\" (click)=\"zoomTo(layer)\">\n      </clr-icon>\n      <clr-icon *ngIf=\"layer.removable\" shape=\"trash\" class=\"iconButton\" (click)=\"removeLayer(group, layer)\"\n        title=\"Remove layer\"></clr-icon>\n    </div>\n    <div class=\"tabsbody\">\n      <div *ngIf=\"activeTabs.settings\" class=\"layersettings\">\n        <!-- setLayerOpacity -->\n        <div class=\"form-group\">\n          <label [for]=\"'layer_transparency_slider_'+layer.id\">Opacity:</label>\n          <input [id]=\"'layer_transparency_slider_'+layer.id\" type=\"range\" class=\"ukis-range-input opacity-input\"\n            name=\"points\" [value]=\"layer.opacity\" [min]=\"0.0\" [max]=\"1.0\" [step]=\"0.1\" (change)=\"setLayerOpacity(layer)\"\n            [(ngModel)]=\"layer.opacity\" />\n          <span>{{\" \"+layer.opacity}}</span>\n        </div>\n        <ng-container *ngIf=\"checkIsComponentItem(layer, 'action');\">\n          <ukis-dynamic-component [(dynamicComponent)]=\"layer.action\">\n          </ukis-dynamic-component>\n        </ng-container>\n      </div>\n      <!-- show Legend -->\n      <div *ngIf=\"activeTabs.legend && layer.legendImg\">\n        <ng-container *ngIf=\"checkIsComponentItem(layer,'legendImg'); else imageUrl\">\n          <ukis-dynamic-component [(dynamicComponent)]=\"layer.legendImg\"></ukis-dynamic-component>\n        </ng-container>\n\n        <ng-template #imageUrl>\n          <a [href]=\"layer.legendImg\" target=\"_blank\" title=\"Show full Image\"><img [src]=\"layer.legendImg\" /></a>\n        </ng-template>\n      </div>\n      <!-- show Description -->\n      <div *ngIf=\"activeTabs.description && layer.description\">\n        <span [innerHTML]=\"layer.description\"></span>\n      </div>\n      <!-- show style-switcher -->\n      <div *ngIf=\"activeTabs.changeStyle && layer.styles && layer.styles?.length > 1\">\n        <select clrSelect (change)=\"executeChangeStyle($event)\">\n          <option *ngFor=\"let style of layer.styles\" [value]=\"style.name\"\n            [attr.selected]=\"isSelectedStyle(style.name) ? true : null\">{{style.title}}</option>\n        </select>\n      </div>\n    </div>\n\n  </div>\n\n</div>\n", styles: [".title{cursor:pointer}.item-title-replacement:empty{display:none}.body{cursor:default}.tabsbody{overflow:hidden;word-break:break-all}.tabsbody img{height:auto;max-width:100%}\n"], components: [{ type: i1.DynamicComponentComponent, selector: "ukis-dynamic-component", inputs: ["dynamicComponent"], outputs: ["dynamicComponentChange"] }], directives: [{ type: i2.ClrIconCustomTag, selector: "clr-icon" }, { type: i3.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2.ClrLabel, selector: "label", inputs: ["for"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i4.RangeValueAccessor, selector: "input[type=range][formControlName],input[type=range][formControl],input[type=range][ngModel]" }, { type: i4.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { type: i4.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i4.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { type: i2.ClrSelect, selector: "[clrSelect]" }, { type: i4.NgSelectOption, selector: "option", inputs: ["ngValue", "value"] }, { type: i4.ɵNgSelectMultipleOption, selector: "option", inputs: ["ngValue", "value"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: LayerentryComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ukis-layerentry', template: "<div class=\"layer\">\n  <div class=\"head\">\n    <!-- layer expand icon -->\n    <clr-icon shape=\"angle\" [ngStyle]=\"getExpandShape()\" class=\"iconButton\" [ngClass]=\"{'disabled': is_expandable()}\"\n      (click)=\"showProperties()\" title=\"Details\"></clr-icon>\n\n    <!-- layer title -->\n    <div #ref class=\"item-title-replacement title\" (click)=\"showProperties()\" [title]=\"getLayerName(layer)\">\n      <ng-content></ng-content>\n    </div>\n    <span *ngIf=\"ref.children.length == 0\" class=\"title\" [title]=\"getLayerName(layer)\" (click)=\"showProperties()\">\n      {{getLayerName(layer)}}\n    </span>\n\n    <!-- setLayerIndex // for reversed layergroups on ngFor up is down -->\n    <span *ngIf=\"!checkBaselayer(layer,group)\">\n      <clr-icon [hidden]=\"layerGroups && layerGroups.length == 1\" class=\"iconButton\" shape=\"arrow\"\n        [ngClass]=\"{'disabled': isLast(layer)}\" (click)=\"setLayerIndex(layer, 'down', group)\" title=\"up\"></clr-icon>\n      <clr-icon [hidden]=\"layerGroups && layerGroups.length == 1\" class=\"iconButton\" shape=\"arrow\"\n        [ngClass]=\"{'disabled': isFirst(layer)}\" (click)=\"setLayerIndex(layer, 'up', group)\" title=\"down\" dir=\"down\">\n      </clr-icon>\n    </span>\n\n    <!-- setLayerVisibility -->\n    <input class=\"hide\" [type]=\"(checkBaselayer(layer,group))?'radio':'checkbox'\" [name]=\"'layer'\" [id]=\"layer.id\"\n      [checked]=\"layer.visible\" (change)=\"setLayerVisibility(layer, group)\">\n    <label [for]=\"layer.id\">\n      <clr-icon *ngIf=\"checkBaselayer(layer,group); else notBaselayer\" class=\"iconButton\"\n        [ngClass]=\"{'is-solid':layer.visible}\" [attr.shape]=\"(layer.visible)?'dot-circle':'circle'\"\n        title=\"{{layer.visible?'Choose another layer':'Show layer'}}\">\n      </clr-icon>\n      <ng-template #notBaselayer>\n        <clr-icon class=\"iconButton\" [ngClass]=\"{'is-solid':layer.visible}\"\n          [attr.shape]=\"(layer.visible)?'eye':'eye-hide'\" title=\"{{layer.visible?'Hide layer':'Show layer'}}\">\n        </clr-icon>\n      </ng-template>\n    </label>\n\n  </div>\n  <div *ngIf=\"expandable && expanded\" class=\"body\">\n    <!-- tools: zoomTo, remove, switch Tab -->\n    <div class=\"tools\">\n      <clr-icon *ngIf=\"!checkBaselayer(layer, group)\" title=\"Layer settings\" shape=\"cog\" class=\"iconButton\"\n        [ngClass]=\"{'active': activeTabs['settings']}\" (click)=\"switchTab('settings')\"></clr-icon>\n      <clr-icon *ngIf=\"layer.legendImg\" title=\"Layer Legend\" shape=\"image\" class=\"iconButton\"\n        [ngClass]=\"{'active': activeTabs['legend']}\" (click)=\"switchTab('legend')\"></clr-icon>\n      <clr-icon *ngIf=\"layer.description\" title=\"Layer info\" shape=\"info-standard\" class=\"iconButton\"\n        [ngClass]=\"{'active': activeTabs['description']}\" (click)=\"switchTab('description')\"></clr-icon>\n      <clr-icon *ngIf=\"layer.styles?.length > 1\" title=\"Change style\" shape=\"cloud-chart\" class=\"iconButton\"\n        [ngClass]=\"{'active': activeTabs['changeStyle']}\" (click)=\"switchTab('changeStyle')\"></clr-icon>\n\n      <clr-icon *ngFor=\"let item of layer.actions\" [attr.shape]=\"item.icon\" class=\"iconButton\"\n        (click)=\"item.action(layer)\" [title]=\"item.title\">\n      </clr-icon>\n\n\n      <span></span>\n      <clr-icon *ngIf=\"canZoomToLayer\" shape=\"zoom-in\" class=\"iconButton\" title=\"Zoom to layer\" (click)=\"zoomTo(layer)\">\n      </clr-icon>\n      <clr-icon *ngIf=\"layer.removable\" shape=\"trash\" class=\"iconButton\" (click)=\"removeLayer(group, layer)\"\n        title=\"Remove layer\"></clr-icon>\n    </div>\n    <div class=\"tabsbody\">\n      <div *ngIf=\"activeTabs.settings\" class=\"layersettings\">\n        <!-- setLayerOpacity -->\n        <div class=\"form-group\">\n          <label [for]=\"'layer_transparency_slider_'+layer.id\">Opacity:</label>\n          <input [id]=\"'layer_transparency_slider_'+layer.id\" type=\"range\" class=\"ukis-range-input opacity-input\"\n            name=\"points\" [value]=\"layer.opacity\" [min]=\"0.0\" [max]=\"1.0\" [step]=\"0.1\" (change)=\"setLayerOpacity(layer)\"\n            [(ngModel)]=\"layer.opacity\" />\n          <span>{{\" \"+layer.opacity}}</span>\n        </div>\n        <ng-container *ngIf=\"checkIsComponentItem(layer, 'action');\">\n          <ukis-dynamic-component [(dynamicComponent)]=\"layer.action\">\n          </ukis-dynamic-component>\n        </ng-container>\n      </div>\n      <!-- show Legend -->\n      <div *ngIf=\"activeTabs.legend && layer.legendImg\">\n        <ng-container *ngIf=\"checkIsComponentItem(layer,'legendImg'); else imageUrl\">\n          <ukis-dynamic-component [(dynamicComponent)]=\"layer.legendImg\"></ukis-dynamic-component>\n        </ng-container>\n\n        <ng-template #imageUrl>\n          <a [href]=\"layer.legendImg\" target=\"_blank\" title=\"Show full Image\"><img [src]=\"layer.legendImg\" /></a>\n        </ng-template>\n      </div>\n      <!-- show Description -->\n      <div *ngIf=\"activeTabs.description && layer.description\">\n        <span [innerHTML]=\"layer.description\"></span>\n      </div>\n      <!-- show style-switcher -->\n      <div *ngIf=\"activeTabs.changeStyle && layer.styles && layer.styles?.length > 1\">\n        <select clrSelect (change)=\"executeChangeStyle($event)\">\n          <option *ngFor=\"let style of layer.styles\" [value]=\"style.name\"\n            [attr.selected]=\"isSelectedStyle(style.name) ? true : null\">{{style.title}}</option>\n        </select>\n      </div>\n    </div>\n\n  </div>\n\n</div>\n", styles: [".title{cursor:pointer}.item-title-replacement:empty{display:none}.body{cursor:default}.tabsbody{overflow:hidden;word-break:break-all}.tabsbody img{height:auto;max-width:100%}\n"] }]
        }], ctorParameters: function () { return []; }, propDecorators: { visible: [{
                type: HostBinding,
                args: ['class.layer-visible']
            }], cssClass: [{
                type: HostBinding,
                args: ['class']
            }], layersSvc: [{
                type: Input,
                args: ['layersSvc']
            }], mapState: [{
                type: Input,
                args: ['mapState']
            }], layer: [{
                type: Input,
                args: ['layer']
            }], group: [{
                type: Input,
                args: ['group']
            }], layerGroups: [{
                type: Input,
                args: ['layerGroups']
            }], expanded: [{
                type: Input,
                args: ['expanded']
            }], expandable: [{
                type: Input,
                args: ['expandable']
            }], update: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGF5ZXJlbnRyeS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9sYXllci1jb250cm9sL3NyYy9saWIvbGF5ZXJlbnRyeS9sYXllcmVudHJ5LmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2xheWVyLWNvbnRyb2wvc3JjL2xpYi9sYXllcmVudHJ5L2xheWVyZW50cnkuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBVSxLQUFLLEVBQUUsTUFBTSxFQUFFLFlBQVksRUFBRSxXQUFXLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFHNUYsOEJBQThCO0FBQzlCLE9BQU8sRUFDTyxLQUFLLEVBQThCLFFBQVEsRUFBRSxTQUFTLEVBQ25FLE1BQU0sMEJBQTBCLENBQUM7Ozs7OztBQVFsQyxNQUFNLE9BQU8sbUJBQW1CO0lBcUM5QjtRQWZxQixlQUFVLEdBQUcsSUFBSSxDQUFDO1FBRzdCLFdBQU0sR0FBRyxJQUFJLFlBQVksRUFBb0IsQ0FBQztRQUVqRCxtQkFBYyxHQUFHLEtBQUssQ0FBQztRQUV2QixlQUFVLEdBQUc7WUFDbEIsUUFBUSxFQUFFLEtBQUs7WUFDZixNQUFNLEVBQUUsSUFBSTtZQUNaLFdBQVcsRUFBRSxLQUFLO1lBQ2xCLFdBQVcsRUFBRSxLQUFLO1NBQ25CLENBQUM7SUFLRixDQUFDO0lBdENELElBQXdDLE9BQU8sS0FBSyxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztJQUNoRixJQUEwQixRQUFRLEtBQUssT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7SUFPTixDQUFDO0lBQy9ELElBQXVCLFFBQVEsQ0FBQyxLQUFjO1FBQzVDLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTtZQUNkLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxH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QUNILENBQUM7SUFFRCxNQUFNLENBQUMsS0FBSztRQUNWLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTtZQUNkLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDN0Q7YUFBTTtZQUNMLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUM7U0FDbEU7SUFDSCxDQUFDO0lBRUQsY0FBYztRQUNaLGlEQUFpRDtRQUNqRCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUUsU0FBUyxFQUFFLGdCQUFnQixFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsU0FBUyxFQUFFLGVBQWUsRUFBRSxDQUFDO0lBQzFGLENBQUM7O2dIQWpSVSxtQkFBbUI7b0dBQW5CLG1CQUFtQix1VkNkaEMsNitLQXVHQTsyRkR6RmEsbUJBQW1CO2tCQUwvQixTQUFTOytCQUNFLGlCQUFpQjswRUFLYSxPQUFPO3NCQUE5QyxXQUFXO3VCQUFDLHFCQUFxQjtnQkFDUixRQUFRO3NCQUFqQyxXQUFXO3VCQUFDLE9BQU87Z0JBRUEsU0FBUztzQkFBNUIsS0FBSzt1QkFBQyxXQUFXO2dCQUNDLFFBQVE7c0JBQTFCLEtBQUs7dUJBQUMsVUFBVTtnQkFDRCxLQUFLO3NCQUFwQixLQUFLO3VCQUFDLE9BQU87Z0JBRUUsS0FBSztzQkFBcEIsS0FBSzt1QkFBQyxPQUFPO2dCQUNRLFdBQVc7c0JBQWhDLEtBQUs7dUJBQUMsYUFBYTtnQkFDRyxRQUFRO3NCQUE5QixLQUFLO3VCQUFDLFVBQVU7Z0JBWUksVUFBVTtzQkFBOUIsS0FBSzt1QkFBQyxZQUFZO2dCQUdULE1BQU07c0JBQWYsTUFBTSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0LCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIsIEhvc3RCaW5kaW5nIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJRHluYW1pY0NvbXBvbmVudCB9IGZyb20gJ0BkbHItZW9jL2NvcmUtdWknO1xuXG4vLyBpbXBvcnRzIG9ubHkgZm9yIHR5cGluZ3MuLi5cbmltcG9ydCB7XG4gIExheWVyR3JvdXAsIExheWVyLCBSYXN0ZXJMYXllciwgTGF5ZXJzU2VydmljZSwgV21zTGF5ZXIsIFdtdHNMYXllclxufSBmcm9tICdAZGxyLWVvYy9zZXJ2aWNlcy1sYXllcnMnO1xuaW1wb3J0IHsgTWFwU3RhdGVTZXJ2aWNlIH0gZnJvbSAnQGRsci1lb2Mvc2VydmljZXMtbWFwLXN0YXRlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAndWtpcy1sYXllcmVudHJ5JyxcbiAgdGVtcGxhdGVVcmw6ICcuL2xheWVyZW50cnkuY29tcG9uZW50Lmh0bWwnLFxuICBzdHlsZVVybHM6IFsnLi9sYXllcmVudHJ5LmNvbXBvbmVudC5zY3NzJ11cbn0pXG5leHBvcnQgY2xhc3MgTGF5ZXJlbnRyeUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIEBIb3N0QmluZGluZygnY2xhc3MubGF5ZXItdmlzaWJsZScpIGdldCB2aXNpYmxlKCkgeyByZXR1cm4gdGhpcy5sYXllci52aXNpYmxlOyB9XG4gIEBIb3N0QmluZGluZygnY2xhc3MnKSBnZXQgY3NzQ2xhc3MoKSB7IHJldHVybiB0aGlzLmxheWVyLmNzc0NsYXNzOyB9XG5cbiAgQElucHV0KCdsYXllcnNTdmMnKSBsYXllcnNTdmM6IExheWVyc1NlcnZpY2U7XG4gIEBJbnB1dCgnbWFwU3RhdGUnKSBtYXBTdGF0ZT86IE1hcFN0YXRlU2VydmljZTtcbiAgQElucHV0KCdsYXllcicpIGxheWVyOiBMYXllcjtcblxuICBASW5wdXQoJ2dyb3VwJykgZ3JvdXA/OiBMYXllckdyb3VwO1xuICBASW5wdXQoJ2xheWVyR3JvdXBzJykgbGF5ZXJHcm91cHM/OiBBcnJheTxMYXllciB8IExheWVyR3JvdXA+OztcbiAgQElucHV0KCdleHBhbmRlZCcpIHNldCBleHBhbmRlZCh2YWx1ZTogYm9vbGVhbikge1xuICAgIGlmICh0aGlzLmxheWVyKSB7XG4gICAgICB0aGlzLmxheWVyLmV4cGFuZGVkID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIGdldCBleHBhbmRlZCgpIHtcbiAgICBpZiAodGhpcy5sYXllcikge1xuICAgICAgcmV0dXJuIHRoaXMubGF5ZXIuZXhwYW5kZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgQElucHV0KCdleHBhbmRhYmxlJykgZXhwYW5kYWJsZSA9IHRydWU7XG5cblxuICBAT3V0cHV0KCkgdXBkYXRlID0gbmV3IEV2ZW50RW1pdHRlcjx7IGxheWVyOiBMYXllciB9PigpO1xuXG4gIHB1YmxpYyBjYW5ab29tVG9MYXllciA9IGZhbHNlO1xuXG4gIHB1YmxpYyBhY3RpdmVUYWJzID0ge1xuICAgIHNldHRpbmdzOiBmYWxzZSxcbiAgICBsZWdlbmQ6IHRydWUsXG4gICAgZGVzY3JpcHRpb246IGZhbHNlLFxuICAgIGNoYW5nZVN0eWxlOiBmYWxzZVxuICB9O1xuXG5cbiAgY29uc3RydWN0b3IoKSB7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBvYmo6IHthbnl8IElEeW5hbWljQ29tcG9uZW50fVxuICAgKi9cbiAgY2hlY2tJc0NvbXBvbmVudEl0ZW0obGF5ZXI6IExheWVyLCBjb21wUHJvcDogc3RyaW5nKTogbGF5ZXIgaXMgT21pdDxMYXllciwgJ2xlZ2VuZEltZycgfCAnYWN0aW9uJz4gJiB7IGxlZ2VuZEltZzogSUR5bmFtaWNDb21wb25lbnQsIGFjdGlvbjogSUR5bmFtaWNDb21wb25lbnQgfSB7XG4gICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzY1MzQ3NTMzLzEwODUwMDIxXG4gICAgY29uc3Qgb2JqID0gbGF5ZXJbY29tcFByb3BdO1xuICAgIGxldCBpc0NvbXAgPSBmYWxzZTtcbiAgICBpZiAob2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoJ2NvbXBvbmVudCcgaW4gb2JqKSB7XG4gICAgICAgIGlmICghb2JqLmlucHV0cykge1xuICAgICAgICAgIC8vIGh0dHBzOi8vMmFsaXR5LmNvbS8yMDE0LzAxL29iamVjdC1hc3NpZ24uaHRtbCMyLjNcbiAgICAgICAgICBjb25zdCBsYXllckNsb25lID0gT2JqZWN0LmFzc2lnbih7IF9fcHJvdG9fXzogdGhpcy5sYXllclsnX19wcm90b19fJ10gfSwgbGF5ZXIpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGxheWVyQ2xvbmUpXG4gICAgICAgICAgaWYgKGxheWVyQ2xvbmUgJiYgbGF5ZXJDbG9uZVtjb21wUHJvcF0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSBsYXllckNsb25lW2NvbXBQcm9wXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2JqLmlucHV0cyA9IHsgbGF5ZXI6IGxheWVyQ2xvbmUgfTtcbiAgICAgICAgfSBlbHNlIGlmIChvYmouaW5wdXRzICYmICFvYmouaW5wdXRzLmxheWVyKSB7XG4gICAgICAgICAgLy8gaHR0cHM6Ly8yYWxpdHkuY29tLzIwMTQvMDEvb2JqZWN0LWFzc2lnbi5odG1sIzIuM1xuICAgICAgICAgIGNvbnN0IGxheWVyQ2xvbmUgPSBPYmplY3QuYXNzaWduKHsgX19wcm90b19fOiB0aGlzLmxheWVyWydfX3Byb3RvX18nXSB9LCBsYXllcik7XG4gICAgICAgICAgY29uc29sZS5sb2cobGF5ZXJDbG9uZSlcbiAgICAgICAgICBpZiAobGF5ZXJDbG9uZSAmJiBsYXllckNsb25lW2NvbXBQcm9wXSkge1xuICAgICAgICAgICAgZGVsZXRlIGxheWVyQ2xvbmVbY29tcFByb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvYmouaW5wdXRzID0gT2JqZWN0LmFzc2lnbih7IGxheWVyOiBsYXllckNsb25lIH0sIG9iai5pbnB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIGlzQ29tcCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpc0NvbXA7XG4gIH1cblxuICBnZXRMYXllck5hbWUobGF5ZXI6IExheWVyKSB7XG4gICAgaWYgKGxheWVyLmRpc3BsYXlOYW1lKSB7XG4gICAgICByZXR1cm4gbGF5ZXIuZGlzcGxheU5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBsYXllci5uYW1lO1xuICAgIH1cbiAgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIGlmICghdGhpcy5sYXllcnNTdmMpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ3lvdSBuZWVkIHRvIHByb3ZpZGUgYSBsYXllcnNTZXJ2aWNlIScpO1xuICAgIH1cbiAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmxheWVyKVxuICAgIGlmICghdGhpcy5sYXllci5sZWdlbmRJbWcpIHtcbiAgICAgIHRoaXMuYWN0aXZlVGFicy5kZXNjcmlwdGlvbiA9IHRydWU7XG4gICAgICB0aGlzLmFjdGl2ZVRhYnMubGVnZW5kID0gZmFsc2U7XG4gICAgICB0aGlzLmFjdGl2ZVRhYnMuc2V0dGluZ3MgPSBmYWxzZTtcbiAgICAgIHRoaXMuYWN0aXZlVGFicy5jaGFuZ2VTdHlsZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5sYXllci5sZWdlbmRJbWcgJiYgIXRoaXMubGF5ZXIuZGVzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuYWN0aXZlVGFicy5kZXNjcmlwdGlvbiA9IGZhbHNlO1xuICAgICAgdGhpcy5hY3RpdmVUYWJzLmxlZ2VuZCA9IGZhbHNlO1xuICAgICAgdGhpcy5hY3RpdmVUYWJzLnNldHRpbmdzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sYXllci5iYm94ICYmIHRoaXMubGF5ZXIuYmJveC5sZW5ndGggPj0gNCkge1xuICAgICAgdGhpcy5jYW5ab29tVG9MYXllciA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHNob3cgb3IgaGlkZSB0aGUgbGF5ZXJcbiAgICovXG4gIHNldExheWVyVmlzaWJpbGl0eShzZWxlY3RlZExheWVyOiBMYXllciwgZ3JvdXA/OiBMYXllckdyb3VwKSB7XG4gICAgaWYgKCFncm91cCkge1xuICAgICAgaWYgKHNlbGVjdGVkTGF5ZXIuZmlsdGVydHlwZSA9PT0gJ0Jhc2VsYXllcnMnKSB7XG4gICAgICAgIHNlbGVjdGVkTGF5ZXIudmlzaWJsZSA9ICFzZWxlY3RlZExheWVyLnZpc2libGU7XG4gICAgICAgIGNvbnN0IGZpbHRlcmRsYXllcnMgPSB0aGlzLmxheWVyR3JvdXBzLmZpbHRlcigobCkgPT4gbC5maWx0ZXJ0eXBlID09PSAnQmFzZWxheWVycycpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhmaWx0ZXJkbGF5ZXJzKTtcbiAgICAgICAgZm9yIChjb25zdCBsYXllciBvZiBmaWx0ZXJkbGF5ZXJzKSB7XG4gICAgICAgICAgaWYgKGxheWVyIGluc3RhbmNlb2YgTGF5ZXIgJiYgbGF5ZXIuaWQgIT09IHNlbGVjdGVkTGF5ZXIuaWQpIHtcbiAgICAgICAgICAgIGxheWVyLnZpc2libGUgPSAhc2VsZWN0ZWRMYXllci52aXNpYmxlO1xuICAgICAgICAgICAgdGhpcy5sYXllcnNTdmMudXBkYXRlTGF5ZXIobGF5ZXIsIGxheWVyLmZpbHRlcnR5cGUgfHwgJ0Jhc2VsYXllcnMnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGVjdGVkTGF5ZXIudmlzaWJsZSA9ICFzZWxlY3RlZExheWVyLnZpc2libGU7XG4gICAgICAgIHRoaXMubGF5ZXJzU3ZjLnVwZGF0ZUxheWVyKHNlbGVjdGVkTGF5ZXIsIHNlbGVjdGVkTGF5ZXIuZmlsdGVydHlwZSB8fCAnTGF5ZXJzJyk7IC8vIFRPRE8gY2hlY2sgZm9yIGJhc2VsYXllcnMhISEhISFcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGdyb3VwLmxheWVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8qKiBcInJhZGlvXCIgZm9yIEJhc2VsYXllcnMgKi9cbiAgICAgICAgaWYgKGdyb3VwLmZpbHRlcnR5cGUgPT09ICdCYXNlbGF5ZXJzJykge1xuICAgICAgICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgZ3JvdXAubGF5ZXJzKSB7XG4gICAgICAgICAgICBsYXllci52aXNpYmxlID0gbGF5ZXIgPT09IHNlbGVjdGVkTGF5ZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudXBkYXRlLmVtaXQoe1xuICAgICAgICAgICAgbGF5ZXI6IHRoaXMubGF5ZXJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvKiogXCJjaGVja2JveFwiIGZvciBhbGwgb3RoZXIgbGF5ZXJzICovXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgdGVtcEdyb3VwVmlzaWJsZSA9IGdyb3VwLnZpc2libGU7XG4gICAgICAgICAgLyoqIGNoYW5nZSB2aXNpYmlsaXR5IG9mIHRoZSBzZWxlY3RlZCBsYXllciAqL1xuICAgICAgICAgIHNlbGVjdGVkTGF5ZXIudmlzaWJsZSA9ICFzZWxlY3RlZExheWVyLnZpc2libGU7XG5cbiAgICAgICAgICAvKiogY2hlY2sgaWYgZ3JvdXAgdmlzaWJpbGl0eSBoYXMgY2hhbmdlZCAqL1xuICAgICAgICAgIGlmICh0ZW1wR3JvdXBWaXNpYmxlICE9PSBncm91cC52aXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZS5lbWl0KHtcbiAgICAgICAgICAgICAgbGF5ZXI6IHRoaXMubGF5ZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvKiogSWYgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGdyb3VwIGRvbid0IGNoYW5nZXMgdXBkYXRlIG9ubHkgdGhlIGxheWVyICAqL1xuICAgICAgICAgICAgdGhpcy5sYXllcnNTdmMudXBkYXRlTGF5ZXIoc2VsZWN0ZWRMYXllciwgc2VsZWN0ZWRMYXllci5maWx0ZXJ0eXBlIHx8ICdMYXllcnMnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIHNldExheWVySW5kZXhcbiAgICovXG4gIHNldExheWVySW5kZXgobGF5ZXI6IExheWVyLCBkaXIsIGdyb3VwPzogTGF5ZXJHcm91cCkge1xuICAgIC8vIGNvbnNvbGUubG9nKCdpcyBGaXJzdCcsIHRoaXMuaXNGaXJzdChsYXllcikpO1xuICAgIC8vIGNvbnNvbGUubG9nKCdpcyBMYXN0JywgdGhpcy5pc0xhc3QobGF5ZXIpKTtcbiAgICAvLyBjb25zb2xlLmxvZyhsYXllciwgZ3JvdXApO1xuICAgIGlmIChncm91cCkge1xuICAgICAgdGhpcy5sYXllcnNTdmMuc2V0TGF5ZXJJbmRleEluR3JvdXAobGF5ZXIsIGRpciwgZ3JvdXApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxheWVyc1N2Yy5zZXRHcm91cExheWVySW5kZXgobGF5ZXIsIGRpcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHJlbW92ZSB0aGUgTGF5ZXIgaWYgcG9zc2libGVcbiAgICovXG4gIHJlbW92ZUxheWVyKGdyb3VwOiBMYXllckdyb3VwLCBzZWxlY3RlZExheWVyOiBMYXllcikge1xuICAgIC8vIGNvbnNvbGUubG9nKFwiZGVsZXRlIFwiLCBncm91cCwgc2VsZWN0ZWRMYXllcilcbiAgICBpZiAoZ3JvdXApIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiZGVsZXRlIGxheWVyIGZyb20gZ3JvdXBcIilcbiAgICAgIHRoaXMubGF5ZXJzU3ZjLnJlbW92ZUxheWVyRnJvbUdyb3VwKHNlbGVjdGVkTGF5ZXIsIGdyb3VwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29uc29sZS5sb2coJ2RlbGV0ZSBzaW5nbGUgbGF5ZXInKTtcbiAgICAgIHRoaXMubGF5ZXJzU3ZjLnJlbW92ZUxheWVyKHNlbGVjdGVkTGF5ZXIsIHNlbGVjdGVkTGF5ZXIuZmlsdGVydHlwZSk7XG4gICAgfVxuICB9XG5cbiAgem9vbVRvKGxheWVyOiBMYXllcikge1xuICAgIGlmICh0aGlzLm1hcFN0YXRlICYmIGxheWVyLmJib3ggJiYgbGF5ZXIuYmJveC5sZW5ndGggPj0gNCkge1xuICAgICAgdGhpcy5tYXBTdGF0ZS5zZXRFeHRlbnQobGF5ZXIuYmJveCBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSk7XG4gICAgfVxuICB9XG5cbiAgc2V0TGF5ZXJPcGFjaXR5KGxheWVyKSB7XG4gICAgaWYgKCF0aGlzLmdyb3VwKSB7XG4gICAgICB0aGlzLmxheWVyc1N2Yy51cGRhdGVMYXllcihsYXllciwgbGF5ZXIuZmlsdGVydHlwZSB8fCAnTGF5ZXJzJyk7IC8vIFRPRE8gY2hlY2sgZm9yIGJhc2VsYXllcnMhISEhISFcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cGRhdGUuZW1pdCh7XG4gICAgICAgIGxheWVyXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBjaGVja0Jhc2VsYXllcihsYXllcjogTGF5ZXIsIGdyb3VwPzogTGF5ZXJHcm91cCkge1xuICAgIGlmIChsYXllci5maWx0ZXJ0eXBlID09PSAnQmFzZWxheWVycycgfHwgZ3JvdXAgJiYgZ3JvdXAuZmlsdGVydHlwZSA9PT0gJ0Jhc2VsYXllcnMnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBpcyBleHBhbmRhYmxlIGlmIGxheWVyIGhhcyBsZWdlbmQsIGRlc2NyaXB0aW9uIG9yIG9wYWNpdHkgY2FuIGJlIGNoYW5nZWRcbiAgICovXG4gIGlzX2V4cGFuZGFibGUoKSB7XG4gICAgaWYgKHRoaXMuZ3JvdXApIHtcbiAgICAgIHJldHVybiAhdGhpcy5sYXllci5sZWdlbmRJbWcgJiYgdGhpcy5ncm91cC5maWx0ZXJ0eXBlID09PSAnQmFzZWxheWVycyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gIXRoaXMubGF5ZXIubGVnZW5kSW1nOyAvL3RoaXMubGF5ZXIuZGVzY3JpcHRpb25cbiAgICB9XG4gIH1cblxuICBzaG93UHJvcGVydGllcygpIHtcbiAgICBpZiAoIXRoaXMuaXNfZXhwYW5kYWJsZSgpKSB7XG4gICAgICB0aGlzLmV4cGFuZGVkID0gIXRoaXMuZXhwYW5kZWQ7XG4gICAgfVxuICB9XG5cbiAgc3dpdGNoVGFiKHRhYk5hbWU6IHN0cmluZykge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMuYWN0aXZlVGFicykpIHtcbiAgICAgIHRoaXMuYWN0aXZlVGFic1trZXldID0gdGFiTmFtZSA9PT0ga2V5O1xuICAgIH1cbiAgfVxuXG4gIGlzU2VsZWN0ZWRTdHlsZShzdHlsZU5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLmxheWVyIGluc3RhbmNlb2YgV21zTGF5ZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmxheWVyLnBhcmFtcy5TVFlMRVMgPT09IHN0eWxlTmFtZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubGF5ZXIgaW5zdGFuY2VvZiBXbXRzTGF5ZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmxheWVyLnBhcmFtcy5zdHlsZSA9PT0gc3R5bGVOYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBob3cgdG8gY29tcGFyZSBzdHlsZXMgZm9yIHZlY3RvciBsYXllcnMgYW5kIGN1c3RvbSBsYXllcnM/XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZXhlY3V0ZUNoYW5nZVN0eWxlKGV2dDogRXZlbnQpIHtcbiAgICBjb25zdCBuZXdTdHlsZU5hbWUgPSAoZXZ0LnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50KS52YWx1ZTtcbiAgICBpZiAodGhpcy5sYXllci5zdHlsZXMpIHtcbiAgICAgIGNvbnN0IG5ld1N0eWxlID0gKHRoaXMubGF5ZXIgYXMgUmFzdGVyTGF5ZXIpLnN0eWxlcy5maW5kKHMgPT4gcy5uYW1lID09PSBuZXdTdHlsZU5hbWUpO1xuICAgICAgaWYgKG5ld1N0eWxlKSB7XG4gICAgICAgIHRoaXMubGF5ZXIubGVnZW5kSW1nID0gbmV3U3R5bGUubGVnZW5kVVJMO1xuICAgICAgICBpZiAodGhpcy5sYXllciBpbnN0YW5jZW9mIFdtc0xheWVyKSB7XG4gICAgICAgICAgdGhpcy5sYXllci5wYXJhbXMuU1RZTEVTID0gbmV3U3R5bGUubmFtZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmxheWVyIGluc3RhbmNlb2YgV210c0xheWVyKSB7XG4gICAgICAgICAgdGhpcy5sYXllci5wYXJhbXMuc3R5bGUgPSBuZXdTdHlsZS5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGF5ZXJzU3ZjLnVwZGF0ZUxheWVyKHRoaXMubGF5ZXIsIHRoaXMubGF5ZXIuZmlsdGVydHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaXNGaXJzdChsYXllcikge1xuICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYXllcnNTdmMuaXNHcm91cEZpcnN0KGxheWVyLCB0aGlzLmdyb3VwLmxheWVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmxheWVyc1N2Yy5pc0dyb3VwRmlyc3QobGF5ZXIsIG51bGwsIGxheWVyLmZpbHRlcnR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIGlzTGFzdChsYXllcikge1xuICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYXllcnNTdmMuaXNHcm91cExhc3QobGF5ZXIsIHRoaXMuZ3JvdXAubGF5ZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMubGF5ZXJzU3ZjLmlzR3JvdXBMYXN0KGxheWVyLCBudWxsLCBsYXllci5maWx0ZXJ0eXBlKTtcbiAgICB9XG4gIH1cblxuICBnZXRFeHBhbmRTaGFwZSgpIHtcbiAgICAvLyByZXR1cm4gdGhpcy5vcGVuUHJvcGVydGllcyA/ICdkb3duJyA6ICdyaWdodCc7XG4gICAgcmV0dXJuIHRoaXMuZXhwYW5kZWQgPyB7IHRyYW5zZm9ybTogJ3JvdGF0ZSgxODBkZWcpJyB9IDogeyB0cmFuc2Zvcm06ICdyb3RhdGUoOTBkZWcpJyB9O1xuICB9XG5cbn1cbiIsIjxkaXYgY2xhc3M9XCJsYXllclwiPlxuICA8ZGl2IGNsYXNzPVwiaGVhZFwiPlxuICAgIDwhLS0gbGF5ZXIgZXhwYW5kIGljb24gLS0+XG4gICAgPGNsci1pY29uIHNoYXBlPVwiYW5nbGVcIiBbbmdTdHlsZV09XCJnZXRFeHBhbmRTaGFwZSgpXCIgY2xhc3M9XCJpY29uQnV0dG9uXCIgW25nQ2xhc3NdPVwieydkaXNhYmxlZCc6IGlzX2V4cGFuZGFibGUoKX1cIlxuICAgICAgKGNsaWNrKT1cInNob3dQcm9wZXJ0aWVzKClcIiB0aXRsZT1cIkRldGFpbHNcIj48L2Nsci1pY29uPlxuXG4gICAgPCEtLSBsYXllciB0aXRsZSAtLT5cbiAgICA8ZGl2ICNyZWYgY2xhc3M9XCJpdGVtLXRpdGxlLXJlcGxhY2VtZW50IHRpdGxlXCIgKGNsaWNrKT1cInNob3dQcm9wZXJ0aWVzKClcIiBbdGl0bGVdPVwiZ2V0TGF5ZXJOYW1lKGxheWVyKVwiPlxuICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIDwvZGl2PlxuICAgIDxzcGFuICpuZ0lmPVwicmVmLmNoaWxkcmVuLmxlbmd0aCA9PSAwXCIgY2xhc3M9XCJ0aXRsZVwiIFt0aXRsZV09XCJnZXRMYXllck5hbWUobGF5ZXIpXCIgKGNsaWNrKT1cInNob3dQcm9wZXJ0aWVzKClcIj5cbiAgICAgIHt7Z2V0TGF5ZXJOYW1lKGxheWVyKX19XG4gICAgPC9zcGFuPlxuXG4gICAgPCEtLSBzZXRMYXllckluZGV4IC8vIGZvciByZXZlcnNlZCBsYXllcmdyb3VwcyBvbiBuZ0ZvciB1cCBpcyBkb3duIC0tPlxuICAgIDxzcGFuICpuZ0lmPVwiIWNoZWNrQmFzZWxheWVyKGxheWVyLGdyb3VwKVwiPlxuICAgICAgPGNsci1pY29uIFtoaWRkZW5dPVwibGF5ZXJHcm91cHMgJiYgbGF5ZXJHcm91cHMubGVuZ3RoID09IDFcIiBjbGFzcz1cImljb25CdXR0b25cIiBzaGFwZT1cImFycm93XCJcbiAgICAgICAgW25nQ2xhc3NdPVwieydkaXNhYmxlZCc6IGlzTGFzdChsYXllcil9XCIgKGNsaWNrKT1cInNldExheWVySW5kZXgobGF5ZXIsICdkb3duJywgZ3JvdXApXCIgdGl0bGU9XCJ1cFwiPjwvY2xyLWljb24+XG4gICAgICA8Y2xyLWljb24gW2hpZGRlbl09XCJsYXllckdyb3VwcyAmJiBsYXllckdyb3Vwcy5sZW5ndGggPT0gMVwiIGNsYXNzPVwiaWNvbkJ1dHRvblwiIHNoYXBlPVwiYXJyb3dcIlxuICAgICAgICBbbmdDbGFzc109XCJ7J2Rpc2FibGVkJzogaXNGaXJzdChsYXllcil9XCIgKGNsaWNrKT1cInNldExheWVySW5kZXgobGF5ZXIsICd1cCcsIGdyb3VwKVwiIHRpdGxlPVwiZG93blwiIGRpcj1cImRvd25cIj5cbiAgICAgIDwvY2xyLWljb24+XG4gICAgPC9zcGFuPlxuXG4gICAgPCEtLSBzZXRMYXllclZpc2liaWxpdHkgLS0+XG4gICAgPGlucHV0IGNsYXNzPVwiaGlkZVwiIFt0eXBlXT1cIihjaGVja0Jhc2VsYXllcihsYXllcixncm91cCkpPydyYWRpbyc6J2NoZWNrYm94J1wiIFtuYW1lXT1cIidsYXllcidcIiBbaWRdPVwibGF5ZXIuaWRcIlxuICAgICAgW2NoZWNrZWRdPVwibGF5ZXIudmlzaWJsZVwiIChjaGFuZ2UpPVwic2V0TGF5ZXJWaXNpYmlsaXR5KGxheWVyLCBncm91cClcIj5cbiAgICA8bGFiZWwgW2Zvcl09XCJsYXllci5pZFwiPlxuICAgICAgPGNsci1pY29uICpuZ0lmPVwiY2hlY2tCYXNlbGF5ZXIobGF5ZXIsZ3JvdXApOyBlbHNlIG5vdEJhc2VsYXllclwiIGNsYXNzPVwiaWNvbkJ1dHRvblwiXG4gICAgICAgIFtuZ0NsYXNzXT1cInsnaXMtc29saWQnOmxheWVyLnZpc2libGV9XCIgW2F0dHIuc2hhcGVdPVwiKGxheWVyLnZpc2libGUpPydkb3QtY2lyY2xlJzonY2lyY2xlJ1wiXG4gICAgICAgIHRpdGxlPVwie3tsYXllci52aXNpYmxlPydDaG9vc2UgYW5vdGhlciBsYXllcic6J1Nob3cgbGF5ZXInfX1cIj5cbiAgICAgIDwvY2xyLWljb24+XG4gICAgICA8bmctdGVtcGxhdGUgI25vdEJhc2VsYXllcj5cbiAgICAgICAgPGNsci1pY29uIGNsYXNzPVwiaWNvbkJ1dHRvblwiIFtuZ0NsYXNzXT1cInsnaXMtc29saWQnOmxheWVyLnZpc2libGV9XCJcbiAgICAgICAgICBbYXR0ci5zaGFwZV09XCIobGF5ZXIudmlzaWJsZSk/J2V5ZSc6J2V5ZS1oaWRlJ1wiIHRpdGxlPVwie3tsYXllci52aXNpYmxlPydIaWRlIGxheWVyJzonU2hvdyBsYXllcid9fVwiPlxuICAgICAgICA8L2Nsci1pY29uPlxuICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICA8L2xhYmVsPlxuXG4gIDwvZGl2PlxuICA8ZGl2ICpuZ0lmPVwiZXhwYW5kYWJsZSAmJiBleHBhbmRlZFwiIGNsYXNzPVwiYm9keVwiPlxuICAgIDwhLS0gdG9vbHM6IHpvb21UbywgcmVtb3ZlLCBzd2l0Y2ggVGFiIC0tPlxuICAgIDxkaXYgY2xhc3M9XCJ0b29sc1wiPlxuICAgICAgPGNsci1pY29uICpuZ0lmPVwiIWNoZWNrQmFzZWxheWVyKGxheWVyLCBncm91cClcIiB0aXRsZT1cIkxheWVyIHNldHRpbmdzXCIgc2hhcGU9XCJjb2dcIiBjbGFzcz1cImljb25CdXR0b25cIlxuICAgICAgICBbbmdDbGFzc109XCJ7J2FjdGl2ZSc6IGFjdGl2ZVRhYnNbJ3NldHRpbmdzJ119XCIgKGNsaWNrKT1cInN3aXRjaFRhYignc2V0dGluZ3MnKVwiPjwvY2xyLWljb24+XG4gICAgICA8Y2xyLWljb24gKm5nSWY9XCJsYXllci5sZWdlbmRJbWdcIiB0aXRsZT1cIkxheWVyIExlZ2VuZFwiIHNoYXBlPVwiaW1hZ2VcIiBjbGFzcz1cImljb25CdXR0b25cIlxuICAgICAgICBbbmdDbGFzc109XCJ7J2FjdGl2ZSc6IGFjdGl2ZVRhYnNbJ2xlZ2VuZCddfVwiIChjbGljayk9XCJzd2l0Y2hUYWIoJ2xlZ2VuZCcpXCI+PC9jbHItaWNvbj5cbiAgICAgIDxjbHItaWNvbiAqbmdJZj1cImxheWVyLmRlc2NyaXB0aW9uXCIgdGl0bGU9XCJMYXllciBpbmZvXCIgc2hhcGU9XCJpbmZvLXN0YW5kYXJkXCIgY2xhc3M9XCJpY29uQnV0dG9uXCJcbiAgICAgICAgW25nQ2xhc3NdPVwieydhY3RpdmUnOiBhY3RpdmVUYWJzWydkZXNjcmlwdGlvbiddfVwiIChjbGljayk9XCJzd2l0Y2hUYWIoJ2Rlc2NyaXB0aW9uJylcIj48L2Nsci1pY29uPlxuICAgICAgPGNsci1pY29uICpuZ0lmPVwibGF5ZXIuc3R5bGVzPy5sZW5ndGggPiAxXCIgdGl0bGU9XCJDaGFuZ2Ugc3R5bGVcIiBzaGFwZT1cImNsb3VkLWNoYXJ0XCIgY2xhc3M9XCJpY29uQnV0dG9uXCJcbiAgICAgICAgW25nQ2xhc3NdPVwieydhY3RpdmUnOiBhY3RpdmVUYWJzWydjaGFuZ2VTdHlsZSddfVwiIChjbGljayk9XCJzd2l0Y2hUYWIoJ2NoYW5nZVN0eWxlJylcIj48L2Nsci1pY29uPlxuXG4gICAgICA8Y2xyLWljb24gKm5nRm9yPVwibGV0IGl0ZW0gb2YgbGF5ZXIuYWN0aW9uc1wiIFthdHRyLnNoYXBlXT1cIml0ZW0uaWNvblwiIGNsYXNzPVwiaWNvbkJ1dHRvblwiXG4gICAgICAgIChjbGljayk9XCJpdGVtLmFjdGlvbihsYXllcilcIiBbdGl0bGVdPVwiaXRlbS50aXRsZVwiPlxuICAgICAgPC9jbHItaWNvbj5cblxuXG4gICAgICA8c3Bhbj48L3NwYW4+XG4gICAgICA8Y2xyLWljb24gKm5nSWY9XCJjYW5ab29tVG9MYXllclwiIHNoYXBlPVwiem9vbS1pblwiIGNsYXNzPVwiaWNvbkJ1dHRvblwiIHRpdGxlPVwiWm9vbSB0byBsYXllclwiIChjbGljayk9XCJ6b29tVG8obGF5ZXIpXCI+XG4gICAgICA8L2Nsci1pY29uPlxuICAgICAgPGNsci1pY29uICpuZ0lmPVwibGF5ZXIucmVtb3ZhYmxlXCIgc2hhcGU9XCJ0cmFzaFwiIGNsYXNzPVwiaWNvbkJ1dHRvblwiIChjbGljayk9XCJyZW1vdmVMYXllcihncm91cCwgbGF5ZXIpXCJcbiAgICAgICAgdGl0bGU9XCJSZW1vdmUgbGF5ZXJcIj48L2Nsci1pY29uPlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJ0YWJzYm9keVwiPlxuICAgICAgPGRpdiAqbmdJZj1cImFjdGl2ZVRhYnMuc2V0dGluZ3NcIiBjbGFzcz1cImxheWVyc2V0dGluZ3NcIj5cbiAgICAgICAgPCEtLSBzZXRMYXllck9wYWNpdHkgLS0+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCI+XG4gICAgICAgICAgPGxhYmVsIFtmb3JdPVwiJ2xheWVyX3RyYW5zcGFyZW5jeV9zbGlkZXJfJytsYXllci5pZFwiPk9wYWNpdHk6PC9sYWJlbD5cbiAgICAgICAgICA8aW5wdXQgW2lkXT1cIidsYXllcl90cmFuc3BhcmVuY3lfc2xpZGVyXycrbGF5ZXIuaWRcIiB0eXBlPVwicmFuZ2VcIiBjbGFzcz1cInVraXMtcmFuZ2UtaW5wdXQgb3BhY2l0eS1pbnB1dFwiXG4gICAgICAgICAgICBuYW1lPVwicG9pbnRzXCIgW3ZhbHVlXT1cImxheWVyLm9wYWNpdHlcIiBbbWluXT1cIjAuMFwiIFttYXhdPVwiMS4wXCIgW3N0ZXBdPVwiMC4xXCIgKGNoYW5nZSk9XCJzZXRMYXllck9wYWNpdHkobGF5ZXIpXCJcbiAgICAgICAgICAgIFsobmdNb2RlbCldPVwibGF5ZXIub3BhY2l0eVwiIC8+XG4gICAgICAgICAgPHNwYW4+e3tcIiBcIitsYXllci5vcGFjaXR5fX08L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiY2hlY2tJc0NvbXBvbmVudEl0ZW0obGF5ZXIsICdhY3Rpb24nKTtcIj5cbiAgICAgICAgICA8dWtpcy1keW5hbWljLWNvbXBvbmVudCBbKGR5bmFtaWNDb21wb25lbnQpXT1cImxheWVyLmFjdGlvblwiPlxuICAgICAgICAgIDwvdWtpcy1keW5hbWljLWNvbXBvbmVudD5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICA8L2Rpdj5cbiAgICAgIDwhLS0gc2hvdyBMZWdlbmQgLS0+XG4gICAgICA8ZGl2ICpuZ0lmPVwiYWN0aXZlVGFicy5sZWdlbmQgJiYgbGF5ZXIubGVnZW5kSW1nXCI+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJjaGVja0lzQ29tcG9uZW50SXRlbShsYXllciwnbGVnZW5kSW1nJyk7IGVsc2UgaW1hZ2VVcmxcIj5cbiAgICAgICAgICA8dWtpcy1keW5hbWljLWNvbXBvbmVudCBbKGR5bmFtaWNDb21wb25lbnQpXT1cImxheWVyLmxlZ2VuZEltZ1wiPjwvdWtpcy1keW5hbWljLWNvbXBvbmVudD5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG5cbiAgICAgICAgPG5nLXRlbXBsYXRlICNpbWFnZVVybD5cbiAgICAgICAgICA8YSBbaHJlZl09XCJsYXllci5sZWdlbmRJbWdcIiB0YXJnZXQ9XCJfYmxhbmtcIiB0aXRsZT1cIlNob3cgZnVsbCBJbWFnZVwiPjxpbWcgW3NyY109XCJsYXllci5sZWdlbmRJbWdcIiAvPjwvYT5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgIDwvZGl2PlxuICAgICAgPCEtLSBzaG93IERlc2NyaXB0aW9uIC0tPlxuICAgICAgPGRpdiAqbmdJZj1cImFjdGl2ZVRhYnMuZGVzY3JpcHRpb24gJiYgbGF5ZXIuZGVzY3JpcHRpb25cIj5cbiAgICAgICAgPHNwYW4gW2lubmVySFRNTF09XCJsYXllci5kZXNjcmlwdGlvblwiPjwvc3Bhbj5cbiAgICAgIDwvZGl2PlxuICAgICAgPCEtLSBzaG93IHN0eWxlLXN3aXRjaGVyIC0tPlxuICAgICAgPGRpdiAqbmdJZj1cImFjdGl2ZVRhYnMuY2hhbmdlU3R5bGUgJiYgbGF5ZXIuc3R5bGVzICYmIGxheWVyLnN0eWxlcz8ubGVuZ3RoID4gMVwiPlxuICAgICAgICA8c2VsZWN0IGNsclNlbGVjdCAoY2hhbmdlKT1cImV4ZWN1dGVDaGFuZ2VTdHlsZSgkZXZlbnQpXCI+XG4gICAgICAgICAgPG9wdGlvbiAqbmdGb3I9XCJsZXQgc3R5bGUgb2YgbGF5ZXIuc3R5bGVzXCIgW3ZhbHVlXT1cInN0eWxlLm5hbWVcIlxuICAgICAgICAgICAgW2F0dHIuc2VsZWN0ZWRdPVwiaXNTZWxlY3RlZFN0eWxlKHN0eWxlLm5hbWUpID8gdHJ1ZSA6IG51bGxcIj57e3N0eWxlLnRpdGxlfX08L29wdGlvbj5cbiAgICAgICAgPC9zZWxlY3Q+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cblxuICA8L2Rpdj5cblxuPC9kaXY+XG4iXX0=