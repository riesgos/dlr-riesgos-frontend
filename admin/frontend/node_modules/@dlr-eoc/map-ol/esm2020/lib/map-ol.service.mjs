import { Injectable } from '@angular/core';
import { VectorLayer, RasterLayer, WmtsLayer, StackedLayer, StackedLayertype, CustomLayertype, WfsLayertype, KmlLayertype, GeojsonLayertype, TmsLayertype, WmtsLayertype, WmsLayertype, XyzLayertype } from '@dlr-eoc/services-layers';
import olMap from 'ol/Map';
import olView from 'ol/View';
import olBaseLayer from 'ol/layer/Base';
import olLayer from 'ol/layer/Layer';
import olLayerGroup from 'ol/layer/Group';
import olOverlay from 'ol/Overlay';
import olBaseTileLayer from 'ol/layer/BaseTile';
import olBaseVectorLayer from 'ol/layer/BaseVector';
import olBaseImageLayer from 'ol/layer/BaseImage';
import olImageLayer from 'ol/layer/Image';
import olTileLayer from 'ol/layer/Tile';
import olVectorLayer from 'ol/layer/Vector';
import olVectorTile from 'ol/source/VectorTile';
import olVectorTileLayer from 'ol/layer/VectorTile';
import olVectorTileSource from 'ol/source/VectorTile';
import { applyStyle } from 'ol-mapbox-style';
import { createXYZ } from 'ol/tilegrid';
import olMVT from 'ol/format/MVT';
import olXYZ from 'ol/source/XYZ';
import olTileSource from 'ol/source/Tile';
import olTileWMS from 'ol/source/TileWMS';
import olImageWMS from 'ol/source/ImageWMS';
import olTileImageSource from 'ol/source/TileImage';
import olImageSource from 'ol/source/Image';
import olWMTS from 'ol/source/WMTS';
import olWMTSTileGrid from 'ol/tilegrid/WMTS';
import olTileGrid from 'ol/tilegrid/TileGrid';
import olVectorSource from 'ol/source/Vector';
import olRasterSource from 'ol/source/Raster';
import olCluster from 'ol/source/Cluster';
import olCollection from 'ol/Collection';
import olGeoJSON from 'ol/format/GeoJSON';
import olKML from 'ol/format/KML';
import olProjection from 'ol/proj/Projection';
import { transformExtent, get as getProjection, transform } from 'ol/proj';
import { register as olRegister } from 'ol/proj/proj4';
import proj4 from 'proj4';
import { extend as olExtend, getWidth as olGetWidth, getHeight as olGetHeight, getTopLeft as olGetTopLeft, containsCoordinate as olContainsCoordinate } from 'ol/extent';
import { DEFAULT_MAX_ZOOM, DEFAULT_TILE_SIZE } from 'ol/tilegrid/common';
import { easeOut } from 'ol/easing.js';
import olStyle from 'ol/style/Style';
import olText from 'ol/style/Text';
import olFill from 'ol/style/Fill';
import olCircleStyle from 'ol/style/Circle';
import olStroke from 'ol/style/Stroke';
import { DragBox } from 'ol/interaction';
import { getUid as olGetUid } from 'ol/util';
import { Subject } from 'rxjs';
import { flattenLayers } from '@dlr-eoc/utils-maps';
import OverlayPositioning from 'ol/OverlayPositioning';
import * as i0 from "@angular/core";
const OVERLAY_TYPE_KEY = 'type';
const FILTER_TYPE_KEY = 'filtertype';
const ID_KEY = 'id';
const TITLE_KEY = 'title';
const WebMercator = 'EPSG:3857';
const WGS84 = 'EPSG:4326';
export class MapOlService {
    constructor(crf, app, injector) {
        this.crf = crf;
        this.app = app;
        this.injector = injector;
        this.hitTolerance = 0;
        this.hitLayerCurr = null;
        this.hitLayerPrev = null;
        /** 'olProjection' */
        this.projectionChange = new Subject();
        /**
         * This object keeps track of currently bound angular-components that are being used as popups.
         * We keep a reference to them here so that we can remove them again after they are no longer displayed.
         */
        this.dynamicPopupComponents = new Map();
        /**
         * To filtered out layers and show the popup beneath e.g. text overlays
         * in map.forEachLayerAtPixel for raster and map.forEachFeatureAtPixel for vector
         */
        this.filterLayerNoPopup = (l) => {
            const popup = (l.get('popup'));
            let shouldNotFilterLayer = true;
            if (popup && this.isPopupObj(popup)) {
                if (popup.filterLayer === true) {
                    shouldNotFilterLayer = false;
                }
            }
            return shouldNotFilterLayer;
        };
        this.map = new olMap({ controls: [] });
        this.view = new olView();
        this.EPSG = WebMercator;
    }
    /**
     * if this is used in an angular component then set the target after the view is created
     * e.g. this.map.setTarget(this.mapDivView.nativeElement) in ngAfterViewInit()
     */
    createMap(target) {
        const zoom = 0;
        const center = {
            lat: 0,
            lon: 0
        };
        const baselayerGroup = new olLayerGroup({
            layers: []
        });
        baselayerGroup.set(FILTER_TYPE_KEY, 'baselayers');
        baselayerGroup.set(TITLE_KEY, 'Base maps');
        baselayerGroup.set(ID_KEY, 'ID_filtertype_baselayers');
        const layersGroup = new olLayerGroup({
            layers: []
        });
        layersGroup.set(FILTER_TYPE_KEY, 'layers');
        layersGroup.set(TITLE_KEY, 'Layers');
        layersGroup.set(ID_KEY, 'ID_filtertype_layers');
        // ---------------------------------------------------------------------------------------------------
        const overlayGroup = new olLayerGroup({
            layers: []
        });
        overlayGroup.set(FILTER_TYPE_KEY, 'overlays');
        overlayGroup.set(TITLE_KEY, 'Overlays');
        overlayGroup.set(ID_KEY, 'ID_filtertype_overlays');
        /**
         * set default viewOptions
         */
        this.viewOptions = {
            center: transform([center.lon, center.lat], WGS84, this.EPSG),
            zoom,
            projection: getProjection(this.EPSG)
        };
        if (this.view['constrainRotation']) {
            this.viewOptions.constrainRotation = this.view['constrainRotation'];
        }
        if (this.view['enableRotation']) {
            this.viewOptions.enableRotation = this.view['enableRotation'];
        }
        if (this.view['extent']) {
            this.viewOptions.extent = this.view['extent'];
        }
        if (this.view['constrainOnlyCenter']) {
            this.viewOptions.constrainOnlyCenter = this.view['constrainOnlyCenter'];
        }
        if (this.view['smoothExtentConstraint']) {
            this.viewOptions.smoothExtentConstraint = this.view['smoothExtentConstraint'];
        }
        if (this.view.getMaxResolution()) {
            this.viewOptions.maxResolution = this.view.getMaxResolution();
        }
        if (this.view.getMinResolution()) {
            this.viewOptions.minResolution = this.view.getMinResolution();
        }
        if (this.view.getMaxZoom()) {
            this.viewOptions.maxZoom = this.view.getMaxZoom();
        }
        if (this.view.getMinZoom()) {
            this.viewOptions.minZoom = this.view.getMinZoom();
        }
        if (this.view['multiWorld']) {
            this.viewOptions.multiWorld = this.view['multiWorld'];
        }
        if (this.view['constrainResolution']) {
            this.viewOptions.constrainResolution = this.view['constrainResolution'];
        }
        if (this.view['smoothResolutionConstraint']) {
            this.viewOptions.smoothResolutionConstraint = this.view['smoothResolutionConstraint'];
        }
        if (this.view.getResolution()) {
            this.viewOptions.resolution = this.view.getResolution();
        }
        if (this.view.getResolutions()) {
            this.viewOptions.resolutions = this.view.getResolutions();
        }
        if (this.view['rotation']) {
            this.viewOptions.rotation = this.view['rotation'];
        }
        if (this.view['zoomFactor']) {
            this.viewOptions.zoomFactor = this.view['zoomFactor'];
        }
        const tempview = new olView(this.viewOptions);
        /** define map in constructor so it is created before to use it in projects onInit Method  */
        [baselayerGroup, layersGroup, overlayGroup].map(layer => this.map.addLayer(layer));
        this.map.setView(tempview);
        // this.map.getControls().clear();
        this.view = this.map.getView();
        this.setProjection(this.EPSG);
        if (target) {
            this.map.setTarget(target);
        }
        return {
            map: this.map,
            view: this.view
        };
    }
    setHitTolerance(tolerance) {
        this.hitTolerance = tolerance;
    }
    getHitTolerance() {
        return this.hitTolerance;
    }
    /**
     * See this example:
     * https://openlayers.org/en/latest/examples/box-selection.html
     */
    addBboxSelection(conditionForDrawing, onBoxStart, onBoxEnd, dragBoxOptions) {
        const options = {
            className: 'ol-drag-select',
            condition: conditionForDrawing,
        };
        Object.assign(options, dragBoxOptions);
        const dragBox = new DragBox(dragBoxOptions);
        if (onBoxStart) {
            /** TODO: check Types on the next ol update */
            dragBox.on('boxstart', (evt) => {
                onBoxStart(evt);
            });
        }
        if (onBoxEnd) {
            dragBox.on('boxend', (evt) => {
                const extent = dragBox.getGeometry().getExtent();
                onBoxEnd(extent, evt);
            });
        }
        this.map.addInteraction(dragBox);
        return dragBox;
    }
    /**
     * get an array of olLayers from a group type
     */
    getLayers(filtertype) {
        const lowerType = filtertype.toLowerCase();
        let layers;
        this.map.getLayers().getArray().forEach((layerGroup) => {
            if (layerGroup.get(FILTER_TYPE_KEY) === lowerType) {
                layers = layerGroup.getLayers().getArray();
            }
        });
        return layers;
    }
    getLayersFromGroup(group, filtertype, recursive = false) {
        const layers = group.getLayers().getArray();
        let tempLayers = layers;
        if (recursive) {
            let groups = [].concat(layers);
            layers.forEach(l => {
                if (l instanceof olLayerGroup) {
                    groups = groups.concat(this.getLayersFromGroup(l, filtertype, true));
                }
            });
            tempLayers = groups;
        }
        if (filtertype) {
            return tempLayers.filter(l => l.get(FILTER_TYPE_KEY) && l.get(FILTER_TYPE_KEY).toLowerCase() === filtertype.toLowerCase());
        }
        else {
            return tempLayers;
        }
    }
    getLayerByKey(key, filtertype) {
        const layers = this.getLayersFromGroup(this.map.getLayerGroup(), filtertype);
        const flattenedLayers = flattenLayers(layers);
        const keyLayers = [];
        flattenedLayers.forEach((item) => {
            if (item.get(key.key) && item.get(key.key) === key.value) {
                if (keyLayers.indexOf(item) === -1) {
                    keyLayers.push(item);
                }
            }
        });
        if (!keyLayers.length) {
            const subLayers = this.getLayersFromGroup(this.map.getLayerGroup(), filtertype, true); // (map.getLayerGroup(), filtertype, filtertypeKey, true);
            if (subLayers.length) {
                subLayers.forEach((item) => {
                    if (item.get(key.key) && item.get(key.key) === key.value) {
                        if (keyLayers.indexOf(item) === -1) {
                            keyLayers.push(item);
                        }
                    }
                });
            }
        }
        // there could maybe more the one layers with the same key!!!!
        if (keyLayers.length === 1) {
            return keyLayers[0];
        }
        else {
            return null;
        }
    }
    /**
     * set a FilterType to a Layer or Group recursively
     *
     * @param key [key='filtertype']
     */
    setRecursiveKey(layer, value, key = FILTER_TYPE_KEY) {
        layer.set(key, value);
        if (layer instanceof olLayerGroup) {
            layer.getLayers().forEach(l => {
                this.setRecursiveKey(l, value, key);
            });
        }
    }
    /**
     * add a olLayer to a group if it is not there
     */
    addLayer(layer, filtertype) {
        const lowerType = filtertype.toLowerCase();
        let layers;
        this.map.getLayers().getArray().forEach((layerGroup) => {
            if (layerGroup.get(FILTER_TYPE_KEY) === lowerType) {
                if (!this.isLayerInGroup(layer, layerGroup)) {
                    layers = layerGroup.getLayers().getArray();
                    this.setRecursiveKey(layer, lowerType, FILTER_TYPE_KEY);
                    layers.push(layer);
                    layerGroup.setLayers(new olCollection(layers));
                }
            }
        });
        return layers;
    }
    isLayerInGroup(layer, layerGroup) {
        const layers = layerGroup.getLayers().getArray();
        const haseLayer = layers.filter(l => l.get('id') === layer.get('id'));
        if (haseLayer.length) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
      * Get all direkt Layer Groups added to the map
      *
      * @param filtertypeKey [filtertypeKey='filtertype']
      */
    getLayerGroups(filtertype) {
        const layerGroups = [];
        this.map.getLayers().forEach((lg) => {
            if (lg instanceof olLayerGroup) {
                if (filtertype) {
                    if (lg.get(FILTER_TYPE_KEY) && lg.get(FILTER_TYPE_KEY).toLowerCase() === filtertype.toLowerCase()) {
                        layerGroups.push(lg);
                    }
                }
                else {
                    layerGroups.push(lg);
                }
            }
        });
        return layerGroups;
    }
    /**
     * add a array of olLayers to a group if they are not there
     */
    addLayers(layers, filtertype) {
        const lowerType = filtertype.toLocaleLowerCase();
        let newLayers;
        const layerGroups = this.getLayerGroups(lowerType);
        layerGroups.forEach(lg => {
            const groupLayers = lg.getLayers();
            if (groupLayers.getLength() > 0) {
                // I think doing it like this should be more performant like as using the addLayer in a loop
                newLayers = lg.getLayers().getArray();
                layers.map(layer => {
                    if (!this.isLayerInGroup(layer, lg)) {
                        newLayers.push(layer);
                    }
                });
            }
            else {
                newLayers = layers;
            }
            newLayers.forEach(l => {
                if (l instanceof olLayerGroup) {
                    this.setRecursiveKey(l, lowerType, FILTER_TYPE_KEY);
                }
            });
            lg.setLayers(new olCollection(newLayers));
        });
        return newLayers;
    }
    /**
     * reset a group with an array of olLayers
     */
    setLayers(layers, filtertype) {
        const lowerType = filtertype.toLocaleLowerCase();
        const layerGroups = this.getLayerGroups(lowerType);
        layers.forEach(l => {
            if (l instanceof olLayerGroup) {
                this.setRecursiveKey(l, filtertype.toLocaleLowerCase(), FILTER_TYPE_KEY);
            }
        });
        layerGroups.forEach(l => {
            this.cleanUpEventListeners(l, layers);
            l.setLayers(new olCollection(layers));
        });
        return layers;
    }
    /**
     * Clean up event listeners from layers and sources
     *
     * TODO: is this needed? when layers or sources are removed, then there is no Target anymore which listens for events?
     * there are also other functions like removeLayerByKey(), removeAllLayers()
     */
    cleanUpEventListeners(layerGroup, newLayers) {
        /** get Difference of old layers and new layers */
        const layersToRemove = layerGroup.getLayers().getArray().filter(x => !newLayers.map(l => l.get('id')).includes(x.get('id')));
        this.removeListenersFromOldLayers(layersToRemove);
        // TODO: is this done by setLayers??
        layersToRemove.forEach(l => layerGroup.getLayers().remove(l));
    }
    /**
     * on() and un() are functions of olObservable which extends EventTarget
     *
     * https://github.com/openlayers/openlayers/blob/v6.5.0/src/ol/events/Target.js#L145
     * https://github.com/openlayers/openlayers/blob/v6.5.0/src/ol/events/Target.js#L134
     */
    addEventsToLayer(ukisLayer, olLayer, olSource) {
        if (ukisLayer.events) {
            if (ukisLayer.events.layer) {
                ukisLayer.events.layer.forEach(e => {
                    const listeners = olLayer.getListeners(e.event);
                    /** only add listener if it was not registered on the olLayer object (for CustomLayer) */
                    if (!listeners) {
                        /** TODO: check Types on the next ol update - we only define a string so the user has to check if the right event is used */
                        olLayer.on(e.event, e.listener);
                    }
                });
            }
            if (ukisLayer.events.source) {
                ukisLayer.events.source.forEach(e => {
                    const listeners = olSource.getListeners(e.event);
                    /** only add listener if it was not registered on the olSource object (for CustomLayer) */
                    if (!listeners) {
                        /** TODO: check Types on the next ol update - we only define a string so the user has to check if the right event is used */
                        olSource.on(e.event, e.listener);
                    }
                });
            }
        }
    }
    /** TODO: try to remove/replace this function - Property 'disposeInternal' is protected ol function */
    removeListenersFromOldLayers(layers) {
        const disposeLayerInternal = (layer) => {
            if (typeof layer.getSource === 'function') {
                const source = layer.getSource();
                if (source) {
                    // https://github.com/dlr-eoc/ukis-frontend-libraries/issues/100
                    if (source instanceof olRasterSource) {
                        source.dispose();
                    }
                    if (source.hasListener()) {
                        source.disposeInternal();
                    }
                }
            }
            if (layer.hasListener()) {
                layer.disposeInternal();
            }
        };
        layers.forEach(l => {
            if (l instanceof olLayerGroup) {
                l.getLayers().forEach(subL => {
                    disposeLayerInternal(subL);
                });
            }
            else if (l instanceof olBaseLayer) {
                disposeLayerInternal(l);
            }
        });
    }
    /**
     * get corresponding Layer Group on which the layer is added
     */
    getLayerGroupForLayer(layer) {
        const subLayers = this.getLayersFromGroup(this.map.getLayerGroup(), null, true);
        subLayers.push(this.map.getLayerGroup());
        let lyerGroup = null;
        subLayers.forEach((l) => {
            if (l instanceof olLayerGroup) {
                const groupLayers = this.getLayersFromGroup(l);
                const hasLayer = groupLayers.find(i => i === layer);
                if (hasLayer) {
                    lyerGroup = {
                        group: l,
                        layer: hasLayer
                    };
                }
            }
        });
        return lyerGroup;
    }
    removeLayerByKey(key, filtertype) {
        const lowerType = filtertype.toLocaleLowerCase();
        const layer = this.getLayerByKey(key, lowerType);
        if (layer) {
            const gropObj = this.getLayerGroupForLayer(layer);
            if (gropObj.group) {
                const filterdLayers = this.getLayersFromGroup(gropObj.group).filter(i => i !== layer);
                gropObj.group.setLayers(new olCollection(filterdLayers));
            }
        }
    }
    updateLayerByKey(key, newLayer, filtertype) {
        const lowerType = filtertype.toLocaleLowerCase();
        this.map.getLayers().forEach((layerGroup) => {
            if (layerGroup.get(FILTER_TYPE_KEY) === lowerType) {
                const groupLayers = layerGroup.getLayers();
                groupLayers.forEach((oldLayer, index) => {
                    if (oldLayer.get(key.key) && oldLayer.get(key.key) === key.value) {
                        const newProperties = newLayer.getProperties();
                        const newExtent = newLayer.getExtent();
                        const newMaxZoom = newLayer.getMaxZoom();
                        const newMinZoom = newLayer.getMinZoom();
                        const newOpacity = newLayer.getOpacity();
                        const newVisible = newLayer.getVisible();
                        const newZIndex = newLayer.getZIndex();
                        if (oldLayer instanceof olLayer && newLayer instanceof olLayer) {
                            const newSource = newLayer.getSource();
                            oldLayer.setSource(newSource);
                        }
                        if (newProperties) {
                            oldLayer.setProperties(newProperties);
                        }
                        if (newExtent) {
                            oldLayer.setExtent(newExtent);
                        }
                        if (newMaxZoom) {
                            oldLayer.setMaxZoom(newMaxZoom);
                        }
                        if (newMinZoom) {
                            oldLayer.setMinZoom(newMinZoom);
                        }
                        if (newOpacity) {
                            oldLayer.setOpacity(newOpacity);
                        }
                        if (newVisible) {
                            oldLayer.setVisible(newVisible);
                        }
                        if (newZIndex) {
                            oldLayer.setZIndex(newZIndex);
                        }
                        oldLayer.changed();
                        groupLayers.setAt(index, oldLayer);
                    }
                });
                layerGroup.setLayers(groupLayers);
            }
        });
    }
    removeAllLayers(filtertype) {
        const lowerType = filtertype.toLowerCase();
        let layers;
        this.map.getLayers().getArray().forEach((layerGroup) => {
            if (layerGroup.get(FILTER_TYPE_KEY) === lowerType) {
                layers = layerGroup.getLayers();
                layers.clear();
            }
        });
    }
    /**
     * This function resets/adds all olLayers of a type with the new UKIS-Layers
     *
     * if only one group of them map is used and setLayers is called then the map flickers!
     * this is because all layers are newly created and each get new ol_uid's
     */
    setUkisLayers(layers, filtertype) {
        const lowerType = filtertype.toLowerCase();
        const tempLayers = [];
        // TODO try to deep check if a layer if exactly the same and dont create it new
        // create hash from layer???
        if (layers.length < 1 && lowerType !== 'baselayers') {
            // this.removeAllLayers('overlays');
            // this.removeAllLayers('layers');
            this.removeAllLayers(lowerType);
        }
        else {
            layers.forEach((newLayer) => {
                const layer = this.create_layers(newLayer);
                // check if layer not undefined
                if (layer) {
                    tempLayers.push(layer);
                }
            });
        }
        if (tempLayers.length > 0) {
            this.setLayers(tempLayers, lowerType);
            // TODO: checkt to replace type with filtertype -> but breaking Change!!
            const newTempLayer = {
                type: lowerType, layers: tempLayers
            };
            return newTempLayer;
        }
    }
    /** This function resets/adds a olLayer of a type with the new UKIS-Layer */
    setUkisLayer(newLayer, filtertype) {
        if (!filtertype) {
            filtertype = newLayer.filtertype;
        }
        const lowerType = filtertype.toLowerCase();
        const oldLayers = this.getLayers(lowerType);
        const oldLayer = oldLayers.find(l => l.get('id') === newLayer.id);
        const newOlLayer = this.create_layers(newLayer);
        if (oldLayer) {
            this.removeLayerByKey({ key: ID_KEY, value: oldLayer.get(ID_KEY) }, filtertype);
            this.addLayer(newOlLayer, filtertype);
        }
        else {
            this.addLayer(newOlLayer, filtertype);
        }
    }
    updateUkisLayer(newLayer, filtertype) {
        if (!filtertype) {
            filtertype = newLayer.filtertype;
        }
        const lowerType = filtertype.toLowerCase();
        const oldLayers = this.getLayers(lowerType);
        const oldLayer = oldLayers.find(l => l.get('id') === newLayer.id);
        const newOlLayer = this.create_layers(newLayer);
        if (newOlLayer) {
            this.updateLayerByKey({ key: ID_KEY, value: oldLayer.get(ID_KEY) }, newOlLayer, filtertype);
        }
    }
    create_layers(newLayer) {
        let newOlLayer;
        switch (newLayer.type) {
            case XyzLayertype:
                newOlLayer = this.create_xyz_layer(newLayer);
                break;
            case WmsLayertype:
                newOlLayer = this.create_wms_layer(newLayer);
                break;
            case WmtsLayertype:
                newOlLayer = this.create_wmts_layer(newLayer);
                break;
            case TmsLayertype:
                newOlLayer = this.create_tms_layer(newLayer);
                break;
            case GeojsonLayertype:
                newOlLayer = this.create_geojson_layer(newLayer);
                break;
            case KmlLayertype:
                newOlLayer = this.create_kml_layer(newLayer);
                break;
            case WfsLayertype:
                newOlLayer = this.create_wfs_layer(newLayer);
                break;
            case CustomLayertype:
                newOlLayer = this.create_custom_layer(newLayer);
                break;
            case StackedLayertype:
                newOlLayer = this.create_stacked_layer(newLayer);
                break;
        }
        return newOlLayer;
    }
    /**
     * create layeroptions olLayerOptions<OptionSources> & ILayerOptions
     * - id
     * - name
     * - filtertype
     * - type
     * - legendImg
     * - visible
     * - zIndex
     * - opacity
     * - attribution
     * - continuousWorld
     * - set crossOrigin for popup layers
     * - set source on layeroptions
     * - popup
     * - maxResolution/minResolution
     * - maxZoom/minZoom
     * - bbox
     */
    createOlLayerOptions(l, type, source) {
        if (source) {
            if (l.attribution) {
                source.setAttributions([l.attribution]);
            }
            if (l.continuousWorld) {
                /**
                 * set wrapX after source creation is not possible so we have to use the private property
                 * https://github.com/openlayers/openlayers/blob/v6.13.0/src/ol/source/Source.js#L48
                 */
                // tslint:disable-next-line: no-string-literal
                source['wrapX_'] = l.continuousWorld;
            }
            /** set crossOrigin for popup layers  */
            if (l.popup && !l.crossOrigin && l.crossOrigin !== null) {
                this.sourceSetCross(source);
            }
            if (l.crossOrigin || l.crossOrigin === null) {
                this.sourceSetCross(source);
            }
        }
        // ------------------------------------------
        const layeroptions = {
            // className - if
            opacity: l.opacity || 1,
            visible: l.visible,
            // extent - if
            zIndex: 1,
            // minResolution - if
            // maxResolution - if
            // minZoom - if
            // maxZoom - if
            // source - if
            // map - not set
            // render - not set
            // properties - not set
            id: l.id,
            name: l.name,
            filtertype: l.filtertype,
            type,
            legendImg: l.legendImg
        };
        if (source) {
            layeroptions.source = source;
        }
        if (l.popup) {
            layeroptions.popup = l.popup;
            /**
             * ol 6.x problem if popup (map.forEachLayerAtPixel) use className
             * https://github.com/openlayers/openlayers/releases/tag/v6.0.0
             */
            layeroptions.className = l.id;
        }
        if (l.maxResolution) {
            layeroptions.maxResolution = l.maxResolution;
        }
        if (l.minResolution) {
            layeroptions.minResolution = l.minResolution;
        }
        if (l.maxZoom) {
            layeroptions.maxZoom = l.maxZoom;
        }
        if (l.minZoom) {
            layeroptions.minZoom = l.minZoom;
        }
        if (l.bbox) {
            layeroptions.extent = transformExtent(l.bbox.slice(0, 4), WGS84, this.getProjection().getCode());
        }
        return layeroptions;
    }
    /**
     * define layer types
     */
    /**
     * https://openlayers.org/en/latest/apidoc/module-ol_layer_Tile-TileLayer.html
     * https://openlayers.org/en/latest/apidoc/module-ol_source_XYZ-XYZ.html
     */
    create_xyz_layer(l) {
        const xyzOptions = {
            wrapX: false
        };
        if (l.crossOrigin) {
            xyzOptions.crossOrigin = l.crossOrigin;
        }
        const olsource = new olXYZ(xyzOptions);
        const layeroptions = this.createOlLayerOptions(l, 'xyz', olsource);
        const baseTileLayerOptions = {
            preload: 0,
            useInterimTilesOnError: true
        };
        const newlayer = new olTileLayer(Object.assign(layeroptions, baseTileLayerOptions));
        this.setSubdomains(l, newlayer);
        this.setCrossOrigin(l, newlayer);
        this.addEventsToLayer(l, newlayer, olsource);
        return newlayer;
    }
    /**
     * create_xyz_layer for Raster
     *
     * or
     *
     * https://openlayers.org/en/latest/apidoc/module-ol_layer_VectorTile-VectorTileLayer.html
     * https://openlayers.org/en/latest/apidoc/module-ol_source_VectorTile-VectorTile.html
     * https://openlayers.org/en/latest/apidoc/module-ol_format_MVT-MVT.html
     */
    create_tms_layer(l) {
        let newlayer = null;
        if (l instanceof RasterLayer) {
            newlayer = this.create_xyz_layer(l);
            newlayer.set('type', 'tms');
            return newlayer;
        }
        else if (l instanceof VectorLayer) {
            const olsource = new olVectorTileSource({
                format: new olMVT(),
                tileGrid: createXYZ({ minZoom: l.minZoom || undefined, maxZoom: l.maxZoom || undefined }),
                url: l.url,
                wrapX: false
            });
            const layeroptions = this.createOlLayerOptions(l, 'tms', olsource);
            const vectorTileLayerOptions = {
                declutter: true,
                renderMode: 'hybrid'
            };
            newlayer = new olVectorTileLayer(Object.assign(layeroptions, vectorTileLayerOptions));
            this.setSubdomains(l, newlayer);
            this.setCrossOrigin(l, newlayer);
            this.addEventsToLayer(l, newlayer, olsource);
            const style = l?.options?.style;
            const mapboxSourceKey = l?.options?.styleSource;
            if (style && mapboxSourceKey) {
                applyStyle(newlayer, style, mapboxSourceKey);
            }
            return newlayer;
        }
    }
    create_wms_layer(l) {
        let newlayer;
        if (l.params?.TILED === 'true' || l.params?.TILED === undefined || l.params?.TILED === null) {
            newlayer = this.create_tiled_wms_layer(l);
        }
        else if (l.params?.TILED === 'false') {
            newlayer = this.create_image_wms_layer(l);
        }
        return newlayer;
    }
    /**
     * https://openlayers.org/en/latest/apidoc/module-ol_layer_Tile-TileLayer.html
     * https://openlayers.org/en/latest/apidoc/module-ol_source_TileWMS-TileWMS.html
     */
    create_tiled_wms_layer(l) {
        const tileOptions = {
            /** use assign here otherwise params is passed by object reference to the openlayers layer! */
            params: Object.assign({}, this.keysToUppercase(l.params)),
            wrapX: false
        };
        if (l.tileSize) {
            tileOptions['tileGrid'] = this.getTileGrid('default', null, l.tileSize);
            delete tileOptions.params['tileSize'];
        }
        if (l.crossOrigin) {
            tileOptions.crossOrigin = l.crossOrigin;
        }
        const olsource = new olTileWMS(tileOptions);
        const baseTileLayerOptions = {
            preload: 0,
            useInterimTilesOnError: true
        };
        const layeroptions = this.createOlLayerOptions(l, 'wms', olsource);
        const newlayer = new olTileLayer(Object.assign(layeroptions, baseTileLayerOptions));
        this.setSubdomains(l, newlayer);
        this.addEventsToLayer(l, newlayer, olsource);
        return newlayer;
    }
    /**
     * https://openlayers.org/en/latest/apidoc/module-ol_layer_Image-ImageLayer.html
     * https://openlayers.org/en/latest/apidoc/module-ol_source_ImageWMS-ImageWMS.html
     */
    create_image_wms_layer(l) {
        const options = {
            /**
             * use assign here otherwise params is passed by object reference to the openlayers layer!
             * https://thecodebarbarian.com/object-assign-vs-object-spread.html
             */
            params: Object.assign({}, this.keysToUppercase(l.params)),
            url: l.url
        };
        const olsource = new olImageWMS(options);
        const layeroptions = this.createOlLayerOptions(l, 'wms', olsource);
        const baseImageLayerOptions = {};
        const newlayer = new olImageLayer(Object.assign(layeroptions, baseImageLayerOptions));
        this.addEventsToLayer(l, newlayer, olsource);
        return newlayer;
    }
    /**
     * https://openlayers.org/en/latest/apidoc/module-ol_layer_Tile-TileLayer.html
     * https://openlayers.org/en/latest/apidoc/module-ol_source_WMTS-WMTS.html
     */
    create_wmts_layer(l) {
        if (l instanceof WmtsLayer) {
            let tileGrid = this.getTileGrid('wmts');
            let matrixSet = this.EPSG;
            if (l.params.matrixSetOptions) {
                matrixSet = l.params.matrixSetOptions.matrixSet;
                if ('resolutions' in l.params.matrixSetOptions) {
                    const resolutions = l.params.matrixSetOptions.resolutions;
                    tileGrid = this.getTileGrid('wmts', null, l.tileSize, null, resolutions);
                }
                else if ('resolutionLevels' in l.params.matrixSetOptions || 'tileMatrixPrefix' in l.params.matrixSetOptions) { /** ISimpleMatrixSet */
                    const resolutionLevels = l.params.matrixSetOptions.resolutionLevels;
                    const tileMatrixPrefix = l.params.matrixSetOptions.tileMatrixPrefix;
                    tileGrid = this.getTileGrid('wmts', resolutionLevels, l.tileSize, tileMatrixPrefix, null);
                }
                if ('matrixIds' in l.params.matrixSetOptions) {
                    const matrixIds = l.params.matrixSetOptions.matrixIds;
                    tileGrid = this.getTileGrid('wmts', null, l.tileSize, null, null, matrixIds);
                }
            }
            let wmtsOptions = {
                url: l.url,
                tileGrid,
                matrixSet,
                wrapX: false,
                layer: l.params.layer,
                style: l.params.style
            };
            wmtsOptions = Object.assign({}, wmtsOptions, l.params);
            if (l.crossOrigin) {
                wmtsOptions.crossOrigin = l.crossOrigin;
            }
            const olsource = new olWMTS(wmtsOptions);
            const layeroptions = this.createOlLayerOptions(l, 'wmts', olsource);
            const baseTileLayerOptions = {};
            const newlayer = new olTileLayer(Object.assign(layeroptions, baseTileLayerOptions));
            this.setSubdomains(l, newlayer);
            this.setCrossOrigin(l, newlayer);
            this.addEventsToLayer(l, newlayer, olsource);
            return newlayer;
        }
        else {
            const layer = l;
            console.error(`layer with id: ${layer.id} and type ${layer.type} is no instanceof WmtsLayer!`);
        }
    }
    /**
     * check projects/demo-maps/src/app/route-components/route-example-olperformance/services/largelayers.service.ts
     * for WFS examples.
     *
     * https://openlayers.org/en/latest/apidoc/module-ol_layer_Vector-VectorLayer.html
     * https://openlayers.org/en/latest/apidoc/module-ol_source_Vector-VectorSource.html
     */
    create_wfs_layer(l) {
        let url = null;
        if (l.url.indexOf('http://') === 0 || l.url.indexOf('https://') === 0) {
            url = new URL(l.url);
        }
        else {
            url = new URL(l.url, window.location.origin);
        }
        // making sure that srsname is set to current projection
        url.searchParams.set('srsname', this.EPSG);
        // note that we don't need to adjust the bbox. contrary to wms'es, in a wfs,
        // a bbox may use another projection than the srsname.
        const olsource = new olVectorSource({
            format: new olGeoJSON(),
            url: url.toString()
        });
        const layeroptions = this.createOlLayerOptions(l, 'wfs', olsource);
        const baseVectorLayerOptions = {};
        if (l.options) {
            // here Object.assign modifies the target object - style... is included
            Object.assign(baseVectorLayerOptions, l.options);
        }
        const newlayer = new olVectorLayer(Object.assign(layeroptions, baseVectorLayerOptions));
        if (l.cluster) {
            this.setCluster(l, newlayer, olsource, {});
        }
        this.setSubdomains(l, newlayer);
        this.setCrossOrigin(l, newlayer);
        this.addEventsToLayer(l, newlayer, olsource);
        return newlayer;
    }
    /**
     * https://openlayers.org/en/latest/apidoc/module-ol_layer_Vector-VectorLayer.html
     * https://openlayers.org/en/latest/apidoc/module-ol_source_Vector-VectorSource.html
     * https://openlayers.org/en/latest/apidoc/module-ol_format_GeoJSON-GeoJSON.html
     */
    create_geojson_layer(l) {
        let olsource;
        if (l.data) {
            olsource = new olVectorSource({
                features: this.geoJsonToFeatures(l.data),
                format: new olGeoJSON(),
                wrapX: false
            });
        }
        else if (l.url) {
            olsource = new olVectorSource({
                url: l.url,
                format: new olGeoJSON({
                    dataProjection: WGS84,
                    featureProjection: this.EPSG
                }),
                wrapX: false
            });
        }
        const layeroptions = this.createOlLayerOptions(l, 'geojson', olsource);
        const baseVectorLayerOptions = {};
        if (l.options) {
            // here Object.assign modifies the target object - style... is included
            Object.assign(baseVectorLayerOptions, l.options);
        }
        const newlayer = new olVectorLayer(Object.assign(layeroptions, baseVectorLayerOptions));
        if (l.cluster) {
            this.setCluster(l, newlayer, olsource, {});
        }
        this.setCrossOrigin(l, newlayer);
        this.addEventsToLayer(l, newlayer, olsource);
        return newlayer;
    }
    /**
     * https://openlayers.org/en/latest/apidoc/module-ol_layer_Vector-VectorLayer.html
     * https://openlayers.org/en/latest/apidoc/module-ol_source_Vector-VectorSource.html
     * https://openlayers.org/en/latest/apidoc/module-ol_format_KML-KML.html
     */
    create_kml_layer(l) {
        let olsource;
        if (l.data) {
            olsource = new olVectorSource({
                features: new olKML({ extractStyles: true }).readFeatures(l.data, {
                    dataProjection: WGS84,
                    featureProjection: this.EPSG
                }),
                format: new olKML(),
                wrapX: false
            });
        }
        else if (l.url) {
            olsource = new olVectorSource({
                url: l.url,
                format: new olKML({
                    extractStyles: true,
                    crossOrigin: (l.crossOrigin && l.crossOrigin === null) ? l.crossOrigin : 'anonymous',
                }),
                wrapX: false
            });
        }
        const layeroptions = this.createOlLayerOptions(l, 'kml', olsource);
        const baseVectorLayerOptions = {};
        if (l.options) {
            // here Object.assign modifies the target object - style... is included
            Object.assign(baseVectorLayerOptions, l.options);
        }
        const newlayer = new olVectorLayer(Object.assign(layeroptions, baseVectorLayerOptions));
        if (l.cluster) {
            this.setCluster(l, newlayer, olsource, {});
        }
        this.setCrossOrigin(l, newlayer);
        this.addEventsToLayer(l, newlayer, layeroptions.source);
        return newlayer;
    }
    /** bug fix: https://github.com/openlayers/openlayers/issues/10099 */
    setCrossOrigin(l, layer) {
        if (layer instanceof olLayer) {
            const olsource = layer.getSource();
            /** set crossOrigin for popup layers  */
            if (l.popup && !l.crossOrigin && l.crossOrigin !== null) {
                this.sourceSetCross(olsource);
            }
            if (l.crossOrigin || l.crossOrigin === null) {
                this.sourceSetCross(olsource);
            }
        }
    }
    /**
     * set cluster source and style for point layers
     */
    setCluster(l, layer, source, styleCache) {
        if (l.cluster) {
            const clusteroptions = {};
            if (typeof l.cluster === 'object') {
                // here Object.assign modifies the target object
                Object.assign(clusteroptions, l.cluster);
            }
            clusteroptions.source = source;
            const clusterSource = new olCluster(clusteroptions);
            // layeroptions.source = clusterSource;
            layer.setSource(clusterSource);
            layer.setStyle((feature) => {
                const size = feature.get('features').length;
                let style = styleCache[size];
                if (!style) {
                    style = new olStyle({
                        image: new olCircleStyle({
                            radius: 10,
                            stroke: new olStroke({
                                color: '#fff'
                            }),
                            fill: new olFill({
                                color: '#3399CC'
                            })
                        }),
                        text: new olText({
                            text: size.toString(),
                            fill: new olFill({
                                color: '#fff'
                            })
                        })
                    });
                    styleCache[size] = style;
                }
                return style;
            });
        }
    }
    /** use subdomains to setUrl/s on source */
    setSubdomains(l, layer) {
        if (l instanceof VectorLayer || l instanceof RasterLayer) {
            const source = layer.getSource();
            if (l.subdomains) {
                if (l.type === 'wfs' && (source instanceof olVectorSource)) {
                    l.url = l.url.replace('{s}', `${l.subdomains[0]}-${l.subdomains[l.subdomains.length - 1]}`);
                    source.setUrl(l.url);
                }
                else if (!(source instanceof olVectorSource)) {
                    const urls = l.subdomains.map((item) => l.url.replace('{s}', `${item}`));
                    source.setUrls(urls);
                }
            }
            else {
                source.setUrl(l.url);
            }
        }
    }
    sourceSetCross(source) {
        /**
         * https://github.com/search?q=crossOrigin+repo%3Aopenlayers%2Fopenlayers+path%3Asrc%2Fol%2Fsource%2F&type=Code&ref=advsearch&l=&l=
         */
        if (source instanceof olImageSource || source instanceof olTileImageSource || source instanceof olTileSource) {
            source['crossOrigin'] = 'anonymous';
            source['crossOrigin_'] = 'anonymous';
        }
    }
    /**
     * Use this Layer to add a not supported OpenLayers layer
     *
     * custom_layer: olBaseLayer
     */
    create_custom_layer(l) {
        if (l.custom_layer) {
            const layer = l.custom_layer;
            if (layer instanceof olLayer) {
                const olsource = layer.getSource();
                if (l.attribution) {
                    olsource.setAttributions([l.attribution]);
                }
                if (l.continuousWorld) {
                    /**
                     * set wrapX after source creation is not possible so we have to use the private property
                     * It works based on a test in codesandbox.io
                     * https://github.com/openlayers/openlayers/blob/v6.13.0/src/ol/source/Source.js#L48
                     */
                    // tslint:disable-next-line: no-string-literal
                    olsource['wrapX_'] = l.continuousWorld;
                }
                else {
                    // tslint:disable-next-line: no-string-literal
                    olsource['wrapX_'] = false;
                }
                this.setCrossOrigin(l, layer);
                this.addEventsToLayer(l, layer, olsource);
                // https://github.com/dlr-eoc/ukis-frontend-libraries/issues/100
                if (olsource instanceof olRasterSource) {
                    layer.on('change:source', (evt) => {
                        evt.oldValue.dispose();
                    });
                }
            }
            else if (layer instanceof olLayerGroup) {
                layer.getLayers().forEach(gl => {
                    const layerId = `${l.id}_${olGetUid(gl)}`;
                    if (!gl.get('id')) {
                        gl.set('id', layerId);
                    }
                    if (gl instanceof olLayer) {
                        this.setCrossOrigin(l, gl);
                        this.addEventsToLayer(l, gl, gl.getSource());
                    }
                    /**
                     * groups are flattened in map.forEachLayerAtPixel so add popup to each layer
                     * popup will be shown for top layer in the Group if there is a pixel color
                     */
                    if (l.popup && !gl.get('popup')) {
                        gl.set('popup', l.popup);
                        /** set className if not default ol-layer */
                        if (gl.getClassName() === 'ol-layer') {
                            gl['className_'] = layerId;
                        }
                    }
                });
            }
            else {
                console.error(`The custom_layer of ${l.id} in not a openlayers Layer`);
            }
            if (l.maxResolution) {
                layer.setMaxResolution(l.maxResolution);
            }
            if (l.minResolution) {
                layer.setMinResolution(l.minResolution);
            }
            if (l.maxZoom) {
                layer.setMaxZoom(l.maxZoom);
            }
            if (l.minZoom) {
                layer.setMinZoom(l.minZoom);
            }
            const layeroptions = {
                type: 'custom',
                name: l.name,
                id: l.id,
                visible: l.visible,
                legendImg: l.legendImg,
                opacity: l.opacity || 1,
                zIndex: 1,
            };
            if (l.popup && !(layer instanceof olLayerGroup)) {
                layeroptions.popup = l.popup;
                /**
                 * ol 6.x problem if popup (map.forEachLayerAtPixel) use className
                 * needs the class Name to detect if it is a different layer at the pixel value
                 * https://github.com/openlayers/openlayers/releases/tag/v6.0.0
                 */
                // tslint:disable-next-line: no-string-literal
                layer['className_'] = l.id;
            }
            if (l.bbox) {
                const extent = transformExtent(l.bbox.slice(0, 4), WGS84, this.getProjection().getCode());
                layer.setExtent(extent);
            }
            layer.setProperties(layeroptions);
            // don't delete the custom Layer, it is used to newly create all layers from layerservice after map all layers removed!
            // delete l.custom_layer;
            return layer;
        }
        else {
            console.log('attribute custom_layer not set on layer type custom!', l);
        }
    }
    /**
     * Use this Layer to stack multiple ukis layers in one.
     * creates a olLayerGroup from create_layers
     */
    create_stacked_layer(l) {
        if (l instanceof StackedLayer) {
            const layers = l.layers.map(ml => {
                /** Set all to visible because the visibility of merge layers cannot be controlled later */
                ml.visible = true;
                /** popups are get from the olLayer later so add them */
                ml.popup = l.popup;
                /** events are get from the olLayer later so add them */
                ml.events = l.events;
                return this.create_layers(ml);
            });
            const baseLayerOptions = this.createOlLayerOptions(l, 'custom');
            const groupOptions = {
                layers
            };
            const layerGroup = new olLayerGroup(Object.assign(baseLayerOptions, groupOptions));
            return layerGroup;
        }
        else {
            console.log('layer is not of type StackedLayer!', l);
        }
    }
    resolutionsFromExtent(extent, optMaxZoom, tileSize) {
        const maxZoom = optMaxZoom;
        const height = olGetHeight(extent);
        const width = olGetWidth(extent);
        const maxResolution = Math.max(width / tileSize, height / tileSize);
        const length = maxZoom + 1;
        const resolutions = new Array(length);
        for (let z = 0; z < length; ++z) {
            resolutions[z] = maxResolution / Math.pow(2, z);
        }
        return resolutions;
    }
    matrixIdsFromResolutions(resolutionLevels, matrixIdPrefix) {
        return Array.from(Array(resolutionLevels).keys()).map(l => {
            if (matrixIdPrefix) {
                return `${matrixIdPrefix}:${l}`;
            }
            else {
                return l;
            }
        });
    }
    getTileGrid(type = 'default', resolutionLevels, tileSize, matrixIdPrefix, resolutions, matrixIds) {
        const newResolutionLevels = resolutionLevels || DEFAULT_MAX_ZOOM;
        const newTileSize = tileSize || DEFAULT_TILE_SIZE;
        const newMatrixIdPrefix = matrixIdPrefix || '';
        const projectionExtent = this.getProjection().getExtent();
        const defaultResolutions = this.resolutionsFromExtent(projectionExtent, newResolutionLevels, newTileSize);
        const defaultMatrixIds = this.matrixIdsFromResolutions(defaultResolutions.length, newMatrixIdPrefix);
        /** how to generate matrix ids is not in the wms GetCapabilities ?? */
        const tileGridOptions = {
            extent: projectionExtent,
            origin: olGetTopLeft(projectionExtent),
            resolutions: resolutions || defaultResolutions,
            tileSize: [newTileSize, newTileSize]
        };
        if (type === 'wmts') {
            tileGridOptions.matrixIds = matrixIds || defaultMatrixIds;
            const grid = new olWMTSTileGrid(tileGridOptions);
            return grid;
        }
        else if (type === 'default') {
            const grid = new olTileGrid(tileGridOptions);
            return grid;
        }
    }
    isPopupObj(layerpopup) {
        return (layerpopup && typeof layerpopup === 'object') && !Array.isArray(layerpopup);
    }
    isPopupObjMove(layerpopup) {
        return (this.isPopupObj(layerpopup) && layerpopup.event === 'move');
    }
    isPopupObjClick(layerpopup) {
        return (this.isPopupObj(layerpopup) && layerpopup.event === 'click');
    }
    isPopupObjArray(layerpopup) {
        return Array.isArray(layerpopup) && layerpopup.length && this.isPopupObj(layerpopup[0]);
    }
    isPopupStringArray(layerpopup) {
        return Array.isArray(layerpopup) && layerpopup.length && typeof layerpopup[0] === 'string';
    }
    eventIsBrowserEvent(popupEvt, evt) {
        if (popupEvt === 'move' && evt.type === 'pointermove') {
            return true;
        }
        else if (popupEvt === 'click' && evt.type === 'click') {
            return true;
        }
    }
    /** USED in map-ol.component */
    /**
     * TODO:
     * - check the pointer event
     * - on move event set cursor -> depends on which kind of layer??
     *   layers with features and only color pixel
     *
     * - forEachFeatureAtPixel: Detect features that intersect a pixel on the viewport
     *   Vector Layers???
     *
     * - forEachLayerAtPixel: Detect layers that have a color value at a pixel on the viewport (false positives unless the map layers have had different className)
     *   Raster Layers???
     */
    /**
     *  layers_on_click() and layers_on_pointermove() should be removed
     *  this filtering must be done later
     *
     *  1. on a Map event Filter if map has layers on the pixel
     *  forEachLayerAtPixel: Detect layers that have a color value at a pixel on the viewport (false positives unless the map layers have had different className)
     *  check layer source crossOrigin = anonymous
     *
     *  2. Filter if it is the top visible layer - so no popups are shown for layers beneath https://github.com/dlr-eoc/ukis-frontend-libraries/issues/94#issuecomment-916759628
     *  3. check if the top visible layer has a popup property
     *  4. For this Layer change the cursor on forEachLayerAtPixel -> hit
     *
     *  5. Differentiate between raster and vector to get features or layer.color for the properties passed to the popup
     *  For Features change the cursor on forEachFeatureAtPixel -> hit
     *
     *  6. limit properties if popup property is: Array<string> | popup | popup[] -> popup?.filterkeys
     *  7. overwrite properties if popup property is: popup | popup[]
     *  8. check for popupFunction, asyncPopup and dynamicPopup
     *  9. use addPopup() or addPopupObj()
     *
     *  10. check popup event and if move popup exists => reuse old popup
     *  11. remove move popups if different event or !popup.event
     *  12. create new popup if not 10. or 11.
     *  13. prepare ol overlayoptions
     *  14. remove DynamicPopup if exists
     *  15. createPopupContainer
     *  16. set ol overlay addEvent and type = popup
     *  17. get coordinate from geometry or map.event
     *  18. set Position and map.addOverlay(overlay) if popup not exists
     */
    layersOnMapEvent(evt) {
        let layerHit = false;
        /**
         * Detect layers that have a color value at a pixel on the viewport, and execute a callback with each matching layer.
         * Layers included in the detection can be configured through opt_layerFilter.
         *
         * Note: this may give false positives unless the map layers have had different *className* properties assigned to them.
         * Also there could be cross-origin data, so set crossOrigin: 'anonymous' for layers where you want get pixel data!!
         */
        const item = this.map.forEachLayerAtPixel(evt.pixel, (layer, color) => {
            /**
             * return to stop detection and use the top (first detected) layer
             * This is faster than pushing the layers into an array and iterate over it.
             * And normally the user is only interested in the top Layer. If it is still necessary to detect several layers at the same time, then use a new function for map.on()
             */
            return { layer, color };
        }, {
            layerFilter: this.filterLayerNoPopup
        });
        if (item) {
            /**
             * only show for top layer and if top layer has popup
             */
            const hasPopup = (item.layer.get('popup'));
            if (hasPopup) {
                /** check if cursor was set (we need this only on move?) */
                this.hitLayerCurr = item.layer.get('id');
                if (!this.hitLayerPrev) {
                    this.hitLayerPrev = this.hitLayerCurr;
                }
                /** set cursor for Layers with a color value */
                if (item.color) {
                    layerHit = true;
                }
                /** remove cursor and move-popups on layer change */
                if (this.hitLayerPrev && this.hitLayerPrev !== this.hitLayerCurr) {
                    layerHit = false;
                    this.hitLayerPrev = this.hitLayerCurr;
                }
                const useEvent = this.topLayerCheckEvent(evt, hasPopup);
                if (useEvent) {
                    this.layerOnEvent(evt, item.layer, item.color);
                }
            }
        }
        if (layerHit) {
            this.map.getTargetElement().style.cursor = 'pointer';
        }
        else {
            this.removeAllPopups((item) => {
                return item.get('addEvent') === 'pointermove';
            });
            this.map.getTargetElement().style.cursor = '';
        }
    }
    topLayerCheckEvent(evt, popup) {
        let useEvent = null;
        const clickOrMove = (evt, popup) => {
            if (popup.event) {
                if (this.eventIsBrowserEvent(popup.event, evt) && this.isPopupObjClick(popup)) {
                    useEvent = 'click';
                }
                else if (this.eventIsBrowserEvent(popup.event, evt) && this.isPopupObjMove(popup)) {
                    useEvent = 'move';
                }
            }
            else {
                /** only show popups without an event for browser click  */
                if (evt.type === 'click') {
                    useEvent = 'click';
                }
            }
        };
        // check event is browser event
        if (typeof popup === 'boolean') {
            if (popup === true) {
                /** only show popups without an event for browser click  */
                if (evt.type === 'click') {
                    useEvent = 'click';
                }
            }
        }
        else if (this.isPopupStringArray(popup)) {
            /** only show popups without an event for browser click  */
            if (evt.type === 'click') {
                useEvent = 'click';
            }
        }
        else {
            /** popup is  popup | popup[] */
            if (this.isPopupObjArray(popup)) {
                popup.map(p => {
                    clickOrMove(evt, p);
                });
            }
            else {
                clickOrMove(evt, popup);
            }
        }
        return useEvent;
    }
    /**
     * https://openlayers.org/en/latest/apidoc/module-ol_layer_Layer-Layer.html#Subclasses
     */
    checkIsRaster(layer) {
        if (layer instanceof olBaseImageLayer || layer instanceof olBaseTileLayer) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * https://openlayers.org/en/latest/apidoc/module-ol_layer_Layer-Layer.html#Subclasses
     */
    checkIsVector(layer) {
        if (layer instanceof olBaseVectorLayer && !this.checkIsRaster(layer)) {
            return true;
        }
        else {
            return false;
        }
    }
    layerOnEvent(evt, layer, color) {
        if (this.checkIsRaster(layer)) {
            this.rasterOnEvent(evt, layer, color);
        }
        else if (this.checkIsVector(layer)) {
            this.vectorOnEvent(evt);
        }
    }
    vectorOnEvent(evt) {
        let featureHit = false;
        const item = this.map.forEachFeatureAtPixel(evt.pixel, (feature, layer) => {
            /** set cursor for features with a color value */
            featureHit = true;
            /**
             * return to stop detection and use the top (first detected) feature
             * This is faster than pushing the feature into an array and iterate over it.
             */
            return { feature, layer };
        }, {
            layerFilter: (layer) => {
                let shouldNotFilterLayer = true;
                if (layer instanceof olBaseVectorLayer) {
                    const olSource = layer.getSource();
                    if (olSource instanceof olCluster) {
                        shouldNotFilterLayer = olSource.getSource() instanceof olVectorSource;
                    }
                    else {
                        shouldNotFilterLayer = olSource instanceof olVectorSource || olSource instanceof olVectorTile;
                    }
                }
                const filter = this.filterLayerNoPopup(layer);
                if (filter === false) {
                    shouldNotFilterLayer = false;
                }
                /** fix for https://github.com/openlayers/openlayers/issues/12886 */
                const layerExtent = layer.getExtent();
                if (layerExtent) {
                    const pixelCoordinate = this.map.getCoordinateFromPixel(evt.pixel);
                    if (!olContainsCoordinate(layerExtent, pixelCoordinate)) {
                        shouldNotFilterLayer = false;
                    }
                }
                return shouldNotFilterLayer;
            },
            hitTolerance: this.hitTolerance
        });
        if (item) {
            /**
             * only show for top feature and if top layer has popup
             */
            const hasPopup = (item.layer.get('popup'));
            if (hasPopup) {
                const layer = item.layer;
                const feature = item.feature;
                let properties = {};
                const childFeatures = feature.getProperties().features;
                if (childFeatures && childFeatures.length === 1) {
                    const childFeature = childFeatures[0];
                    properties = childFeature.getProperties();
                }
                else if (childFeatures && childFeatures.length > 1) {
                    /**
                     * zoom to cluster on click
                     * or check for layerpopup.event !== move
                     */
                    if (evt.type === 'click') {
                        const extent = this.getFeaturesExtent(feature.getProperties().features);
                        this.setExtent(extent);
                        return false;
                    }
                    else {
                        return true;
                    }
                }
                else {
                    // type no cluster
                    properties = feature.getProperties();
                }
                this.prepareAddPopup(properties, layer, feature, evt, hasPopup);
            }
        }
        if (featureHit) {
            this.map.getTargetElement().style.cursor = 'pointer';
        }
        else {
            this.map.getTargetElement().style.cursor = '';
        }
    }
    rasterOnEvent(evt, layer, color) {
        const layerpopup = layer.get('popup');
        let properties = {};
        if (layerpopup) {
            properties = layer.getProperties();
            properties.evt = evt;
            if (color) {
                properties.color = color;
            }
            this.prepareAddPopup(properties, layer, null, evt, layerpopup);
        }
    }
    prepareAddPopup(layerProperties, layer, feature, evt, layerpopup) {
        const args = {
            modelName: layerProperties.id,
            properties: layerProperties,
            layer,
            feature,
            event: evt
        };
        let popupProperties = Object.assign({}, layerProperties);
        if (popupProperties.geometry) {
            delete popupProperties.geometry;
        }
        const limitPopupObjProperties = (popupObj) => {
            if (popupObj && popupObj.filterkeys) {
                popupProperties = Object.keys(popupProperties)
                    .filter(key => popupObj.filterkeys.includes(key))
                    .reduce((obj, key) => {
                    obj[key] = popupProperties[key];
                    return obj;
                }, {});
            }
        };
        /** Popup is array - limit properties */
        if (this.isPopupStringArray(layerpopup)) {
            popupProperties = Object.keys(popupProperties)
                .filter(key => layerpopup.includes(key))
                .reduce((obj, key) => {
                obj[key] = popupProperties[key];
                return obj;
            }, {});
        }
        /** Popup is array of popupObj - limit properties */
        else if (this.isPopupObjArray(layerpopup)) {
            // is the first popupObj in the array with the same event as evt.type
            const popupObj = layerpopup.find(p => this.eventIsBrowserEvent(p.event, evt));
            limitPopupObjProperties(popupObj);
        }
        /** Popup is object - limit properties */
        else if (this.isPopupObj(layerpopup)) {
            limitPopupObjProperties(layerpopup);
        }
        const overwritePopup = (popupObj) => {
            /** overwrite the keys of the layer properties */
            if (popupObj.properties) {
                const usedProperties = Object.keys(popupObj.properties);
                if (Array.isArray(usedProperties)) {
                    popupProperties = Object.keys(popupProperties)
                        /* .filter(key => usedProperties.includes(key)) */
                        .reduce((obj, key) => {
                        const newKey = popupObj.properties[key];
                        if (newKey) {
                            obj[newKey] = popupProperties[key];
                        }
                        else {
                            obj[key] = popupProperties[key];
                        }
                        return obj;
                    }, {});
                }
            }
        };
        /** overwrite and us popupFunction or dynamicPopup */
        if (this.isPopupObjArray(layerpopup)) {
            layerpopup.forEach(p => {
                if (this.eventIsBrowserEvent(p.event, evt)) {
                    overwritePopup(p);
                }
            });
        }
        else if (this.isPopupObj(layerpopup)) {
            overwritePopup(layerpopup);
        }
        const addPopupObj = (popupObj) => {
            /** async function where you can paste a html string to the callback */
            if ('asyncPopup' in popupObj) {
                popupObj.asyncPopup(popupProperties, (html) => {
                    this.addPopup(args, null, html, popupObj.event, popupObj.single);
                });
                /** add event if popup object */
            }
            else {
                /** adjust args if popupFunction or dynamicPopup*/
                if (popupObj.popupFunction) {
                    args.popupFn = popupObj.popupFunction; //This could be done in createPopupContainer()
                }
                else if (popupObj.dynamicPopup) {
                    args.dynamicPopup = popupObj.dynamicPopup; // This could be done in createPopupContainer()
                }
                this.addPopup(args, popupProperties, null, popupObj.event, popupObj.single);
            }
        };
        /** popup is boolean or string array */
        if (typeof layerpopup === 'boolean' || this.isPopupStringArray(layerpopup)) {
            this.addPopup(args, popupProperties, null);
        }
        /** popup array of popupObj */
        else if (this.isPopupObjArray(layerpopup)) {
            layerpopup.forEach(p => {
                // filter that browser event and popup event are the same
                if (this.eventIsBrowserEvent(p.event, evt)) {
                    addPopupObj(p);
                }
            });
        }
        /** popup is a popupObj */
        else if (layerpopup) {
            addPopupObj(layerpopup);
        }
    }
    // TODO: overlapping layers - move popup is added on click ???
    addPopup(args, popupObj, html, event, removePopups) {
        const layerpopup = args.layer.get('popup');
        // check if popup is already there and event is move
        const layerID = args.layer.get('id');
        const moveID = `popup_move_ID`;
        const moveKeyLayerFeature = 'move_ID_L_F';
        const movePopup = this.getPopups().find(item => item.getId() === moveID);
        const browserEvent = args.event;
        let moveIDlf = null;
        if (event === 'move') {
            /** only on raster color is added - see rasterOnEvent()*/
            if (args.properties?.color) {
                moveIDlf = `${layerID}:${args.properties?.color.toString()}`;
            }
            else {
                if (args.feature) {
                    moveIDlf = `${layerID}:${olGetUid(args.feature)}`;
                }
                else if (args.layer) {
                    moveIDlf = `${layerID}:${olGetUid(args.layer)}`;
                }
            }
        }
        /**
         * If event move and the map already has a Overlay for move
         * then only create new html container and set the position
         */
        if (event === 'move' && browserEvent.type === 'pointermove' && movePopup) {
            let coordinate;
            if (args.properties && args.properties.geometry && args.properties.geometry.getType() === 'Point') {
                coordinate = args.properties.geometry.getCoordinates();
            }
            else {
                coordinate = browserEvent.coordinate;
            }
            /** check if layer or feature changes, then only create new container */
            if (moveIDlf !== movePopup.get(moveKeyLayerFeature)) {
                const container = this.createPopupContainer(movePopup, args, popupObj, html, event);
                movePopup.setElement(container);
            }
            movePopup.setPosition(coordinate);
            /** update movePopup to be rendered over the previous added popup */
            movePopup.getElement().parentElement.style.zIndex = '1';
        }
        else if (browserEvent.type === 'pointermove' && !event) {
            /** remove move popup if move on a click layer */
            if (movePopup) {
                this.removeAllPopups((item) => {
                    return item.get('addEvent') === 'pointermove';
                });
            }
        }
        else if (browserEvent.type === 'pointermove' && event === 'click') {
            if (movePopup) {
                this.removeAllPopups((item) => {
                    return item.get('addEvent') === 'pointermove';
                });
            }
        }
        else {
            let popupID = null;
            if (event === 'move') {
                popupID = moveID;
            }
            else {
                if (args.feature) {
                    popupID = `${layerID}:${olGetUid(args.feature)}`;
                }
                else if (args.layer) {
                    popupID = `${layerID}:${olGetUid(args.layer)}`;
                }
                else {
                    popupID = `${layerID}:popup_${new Date().getTime()}`;
                }
            }
            const defaultOptions = {
                // element: container,
                autoPan: true,
                id: popupID,
                autoPanAnimation: {
                    duration: 250
                },
                positioning: OverlayPositioning.BOTTOM_CENTER,
                stopEvent: true,
                insertFirst: false,
            };
            let overlayoptions = defaultOptions;
            /**
             * Check if popup is an array of popup obj's or a popup obj
             * then merge the popup?.options with the default ol/overlay options
             */
            if (this.isPopupObjArray(layerpopup)) {
                const objForEvent = layerpopup.find(p => this.eventIsBrowserEvent(p.event, browserEvent));
                if (objForEvent.options) {
                    overlayoptions = Object.assign(defaultOptions, objForEvent.options);
                }
            }
            else if (this.isPopupObj(layerpopup) && layerpopup.options) {
                overlayoptions = Object.assign(defaultOptions, layerpopup.options);
            }
            const overlay = new olOverlay(overlayoptions);
            if (moveIDlf) {
                overlay.set(moveKeyLayerFeature, moveIDlf);
            }
            if (removePopups) {
                this.removeAllPopups((item) => {
                    // only remove the popups from the current layer
                    const elementID = item.getId();
                    const layer = elementID.toString().split(':')[0];
                    if (layer) {
                        if (layerID === layer) {
                            return layerID === layer;
                        }
                    }
                    else {
                        return true;
                    }
                });
            }
            const hasPopup = this.getPopups().find(item => (item.getId() === overlay.getId() && overlay.getId() !== moveID));
            if (hasPopup) {
                // removes ol-part of popup
                this.map.removeOverlay(hasPopup);
                // removes angular-part of popup
                this.destroyDynamicPopupComponent(hasPopup.getId().toString());
            }
            const container = this.createPopupContainer(overlay, args, popupObj, html, event);
            /** edge case when moving and clicking sometimes the browser event is not like the popup event */
            if (overlay.getId() === moveID) {
                overlay.set('addEvent', 'pointermove');
            }
            else {
                overlay.set('addEvent', browserEvent.type);
            }
            overlay.set(OVERLAY_TYPE_KEY, 'popup');
            overlay.setElement(container);
            let coordinate;
            if (args.properties && args.properties.geometry && args.properties.geometry.getType() === 'Point') {
                coordinate = args.properties.geometry.getCoordinates();
            }
            else {
                coordinate = browserEvent.coordinate;
            }
            overlay.setPosition(coordinate);
            /**
             * edge case prevent add multiple movePopup's
             * only add a new popup if it's not a movePopup or there isn't a already existing movePopup
             */
            if (!(movePopup && event === 'move')) {
                this.map.addOverlay(overlay);
            }
        }
    }
    createPopupContainer(overlay, args, popupObj, html, event) {
        const content = document.createElement('div');
        content.className = 'ol-popup-content';
        let popupHtml = '';
        if (args.popupFn) {
            popupHtml = args.popupFn(popupObj);
        }
        else if (html && (!popupObj || Object.keys(popupObj).length === 0)) {
            popupHtml = html;
        }
        else {
            popupHtml = this.createPopupHtml(popupObj);
        }
        content.innerHTML = popupHtml;
        if (args.dynamicPopup) {
            // To prevent memory leak:
            // if this very popup already has been created (for example `popup_move_ID`),
            // then destroy it before creating a new one.
            const id = overlay.getId().toString();
            this.destroyDynamicPopupComponent(id);
            // Only now create a new one.
            const dArgs = {
                event: args.event,
                layer: args.layer,
                feature: args.feature || null,
                dynamicPopup: args.dynamicPopup,
                properties: popupObj,
            };
            this.createDynamicPopupComponent(id, content, dArgs);
        }
        const container = document.createElement('div');
        container.className = 'ol-popup';
        container.id = overlay.getId().toString();
        container.style.display = 'block';
        if (!event || event !== 'move') {
            const closer = document.createElement('a');
            closer.className = 'ol-popup-closer';
            container.appendChild(closer);
            const closeFunction = () => {
                closer.removeEventListener('click', closeFunction, false);
                // removes ol-part of popup
                this.map.removeOverlay(overlay);
                // removes angular-part of popup
                this.destroyDynamicPopupComponent(overlay.getId().toString());
            };
            closer.addEventListener('click', closeFunction, false);
        }
        container.appendChild(content);
        return container;
    }
    /** USED in map-ol.component */
    removeAllPopups(filter) {
        let popups = this.getPopups();
        if (filter) {
            popups = this.getPopups().filter(filter);
        }
        popups.forEach((overlay) => {
            if (overlay.get(OVERLAY_TYPE_KEY) === 'popup') {
                // removes ol-part of popup
                this.map.removeOverlay(overlay);
                // removes angular-part of popup
                this.destroyDynamicPopupComponent(overlay.getId().toString());
            }
        });
    }
    createPopupHtml(obj) {
        let htmlStr = '<table>';
        for (const o in obj) {
            if (obj.hasOwnProperty(o)) {
                htmlStr += '<tr><td style="vertical-align: top; padding-right: 7px;"><b>' + o + ': </b></td><td>' + obj[o] +
                    '</td></tr>';
            }
        }
        htmlStr = htmlStr + '</table>';
        return htmlStr;
    }
    getPopups() {
        const popups = [];
        this.map.getOverlays().getArray().slice(0).forEach((overlay) => {
            if (overlay.get(OVERLAY_TYPE_KEY) === 'popup') {
                popups.push(overlay);
            }
        });
        return popups;
    }
    /**
     * Destroys a popup-component.
     *  - kills the component (with `.destroy()`)
     *  - detaches it from angular-application (with `.destroy()`)
     *  - removes the entry from `this.dynamicPopupComponents`
     * @param id : The string under which the popup-component has been stored in `this.dynamicPopupComponents`
     */
    destroyDynamicPopupComponent(id) {
        if (this.dynamicPopupComponents.has(id)) {
            this.dynamicPopupComponents.get(id).destroy();
            this.dynamicPopupComponents.delete(id);
        }
    }
    /**
     * Creates an angular component to be used as popup-body.
     *  - creates component
     *  - attaches component-view to angular-application
     *  - keeps reference to component in `this.dynamicPopupComponents` for later removal.
     *
     * @param id : The container-id. Also the id under which the component will be stored in `this.dynamicPopupComponents`.
     * @param anchorElement : The html-element to which the popup-component shall be attached
     * @param args : Must contain `dynamicPopup`
     */
    createDynamicPopupComponent(id, anchorElement, args) {
        const factory = this.crf.resolveComponentFactory(args.dynamicPopup.component);
        const popupBody = factory.create(this.injector, [], anchorElement);
        if (args.dynamicPopup.getAttributes) {
            const attributes = args.dynamicPopup.getAttributes(args);
            for (const key in attributes) {
                if (attributes[key] !== 'undefined') {
                    popupBody.instance[key] = attributes[key];
                }
            }
        }
        this.app.attachView(popupBody.hostView);
        this.dynamicPopupComponents.set(id, popupBody);
    }
    /**
     *
     * @param extent: [minX, minY, maxX, maxY]
     * @param geographic: boolean
     * @param fitOptions: olFitOptions
     * @returns olExtend: [minX, minY, maxX, maxY]
     */
    setExtent(extent, geographic, fitOptions) {
        const projection = (geographic) ? getProjection(WGS84) : getProjection(this.EPSG);
        const transfomExtent = transformExtent(extent.slice(0, 4), projection, this.getProjection().getCode());
        const newFitOptions = {
            size: this.map.getSize(),
            // padding: [100, 200, 100, 100] // Padding (in pixels) to be cleared inside the view. Values in the array are top, right, bottom and left padding. Default is [0, 0, 0, 0].
        };
        if (fitOptions) {
            Object.assign(newFitOptions, fitOptions);
        }
        this.map.getView().fit(transfomExtent, fitOptions);
        return transfomExtent;
    }
    /** USED in map-ol.component */
    /** ol.Coordinate xy */
    setCenter(center, geographic) {
        const projection = (geographic) ? getProjection(WGS84) : getProjection(this.EPSG);
        const transfomCenter = transform(center, projection, this.getProjection().getCode());
        // console.log('set center in svc', transfomCenter)
        // console.log(this.map.getView().getCenter())
        this.map.getView().setCenter(transfomCenter);
        return transfomCenter;
    }
    /** USED in map-ol.component */
    getCenter(geographic) {
        const dstProjection = (geographic) ? getProjection(WGS84) : getProjection(this.EPSG);
        const srcProjection = getProjection(this.getProjection().getCode());
        const transfomCenter = transform(this.map.getView().getCenter(), srcProjection, dstProjection);
        return transfomCenter;
    }
    /**
     *
     * @param features: olFeature[]
     * @param geographic: boolean
     * @returns olExtend: [minX, minY, maxX, maxY]
     */
    getFeaturesExtent(features, geographic) {
        const extent = features[0].getGeometry().getExtent().slice(0);
        features.forEach((feature) => {
            olExtend(extent, feature.getGeometry().getExtent());
        });
        if (geographic) {
            const projection = getProjection(WGS84);
            const transfomExtent = transformExtent(extent, this.getProjection().getCode(), projection);
            return transfomExtent;
        }
        else {
            return extent;
        }
    }
    /** USED in map-ol.component */
    /**
     * @param geographic: boolean
     * @returns olExtend: [minX, minY, maxX, maxY]
     */
    getCurrentExtent(geographic) {
        const projection = (geographic) ? getProjection(WGS84) : getProjection(this.EPSG);
        const extent = this.map.getView().calculateExtent();
        const transfomExtent = transformExtent(extent, this.getProjection().getCode(), projection);
        return transfomExtent;
    }
    /** USED in map-ol.component */
    setZoom(zoom, notifier) {
        const view = this.map.getView();
        view.setZoom(zoom);
    }
    /** USED in map-ol.component */
    getZoom() {
        return this.map.getView().getZoom();
    }
    zoomInOut(value) {
        const view = this.map.getView();
        if (!view) {
            // the map does not have a view, so we can't act
            // upon it
            return;
        }
        const duration = 250;
        const delta = value === '+' ? 1 : -1;
        const currentZoom = view.getZoom();
        if (currentZoom !== undefined) {
            const newZoom = view.getConstrainedZoom(currentZoom + delta);
            if (duration > 0) {
                if (view.getAnimating()) {
                    view.cancelAnimations();
                }
                view.animate({
                    zoom: newZoom,
                    duration,
                    easing: easeOut
                });
            }
            else {
                view.setZoom(newZoom);
            }
        }
    }
    geoJsonToFeature(geojson) {
        const GEOJSON = new olGeoJSON({
            dataProjection: WGS84,
            featureProjection: this.EPSG
        });
        return GEOJSON.readFeature(geojson);
    }
    geoJsonToFeatures(geojson) {
        const GEOJSON = new olGeoJSON({
            dataProjection: WGS84,
            featureProjection: this.EPSG
        });
        return GEOJSON.readFeatures(geojson);
    }
    /**
     * @returns 'olProjection'
     */
    getProjection() {
        return this.map.getView().getProjection();
    }
    /**
     * function to reproject vector features
     * @param source:  olVectorSource
     * @param srcProj: string (e.g. 'EPSG:4326')
     * @param dstProj: string (e.g. 'EPSG:3857')
     */
    reprojectFeatures(source, srcProj, dstProj) {
        source.getFeatures().forEach(feature => {
            feature.getGeometry().transform(srcProj, dstProj);
        });
    }
    /**
     * vector layers will be reprojected automatically
     * wms layers will be updated with corresponding proj def in the requests.
     * for other raster layers and for those wms layers which backend does not support target projection, please
     * define initial(default) layer projection, so openlayers will reproject on the client side
     * projection is proj~ProjectionLike
     */
    setProjection(projection) {
        if (projection) {
            let viewOptions = {};
            if (this.viewOptions) {
                viewOptions = this.viewOptions;
                viewOptions.minResolution = undefined;
                viewOptions.maxResolution = undefined;
                viewOptions.resolution = undefined;
                viewOptions.resolutions = undefined;
            }
            if (projection instanceof olProjection) {
                viewOptions.projection = projection;
                const newCenter = transform(this.map.getView().getCenter(), this.map.getView().getProjection(), projection); // get center coordinates in the new projection
                viewOptions.center = newCenter; // this.map.getView().getCenter();
                // _viewOptions.extent = projection.getExtent();// || undefined;
                viewOptions.zoom = this.map.getView().getZoom();
            }
            else if (typeof projection === 'string') {
                viewOptions.projection = projection;
                viewOptions.center = this.map.getView().getCenter();
                viewOptions.zoom = this.map.getView().getZoom();
            }
            const view = new olView(viewOptions);
            const oldProjection = this.EPSG;
            this.EPSG = view.getProjection().getCode();
            this.map.setView(view);
            this.view = this.map.getView();
            // reprojecting vector layers
            this.map.getLayers().getArray().forEach((layerGroup) => {
                layerGroup.getLayers().getArray().forEach(layer => {
                    if (layer instanceof olLayer) {
                        let source = layer.getSource();
                        // check for nested sources, e.g. cluster or cluster of clusters etc
                        while (source['source']) {
                            source = source['source'];
                        }
                        if (source instanceof olVectorSource) {
                            this.reprojectFeatures(source, oldProjection, this.EPSG);
                        }
                    }
                });
            });
            this.projectionChange.next(this.getProjection());
        }
        else {
            // console.log('projection code is undefined');
        }
    }
    /**
     * @param projDef.code - e.g.: "EPSG:4326"
     * @param projDef.proj4js - e.g.: "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"
     */
    registerProjection(projDef) {
        proj4.defs(projDef.code, projDef.proj4js);
        olRegister(proj4);
    }
    /**
     * Returns a OpenLayers Projection from Options
     */
    getOlProjection(projDef) {
        return new olProjection({
            code: projDef.code,
            extent: projDef.extent ? projDef.extent : undefined,
            worldExtent: projDef.worldExtent ? projDef.worldExtent : undefined,
            global: projDef.global ? projDef.global : false,
            units: projDef.units ? projDef.units : undefined
        });
    }
    keysToUppercase(obj) {
        Object.keys(obj).forEach((key) => {
            const k = key.toUpperCase();
            if (k !== key) {
                obj[k] = obj[key];
                delete obj[key];
            }
        });
        return obj;
    }
}
MapOlService.fac = i0.ngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: MapOlService, deps: [{ token: i0.ComponentFactoryResolver }, { token: i0.ApplicationRef }, { token: i0.Injector }], target: i0.FactoryTarget.Injectable });
MapOlService.prov = i0.ngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: MapOlService, providedIn: 'root' });
i0.ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: MapOlService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i0.ComponentFactoryResolver }, { type: i0.ApplicationRef }, { type: i0.Injector }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFwLW9sLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9tYXAtb2wvc3JjL2xpYi9tYXAtb2wuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFvRSxNQUFNLGVBQWUsQ0FBQztBQUc3RyxPQUFPLEVBQVMsV0FBVyxFQUFlLFdBQVcsRUFBUyxTQUFTLEVBQXVDLFlBQVksRUFBRSxnQkFBZ0IsRUFBRSxlQUFlLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxnQkFBZ0IsRUFBRSxZQUFZLEVBQUUsYUFBYSxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQW1DLE1BQU0sMEJBQTBCLENBQUM7QUFFeFUsT0FBTyxLQUFLLE1BQU0sUUFBUSxDQUFDO0FBQzNCLE9BQU8sTUFBTSxNQUFNLFNBQVMsQ0FBQztBQUc3QixPQUFPLFdBQVcsTUFBTSxlQUFlLENBQUM7QUFHeEMsT0FBTyxPQUFPLE1BQU0sZ0JBQWdCLENBQUM7QUFLckMsT0FBTyxZQUFZLE1BQU0sZ0JBQWdCLENBQUM7QUFFMUMsT0FBTyxTQUFTLE1BQU0sWUFBWSxDQUFDO0FBR25DLE9BQU8sZUFBZSxNQUFNLG1CQUFtQixDQUFDO0FBRWhELE9BQU8saUJBQWlCLE1BQU0scUJBQXFCLENBQUM7QUFFcEQsT0FBTyxnQkFBZ0IsTUFBTSxvQkFBb0IsQ0FBQztBQUdsRCxPQUFPLFlBQVksTUFBTSxnQkFBZ0IsQ0FBQztBQUUxQyxPQUFPLFdBQVcsTUFBTSxlQUFlLENBQUM7QUFDeEMsT0FBTyxhQUFhLE1BQU0saUJBQWlCLENBQUM7QUFDNUMsT0FBTyxZQUFZLE1BQU0sc0JBQXNCLENBQUM7QUFFaEQsT0FBTyxpQkFBaUIsTUFBTSxxQkFBcUIsQ0FBQztBQUVwRCxPQUFPLGtCQUFrQixNQUFNLHNCQUFzQixDQUFDO0FBQ3RELE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUM3QyxP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R0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUNsQixPQUFPLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUNqQjtRQUNILENBQUMsQ0FBQyxDQUFDO1FBQ0gsT0FBTyxHQUFRLENBQUM7SUFDbEIsQ0FBQzs7eUdBandFVSxZQUFZOzZHQUFaLFlBQVksY0FGWCxNQUFNOzJGQUVQLFlBQVk7a0JBSHhCLFVBQVU7bUJBQUM7b0JBQ1YsVUFBVSxFQUFFLE1BQU07aUJBQ25CIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBBcHBsaWNhdGlvblJlZiwgSW5qZWN0b3IsIENvbXBvbmVudFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5cbmltcG9ydCB7IExheWVyLCBWZWN0b3JMYXllciwgQ3VzdG9tTGF5ZXIsIFJhc3RlckxheWVyLCBwb3B1cCwgV210c0xheWVyLCBXbXNMYXllciwgVEdlb0V4dGVudCwgSUxheWVyT3B0aW9ucywgU3RhY2tlZExheWVyLCBTdGFja2VkTGF5ZXJ0eXBlLCBDdXN0b21MYXllcnR5cGUsIFdmc0xheWVydHlwZSwgS21sTGF5ZXJ0eXBlLCBHZW9qc29uTGF5ZXJ0eXBlLCBUbXNMYXllcnR5cGUsIFdtdHNMYXllcnR5cGUsIFdtc0xheWVydHlwZSwgWHl6TGF5ZXJ0eXBlLCBJVmVjdG9yTGF5ZXJPcHRpb25zLCBJQW55T2JqZWN0IH0gZnJvbSAnQGRsci1lb2Mvc2VydmljZXMtbGF5ZXJzJztcblxuaW1wb3J0IG9sTWFwIGZyb20gJ29sL01hcCc7XG5pbXBvcnQgb2xWaWV3IGZyb20gJ29sL1ZpZXcnO1xuaW1wb3J0IHsgVmlld09wdGlvbnMgYXMgb2xWaWV3T3B0aW9ucyB9IGZyb20gJ29sL1ZpZXcnO1xuXG5pbXBvcnQgb2xCYXNlTGF5ZXIgZnJvbSAnb2wvbGF5ZXIvQmFzZSc7XG5pbXBvcnQgb2xTb3VyY2UgZnJvbSAnb2wvc291cmNlL1NvdXJjZSc7XG5pbXBvcnQgb2xHZW9tZXRyeSBmcm9tICdvbC9nZW9tL0dlb21ldHJ5JztcbmltcG9ydCBvbExheWVyIGZyb20gJ29sL2xheWVyL0xheWVyJztcbmltcG9ydCB7IE9wdGlvbnMgYXMgb2xMYXllck9wdGlvbnMgfSBmcm9tICdvbC9sYXllci9MYXllcic7XG5pbXBvcnQgQ2FudmFzVmVjdG9yTGF5ZXJSZW5kZXJlciBmcm9tICdvbC9yZW5kZXJlci9jYW52YXMvVmVjdG9yTGF5ZXInO1xuaW1wb3J0IENhbnZhc1RpbGVMYXllclJlbmRlcmVyIGZyb20gJ29sL3JlbmRlcmVyL2NhbnZhcy9UaWxlTGF5ZXInO1xuaW1wb3J0IENhbnZhc0ltYWdlTGF5ZXJSZW5kZXJlciBmcm9tICdvbC9yZW5kZXJlci9jYW52YXMvSW1hZ2VMYXllcic7XG5pbXBvcnQgb2xMYXllckdyb3VwIGZyb20gJ29sL2xheWVyL0dyb3VwJztcbmltcG9ydCB7IE9wdGlvbnMgYXMgb2xMYXllckdyb3VwT3B0aW9ucyB9IGZyb20gJ29sL2xheWVyL0dyb3VwJztcbmltcG9ydCBvbE92ZXJsYXkgZnJvbSAnb2wvT3ZlcmxheSc7XG5pbXBvcnQgeyBPcHRpb25zIGFzIG9sT3ZlcmxheU9wdGlvbnMgfSBmcm9tICdvbC9PdmVybGF5JztcblxuaW1wb3J0IG9sQmFzZVRpbGVMYXllciBmcm9tICdvbC9sYXllci9CYXNlVGlsZSc7XG5pbXBvcnQgeyBPcHRpb25zIGFzIG9sQmFzZVRpbGVMYXllck9wdGlvbnMgfSBmcm9tICdvbC9sYXllci9CYXNlVGlsZSc7XG5pbXBvcnQgb2xCYXNlVmVjdG9yTGF5ZXIgZnJvbSAnb2wvbGF5ZXIvQmFzZVZlY3Rvcic7XG5pbXBvcnQgeyBPcHRpb25zIGFzIG9sQmFzZVZlY3RvckxheWVyT3B0aW9ucyB9IGZyb20gJ29sL2xheWVyL0Jhc2VWZWN0b3InO1xuaW1wb3J0IG9sQmFzZUltYWdlTGF5ZXIgZnJvbSAnb2wvbGF5ZXIvQmFzZUltYWdlJztcbmltcG9ydCB7IE9wdGlvbnMgYXMgb2xCYXNlSW1hZ2VMYXllck9wdGlvbnMgfSBmcm9tICdvbC9sYXllci9CYXNlSW1hZ2UnO1xuXG5pbXBvcnQgb2xJbWFnZUxheWVyIGZyb20gJ29sL2xheWVyL0ltYWdlJztcblxuaW1wb3J0IG9sVGlsZUxheWVyIGZyb20gJ29sL2xheWVyL1RpbGUnO1xuaW1wb3J0IG9sVmVjdG9yTGF5ZXIgZnJvbSAnb2wvbGF5ZXIvVmVjdG9yJztcbmltcG9ydCBvbFZlY3RvclRpbGUgZnJvbSAnb2wvc291cmNlL1ZlY3RvclRpbGUnO1xuXG5pbXBvcnQgb2xWZWN0b3JUaWxlTGF5ZXIgZnJvbSAnb2wvbGF5ZXIvVmVjdG9yVGlsZSc7XG5pbXBvcnQgeyBPcHRpb25zIGFzIG9sVmVjdG9yVGlsZUxheWVyT3B0aW9ucyB9IGZyb20gJ29sL2xheWVyL1ZlY3RvclRpbGUnO1xuaW1wb3J0IG9sVmVjdG9yVGlsZVNvdXJjZSBmcm9tICdvbC9zb3VyY2UvVmVjdG9yVGlsZSc7XG5pbXBvcnQgeyBhcHBseVN0eWxlIH0gZnJvbSAnb2wtbWFwYm94LXN0eWxlJztcbmltcG9ydCB7IGNyZWF0ZVhZWiB9IGZyb20gJ29sL3RpbGVncmlkJztcbmltcG9ydCBvbE1WVCBmcm9tICdvbC9mb3JtYXQvTVZUJztcblxuaW1wb3J0IG9sWFlaIGZyb20gJ29sL3NvdXJjZS9YWVonO1xuaW1wb3J0IG9sVGlsZVNvdXJjZSBmcm9tICdvbC9zb3VyY2UvVGlsZSc7XG5cbmltcG9ydCB7IE9wdGlvbnMgYXMgb2xYWVpPcHRpb25zIH0gZnJvbSAnb2wvc291cmNlL1hZWic7XG5pbXBvcnQgb2xUaWxlV01TIGZyb20gJ29sL3NvdXJjZS9UaWxlV01TJztcbmltcG9ydCB7IE9wdGlvbnMgYXMgb2xUaWxlV01TT3B0aW9ucyB9IGZyb20gJ29sL3NvdXJjZS9UaWxlV01TJztcbmltcG9ydCBvbEltYWdlV01TIGZyb20gJ29sL3NvdXJjZS9JbWFnZVdNUyc7XG5pbXBvcnQgeyBPcHRpb25zIGFzIG9sSW1hZ2VXTVNPcHRpb25zIH0gZnJvbSAnb2wvc291cmNlL0ltYWdlV01TJztcbmltcG9ydCBvbFRpbGVJbWFnZVNvdXJjZSBmcm9tICdvbC9zb3VyY2UvVGlsZUltYWdlJztcbmltcG9ydCBvbEltYWdlU291cmNlIGZyb20gJ29sL3NvdXJjZS9JbWFnZSc7XG5pbXBvcnQgb2xXTVRTIGZyb20gJ29sL3NvdXJjZS9XTVRTJztcbmltcG9ydCB7IE9wdGlvbnMgYXMgb2xXTVRTT3B0aW9ucyB9IGZyb20gJ29sL3NvdXJjZS9XTVRTJztcbmltcG9ydCBvbFdNVFNUaWxlR3JpZCBmcm9tICdvbC90aWxlZ3JpZC9XTVRTJztcbmltcG9ydCB7IE9wdGlvbnMgYXMgb2xXTVRTVGlsZUdyaWRPcHRpb25zIH0gZnJvbSAnb2wvdGlsZWdyaWQvV01UUyc7XG5pbXBvcnQgb2xUaWxlR3JpZCBmcm9tICdvbC90aWxlZ3JpZC9UaWxlR3JpZCc7XG5pbXBvcnQgb2xWZWN0b3JTb3VyY2UgZnJvbSAnb2wvc291cmNlL1ZlY3Rvcic7XG5pbXBvcnQgb2xSYXN0ZXJTb3VyY2UgZnJvbSAnb2wvc291cmNlL1Jhc3Rlcic7XG5pbXBvcnQgb2xDbHVzdGVyIGZyb20gJ29sL3NvdXJjZS9DbHVzdGVyJztcbmltcG9ydCB7IE9wdGlvbnMgYXMgb2xDbHVzdGVyT3B0aW9ucyB9IGZyb20gJ29sL3NvdXJjZS9DbHVzdGVyJztcbmltcG9ydCBvbEZlYXR1cmUgZnJvbSAnb2wvRmVhdHVyZSc7XG5cbmltcG9ydCBvbENvbGxlY3Rpb24gZnJvbSAnb2wvQ29sbGVjdGlvbic7XG5pbXBvcnQgb2xHZW9KU09OIGZyb20gJ29sL2Zvcm1hdC9HZW9KU09OJztcbmltcG9ydCBvbEtNTCBmcm9tICdvbC9mb3JtYXQvS01MJztcbmltcG9ydCBvbFByb2plY3Rpb24gZnJvbSAnb2wvcHJvai9Qcm9qZWN0aW9uJztcbmltcG9ydCB7IE9wdGlvbnMgYXMgb2xQcm9qZWN0aW9uT3B0aW9ucyB9IGZyb20gJ29sL3Byb2ovUHJvamVjdGlvbic7XG5pbXBvcnQgeyB0cmFuc2Zvcm1FeHRlbnQsIGdldCBhcyBnZXRQcm9qZWN0aW9uLCB0cmFuc2Zvcm0gfSBmcm9tICdvbC9wcm9qJztcbmltcG9ydCB7IHJlZ2lzdGVyIGFzIG9sUmVnaXN0ZXIgfSBmcm9tICdvbC9wcm9qL3Byb2o0JztcbmltcG9ydCBwcm9qNCBmcm9tICdwcm9qNCc7XG5pbXBvcnQgeyBleHRlbmQgYXMgb2xFeHRlbmQsIGdldFdpZHRoIGFzIG9sR2V0V2lkdGgsIGdldEhlaWdodCBhcyBvbEdldEhlaWdodCwgZ2V0VG9wTGVmdCBhcyBvbEdldFRvcExlZnQsIGNvbnRhaW5zQ29vcmRpbmF0ZSBhcyBvbENvbnRhaW5zQ29vcmRpbmF0ZSB9IGZyb20gJ29sL2V4dGVudCc7XG5pbXBvcnQgeyBERUZBVUxUX01BWF9aT09NLCBERUZBVUxUX1RJTEVfU0laRSB9IGZyb20gJ29sL3RpbGVncmlkL2NvbW1vbic7XG5pbXBvcnQgeyBlYXNlT3V0IH0gZnJvbSAnb2wvZWFzaW5nLmpzJztcblxuaW1wb3J0IG9sU3R5bGUgZnJvbSAnb2wvc3R5bGUvU3R5bGUnO1xuaW1wb3J0IG9sVGV4dCBmcm9tICdvbC9zdHlsZS9UZXh0JztcbmltcG9ydCBvbEZpbGwgZnJvbSAnb2wvc3R5bGUvRmlsbCc7XG5pbXBvcnQgb2xDaXJjbGVTdHlsZSBmcm9tICdvbC9zdHlsZS9DaXJjbGUnO1xuaW1wb3J0IG9sU3Ryb2tlIGZyb20gJ29sL3N0eWxlL1N0cm9rZSc7XG5cbmltcG9ydCB7IERyYWdCb3ggfSBmcm9tICdvbC9pbnRlcmFjdGlvbic7XG5pbXBvcnQgb2xNYXBCcm93c2VyRXZlbnQgZnJvbSAnb2wvTWFwQnJvd3NlckV2ZW50JztcbmltcG9ydCBvbFJlbmRlckZlYXR1cmUgZnJvbSAnb2wvcmVuZGVyL0ZlYXR1cmUnO1xuaW1wb3J0IG9sRXZlbnQgZnJvbSAnb2wvZXZlbnRzL0V2ZW50JztcbmltcG9ydCB7IE9wdGlvbnMgYXMgRHJhZ0JveE9wdGlvbnMgfSBmcm9tICdvbC9pbnRlcmFjdGlvbi9EcmFnQm94JztcbmltcG9ydCB7IGdldFVpZCBhcyBvbEdldFVpZCB9IGZyb20gJ29sL3V0aWwnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZmxhdHRlbkxheWVycyB9IGZyb20gJ0BkbHItZW9jL3V0aWxzLW1hcHMnO1xuaW1wb3J0IE92ZXJsYXlQb3NpdGlvbmluZyBmcm9tICdvbC9PdmVybGF5UG9zaXRpb25pbmcnO1xuXG5cbmV4cG9ydCBkZWNsYXJlIHR5cGUgVGdyb3VwZmlsdGVydHlwZSA9ICdiYXNlbGF5ZXJzJyB8ICdsYXllcnMnIHwgJ292ZXJsYXlzJyB8ICdCYXNlbGF5ZXJzJyB8ICdPdmVybGF5cycgfCAnTGF5ZXJzJztcbmNvbnN0IE9WRVJMQVlfVFlQRV9LRVkgPSAndHlwZSc7XG5jb25zdCBGSUxURVJfVFlQRV9LRVkgPSAnZmlsdGVydHlwZSc7XG5jb25zdCBJRF9LRVkgPSAnaWQnO1xuY29uc3QgVElUTEVfS0VZID0gJ3RpdGxlJztcbmNvbnN0IFdlYk1lcmNhdG9yID0gJ0VQU0c6Mzg1Nyc7XG5jb25zdCBXR1M4NCA9ICdFUFNHOjQzMjYnO1xuXG4vKipcbiAqIFdoaWxlIEBkbHItZW9jL3NlcnZpY2VzLWxheWVycy5wb3B1cCBhbHJlYWR5IGNvbnRhaW5zIGluc3RydWN0aW9ucyBhYm91dCBob3cgdG8gYnVpbGQgYSBwb3B1cCxcbiAqIElQb3B1cEFyZ3MgYWRkcyBhZGRpdGlvbmFsLCBtYXAtb2wtc3BlY2lmaWMgY29udGV4dCBsaWtlIHRoZSBvbExheWVyLCB0aGUgZmVhdHVyZSwgYW5kIHRoZSBvbE1hcEJyb3dzZXJFdmVudC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJUG9wdXBBcmdzIHtcbiAgbW9kZWxOYW1lOiBzdHJpbmc7XG4gIHByb3BlcnRpZXM6IHBvcHVwWydwcm9wZXJ0aWVzJ107IC8vIHdpbGwgYmUgZmlsdGVyZWQgYnkgcG9wdXBbJ2ZpbHRlcmtleXMnXSAoaWYgZ2l2ZW4pXG4gIGxheWVyOiBvbExheWVyPGFueT47XG4gIGZlYXR1cmU/OiBvbEZlYXR1cmU8YW55PiB8IG9sUmVuZGVyRmVhdHVyZTtcbiAgZXZlbnQ6IG9sTWFwQnJvd3NlckV2ZW50PFBvaW50ZXJFdmVudD47XG4gIHBvcHVwRm4/OiBwb3B1cFsncG9wdXBGdW5jdGlvbiddO1xuICBkeW5hbWljUG9wdXA/OiBwb3B1cFsnZHluYW1pY1BvcHVwJ107XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBJRHluYW1pY1BvcHVwQXJncyB7XG4gIHByb3BlcnRpZXM6IHBvcHVwWydwcm9wZXJ0aWVzJ107IC8vIHdpbGwgYmUgZmlsdGVyZWQgYnkgcG9wdXBbJ2ZpbHRlcmtleXMnXSAoaWYgZ2l2ZW4pXG4gIGxheWVyOiBJUG9wdXBBcmdzWydsYXllciddO1xuICBmZWF0dXJlPzogSVBvcHVwQXJnc1snZmVhdHVyZSddO1xuICBldmVudDogb2xNYXBCcm93c2VyRXZlbnQ8UG9pbnRlckV2ZW50PjtcbiAgZHluYW1pY1BvcHVwOiBwb3B1cFsnZHluYW1pY1BvcHVwJ107XG59XG5cblxudHlwZSB0bXNSZXR1cm5UeXBlPFQ+ID0gVCBleHRlbmRzIFJhc3RlckxheWVyID8gb2xUaWxlTGF5ZXI8b2xUaWxlU291cmNlPiA6XG4gIFQgZXh0ZW5kcyBWZWN0b3JMYXllciA/IG9sVmVjdG9yVGlsZUxheWVyIDogbmV2ZXI7XG5cbnR5cGUgTGF5ZXJPcHRpb25zU291cmNlcyA9IG9sVGlsZVNvdXJjZSB8IG9sVmVjdG9yVGlsZVNvdXJjZSB8IG9sSW1hZ2VTb3VyY2UgfCBvbFNvdXJjZTtcblxuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCdcbn0pXG5leHBvcnQgY2xhc3MgTWFwT2xTZXJ2aWNlIHtcbiAgcHVibGljIG1hcDogb2xNYXA7IC8vIG9sLk1hcDtcbiAgcHVibGljIHZpZXc6IG9sVmlldztcbiAgcHJpdmF0ZSB2aWV3T3B0aW9uczogb2xWaWV3T3B0aW9ucztcbiAgcHVibGljIEVQU0c6IHN0cmluZztcbiAgcHJpdmF0ZSBoaXRUb2xlcmFuY2UgPSAwO1xuICBwcml2YXRlIGhpdExheWVyQ3VyciA9IG51bGw7XG4gIHByaXZhdGUgaGl0TGF5ZXJQcmV2ID0gbnVsbDtcbiAgLyoqICdvbFByb2plY3Rpb24nICovXG4gIHB1YmxpYyBwcm9qZWN0aW9uQ2hhbmdlID0gbmV3IFN1YmplY3Q8b2xQcm9qZWN0aW9uPigpO1xuICAvKipcbiAgICogVGhpcyBvYmplY3Qga2VlcHMgdHJhY2sgb2YgY3VycmVudGx5IGJvdW5kIGFuZ3VsYXItY29tcG9uZW50cyB0aGF0IGFyZSBiZWluZyB1c2VkIGFzIHBvcHVwcy5cbiAgICogV2Uga2VlcCBhIHJlZmVyZW5jZSB0byB0aGVtIGhlcmUgc28gdGhhdCB3ZSBjYW4gcmVtb3ZlIHRoZW0gYWdhaW4gYWZ0ZXIgdGhleSBhcmUgbm8gbG9uZ2VyIGRpc3BsYXllZC5cbiAgICovXG4gIHByaXZhdGUgZHluYW1pY1BvcHVwQ29tcG9uZW50czogTWFwPHN0cmluZywgQ29tcG9uZW50UmVmPGFueT4+ID0gbmV3IE1hcCgpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgY3JmOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgcHJpdmF0ZSBhcHA6IEFwcGxpY2F0aW9uUmVmLFxuICAgIHByaXZhdGUgaW5qZWN0b3I6IEluamVjdG9yXG4gICkge1xuICAgIHRoaXMubWFwID0gbmV3IG9sTWFwKHsgY29udHJvbHM6IFtdIH0pO1xuICAgIHRoaXMudmlldyA9IG5ldyBvbFZpZXcoKTtcbiAgICB0aGlzLkVQU0cgPSBXZWJNZXJjYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBpZiB0aGlzIGlzIHVzZWQgaW4gYW4gYW5ndWxhciBjb21wb25lbnQgdGhlbiBzZXQgdGhlIHRhcmdldCBhZnRlciB0aGUgdmlldyBpcyBjcmVhdGVkXG4gICAqIGUuZy4gdGhpcy5tYXAuc2V0VGFyZ2V0KHRoaXMubWFwRGl2Vmlldy5uYXRpdmVFbGVtZW50KSBpbiBuZ0FmdGVyVmlld0luaXQoKVxuICAgKi9cbiAgcHVibGljIGNyZWF0ZU1hcCh0YXJnZXQ/OiBIVE1MRWxlbWVudCkge1xuICAgIGNvbnN0IHpvb20gPSAwO1xuICAgIGNvbnN0IGNlbnRlciA9IHtcbiAgICAgIGxhdDogMCxcbiAgICAgIGxvbjogMFxuICAgIH07XG5cbiAgICBjb25zdCBiYXNlbGF5ZXJHcm91cCA9IG5ldyBvbExheWVyR3JvdXAoe1xuICAgICAgbGF5ZXJzOiBbXVxuICAgIH0pO1xuICAgIGJhc2VsYXllckdyb3VwLnNldChGSUxURVJfVFlQRV9LRVksICdiYXNlbGF5ZXJzJyk7XG4gICAgYmFzZWxheWVyR3JvdXAuc2V0KFRJVExFX0tFWSwgJ0Jhc2UgbWFwcycpO1xuICAgIGJhc2VsYXllckdyb3VwLnNldChJRF9LRVksICdJRF9maWx0ZXJ0eXBlX2Jhc2VsYXllcnMnKTtcblxuXG4gICAgY29uc3QgbGF5ZXJzR3JvdXAgPSBuZXcgb2xMYXllckdyb3VwKHtcbiAgICAgIGxheWVyczogW11cbiAgICB9KTtcbiAgICBsYXllcnNHcm91cC5zZXQoRklMVEVSX1RZUEVfS0VZLCAnbGF5ZXJzJyk7XG4gICAgbGF5ZXJzR3JvdXAuc2V0KFRJVExFX0tFWSwgJ0xheWVycycpO1xuICAgIGxheWVyc0dyb3VwLnNldChJRF9LRVksICdJRF9maWx0ZXJ0eXBlX2xheWVycycpO1xuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgY29uc3Qgb3ZlcmxheUdyb3VwID0gbmV3IG9sTGF5ZXJHcm91cCh7XG4gICAgICBsYXllcnM6IFtdXG4gICAgfSk7XG4gICAgb3ZlcmxheUdyb3VwLnNldChGSUxURVJfVFlQRV9LRVksICdvdmVybGF5cycpO1xuICAgIG92ZXJsYXlHcm91cC5zZXQoVElUTEVfS0VZLCAnT3ZlcmxheXMnKTtcbiAgICBvdmVybGF5R3JvdXAuc2V0KElEX0tFWSwgJ0lEX2ZpbHRlcnR5cGVfb3ZlcmxheXMnKTtcblxuICAgIC8qKlxuICAgICAqIHNldCBkZWZhdWx0IHZpZXdPcHRpb25zXG4gICAgICovXG4gICAgdGhpcy52aWV3T3B0aW9ucyA9IHtcbiAgICAgIGNlbnRlcjogdHJhbnNmb3JtKFtjZW50ZXIubG9uLCBjZW50ZXIubGF0XSwgV0dTODQsIHRoaXMuRVBTRyksXG4gICAgICB6b29tLFxuICAgICAgcHJvamVjdGlvbjogZ2V0UHJvamVjdGlvbih0aGlzLkVQU0cpXG4gICAgfTtcblxuICAgIGlmICh0aGlzLnZpZXdbJ2NvbnN0cmFpblJvdGF0aW9uJ10pIHtcbiAgICAgIHRoaXMudmlld09wdGlvbnMuY29uc3RyYWluUm90YXRpb24gPSB0aGlzLnZpZXdbJ2NvbnN0cmFpblJvdGF0aW9uJ107XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudmlld1snZW5hYmxlUm90YXRpb24nXSkge1xuICAgICAgdGhpcy52aWV3T3B0aW9ucy5lbmFibGVSb3RhdGlvbiA9IHRoaXMudmlld1snZW5hYmxlUm90YXRpb24nXTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy52aWV3WydleHRlbnQnXSkge1xuICAgICAgdGhpcy52aWV3T3B0aW9ucy5leHRlbnQgPSB0aGlzLnZpZXdbJ2V4dGVudCddO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnZpZXdbJ2NvbnN0cmFpbk9ubHlDZW50ZXInXSkge1xuICAgICAgdGhpcy52aWV3T3B0aW9ucy5jb25zdHJhaW5Pbmx5Q2VudGVyID0gdGhpcy52aWV3Wydjb25zdHJhaW5Pbmx5Q2VudGVyJ107XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudmlld1snc21vb3RoRXh0ZW50Q29uc3RyYWludCddKSB7XG4gICAgICB0aGlzLnZpZXdPcHRpb25zLnNtb290aEV4dGVudENvbnN0cmFpbnQgPSB0aGlzLnZpZXdbJ3Ntb290aEV4dGVudENvbnN0cmFpbnQnXTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy52aWV3LmdldE1heFJlc29sdXRpb24oKSkge1xuICAgICAgdGhpcy52aWV3T3B0aW9ucy5tYXhSZXNvbHV0aW9uID0gdGhpcy52aWV3LmdldE1heFJlc29sdXRpb24oKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy52aWV3LmdldE1pblJlc29sdXRpb24oKSkge1xuICAgICAgdGhpcy52aWV3T3B0aW9ucy5taW5SZXNvbHV0aW9uID0gdGhpcy52aWV3LmdldE1pblJlc29sdXRpb24oKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy52aWV3LmdldE1heFpvb20oKSkge1xuICAgICAgdGhpcy52aWV3T3B0aW9ucy5tYXhab29tID0gdGhpcy52aWV3LmdldE1heFpvb20oKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy52aWV3LmdldE1pblpvb20oKSkge1xuICAgICAgdGhpcy52aWV3T3B0aW9ucy5taW5ab29tID0gdGhpcy52aWV3LmdldE1pblpvb20oKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy52aWV3WydtdWx0aVdvcmxkJ10pIHtcbiAgICAgIHRoaXMudmlld09wdGlvbnMubXVsdGlXb3JsZCA9IHRoaXMudmlld1snbXVsdGlXb3JsZCddO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnZpZXdbJ2NvbnN0cmFpblJlc29sdXRpb24nXSkge1xuICAgICAgdGhpcy52aWV3T3B0aW9ucy5jb25zdHJhaW5SZXNvbHV0aW9uID0gdGhpcy52aWV3Wydjb25zdHJhaW5SZXNvbHV0aW9uJ107XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudmlld1snc21vb3RoUmVzb2x1dGlvbkNvbnN0cmFpbnQnXSkge1xuICAgICAgdGhpcy52aWV3T3B0aW9ucy5zbW9vdGhSZXNvbHV0aW9uQ29uc3RyYWludCA9IHRoaXMudmlld1snc21vb3RoUmVzb2x1dGlvbkNvbnN0cmFpbnQnXTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy52aWV3LmdldFJlc29sdXRpb24oKSkge1xuICAgICAgdGhpcy52aWV3T3B0aW9ucy5yZXNvbHV0aW9uID0gdGhpcy52aWV3LmdldFJlc29sdXRpb24oKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy52aWV3LmdldFJlc29sdXRpb25zKCkpIHtcbiAgICAgIHRoaXMudmlld09wdGlvbnMucmVzb2x1dGlvbnMgPSB0aGlzLnZpZXcuZ2V0UmVzb2x1dGlvbnMoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy52aWV3Wydyb3RhdGlvbiddKSB7XG4gICAgICB0aGlzLnZpZXdPcHRpb25zLnJvdGF0aW9uID0gdGhpcy52aWV3Wydyb3RhdGlvbiddO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnZpZXdbJ3pvb21GYWN0b3InXSkge1xuICAgICAgdGhpcy52aWV3T3B0aW9ucy56b29tRmFjdG9yID0gdGhpcy52aWV3Wyd6b29tRmFjdG9yJ107XG4gICAgfVxuICAgIGNvbnN0IHRlbXB2aWV3ID0gbmV3IG9sVmlldyh0aGlzLnZpZXdPcHRpb25zKTtcblxuICAgIC8qKiBkZWZpbmUgbWFwIGluIGNvbnN0cnVjdG9yIHNvIGl0IGlzIGNyZWF0ZWQgYmVmb3JlIHRvIHVzZSBpdCBpbiBwcm9qZWN0cyBvbkluaXQgTWV0aG9kICAqL1xuICAgIFtiYXNlbGF5ZXJHcm91cCwgbGF5ZXJzR3JvdXAsIG92ZXJsYXlHcm91cF0ubWFwKGxheWVyID0+IHRoaXMubWFwLmFkZExheWVyKGxheWVyKSk7XG4gICAgdGhpcy5tYXAuc2V0Vmlldyh0ZW1wdmlldyk7XG4gICAgLy8gdGhpcy5tYXAuZ2V0Q29udHJvbHMoKS5jbGVhcigpO1xuICAgIHRoaXMudmlldyA9IHRoaXMubWFwLmdldFZpZXcoKTtcbiAgICB0aGlzLnNldFByb2plY3Rpb24odGhpcy5FUFNHKTtcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICB0aGlzLm1hcC5zZXRUYXJnZXQodGFyZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hcDogdGhpcy5tYXAsXG4gICAgICB2aWV3OiB0aGlzLnZpZXdcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIHNldEhpdFRvbGVyYW5jZSh0b2xlcmFuY2U6IG51bWJlcikge1xuICAgIHRoaXMuaGl0VG9sZXJhbmNlID0gdG9sZXJhbmNlO1xuICB9XG5cbiAgcHVibGljIGdldEhpdFRvbGVyYW5jZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oaXRUb2xlcmFuY2U7XG4gIH1cblxuICAvKipcbiAgICogU2VlIHRoaXMgZXhhbXBsZTpcbiAgICogaHR0cHM6Ly9vcGVubGF5ZXJzLm9yZy9lbi9sYXRlc3QvZXhhbXBsZXMvYm94LXNlbGVjdGlvbi5odG1sXG4gICAqL1xuICBwdWJsaWMgYWRkQmJveFNlbGVjdGlvbihjb25kaXRpb25Gb3JEcmF3aW5nOiAoZXZ0OiBhbnkpID0+IGJvb2xlYW4sIG9uQm94U3RhcnQ/OiAoZXZ0OiBvbEV2ZW50KSA9PiB2b2lkLCBvbkJveEVuZD86IChleHQsIGV2dDogb2xFdmVudCkgPT4gdm9pZCwgZHJhZ0JveE9wdGlvbnM/OiBEcmFnQm94T3B0aW9ucykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBjbGFzc05hbWU6ICdvbC1kcmFnLXNlbGVjdCcsXG4gICAgICBjb25kaXRpb246IGNvbmRpdGlvbkZvckRyYXdpbmcsXG4gICAgfTtcbiAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIGRyYWdCb3hPcHRpb25zKTtcbiAgICBjb25zdCBkcmFnQm94ID0gbmV3IERyYWdCb3goZHJhZ0JveE9wdGlvbnMpO1xuICAgIGlmIChvbkJveFN0YXJ0KSB7XG4gICAgICAvKiogVE9ETzogY2hlY2sgVHlwZXMgb24gdGhlIG5leHQgb2wgdXBkYXRlICovXG4gICAgICAoZHJhZ0JveCBhcyBhbnkpLm9uKCdib3hzdGFydCcsIChldnQpID0+IHtcbiAgICAgICAgb25Cb3hTdGFydChldnQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG9uQm94RW5kKSB7XG4gICAgICBkcmFnQm94Lm9uKCdib3hlbmQnLCAoZXZ0KSA9PiB7XG4gICAgICAgIGNvbnN0IGV4dGVudCA9IGRyYWdCb3guZ2V0R2VvbWV0cnkoKS5nZXRFeHRlbnQoKTtcbiAgICAgICAgb25Cb3hFbmQoZXh0ZW50LCBldnQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5tYXAuYWRkSW50ZXJhY3Rpb24oZHJhZ0JveCk7XG4gICAgcmV0dXJuIGRyYWdCb3g7XG4gIH1cblxuICAvKipcbiAgICogZ2V0IGFuIGFycmF5IG9mIG9sTGF5ZXJzIGZyb20gYSBncm91cCB0eXBlXG4gICAqL1xuICBwdWJsaWMgZ2V0TGF5ZXJzKGZpbHRlcnR5cGU6IFRncm91cGZpbHRlcnR5cGUpIHtcbiAgICBjb25zdCBsb3dlclR5cGUgPSBmaWx0ZXJ0eXBlLnRvTG93ZXJDYXNlKCkgYXMgVGdyb3VwZmlsdGVydHlwZTtcbiAgICBsZXQgbGF5ZXJzOiBvbEJhc2VMYXllcltdO1xuICAgIHRoaXMubWFwLmdldExheWVycygpLmdldEFycmF5KCkuZm9yRWFjaCgobGF5ZXJHcm91cDogb2xMYXllckdyb3VwKSA9PiB7XG4gICAgICBpZiAobGF5ZXJHcm91cC5nZXQoRklMVEVSX1RZUEVfS0VZKSA9PT0gbG93ZXJUeXBlKSB7XG4gICAgICAgIGxheWVycyA9IGxheWVyR3JvdXAuZ2V0TGF5ZXJzKCkuZ2V0QXJyYXkoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbGF5ZXJzO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRMYXllcnNGcm9tR3JvdXAoZ3JvdXA6IG9sTGF5ZXJHcm91cCwgZmlsdGVydHlwZT86IHN0cmluZywgcmVjdXJzaXZlID0gZmFsc2UpIHtcbiAgICBjb25zdCBsYXllcnMgPSBncm91cC5nZXRMYXllcnMoKS5nZXRBcnJheSgpO1xuICAgIGxldCB0ZW1wTGF5ZXJzID0gbGF5ZXJzO1xuICAgIGlmIChyZWN1cnNpdmUpIHtcbiAgICAgIGxldCBncm91cHM6IG9sQmFzZUxheWVyW10gPSBbXS5jb25jYXQobGF5ZXJzKTtcbiAgICAgIGxheWVycy5mb3JFYWNoKGwgPT4ge1xuICAgICAgICBpZiAobCBpbnN0YW5jZW9mIG9sTGF5ZXJHcm91cCkge1xuICAgICAgICAgIGdyb3VwcyA9IGdyb3Vwcy5jb25jYXQodGhpcy5nZXRMYXllcnNGcm9tR3JvdXAobCwgZmlsdGVydHlwZSwgdHJ1ZSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRlbXBMYXllcnMgPSBncm91cHM7XG4gICAgfVxuXG4gICAgaWYgKGZpbHRlcnR5cGUpIHtcbiAgICAgIHJldHVybiB0ZW1wTGF5ZXJzLmZpbHRlcihsID0+IGwuZ2V0KEZJTFRFUl9UWVBFX0tFWSkgJiYgbC5nZXQoRklMVEVSX1RZUEVfS0VZKS50b0xvd2VyQ2FzZSgpID09PSBmaWx0ZXJ0eXBlLnRvTG93ZXJDYXNlKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGVtcExheWVycztcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0TGF5ZXJCeUtleShrZXk6IHsga2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgfSwgZmlsdGVydHlwZT86IFRncm91cGZpbHRlcnR5cGUpIHtcbiAgICBjb25zdCBsYXllcnMgPSB0aGlzLmdldExheWVyc0Zyb21Hcm91cCh0aGlzLm1hcC5nZXRMYXllckdyb3VwKCksIGZpbHRlcnR5cGUpO1xuICAgIGNvbnN0IGZsYXR0ZW5lZExheWVycyA9IGZsYXR0ZW5MYXllcnMobGF5ZXJzKTtcbiAgICBjb25zdCBrZXlMYXllcnM6IG9sQmFzZUxheWVyW10gPSBbXTtcbiAgICBmbGF0dGVuZWRMYXllcnMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgaWYgKGl0ZW0uZ2V0KGtleS5rZXkpICYmIGl0ZW0uZ2V0KGtleS5rZXkpID09PSBrZXkudmFsdWUpIHtcbiAgICAgICAgaWYgKGtleUxheWVycy5pbmRleE9mKGl0ZW0pID09PSAtMSkge1xuICAgICAgICAgIGtleUxheWVycy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFrZXlMYXllcnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBzdWJMYXllcnMgPSB0aGlzLmdldExheWVyc0Zyb21Hcm91cCh0aGlzLm1hcC5nZXRMYXllckdyb3VwKCksIGZpbHRlcnR5cGUsIHRydWUpOyAvLyAobWFwLmdldExheWVyR3JvdXAoKSwgZmlsdGVydHlwZSwgZmlsdGVydHlwZUtleSwgdHJ1ZSk7XG4gICAgICBpZiAoc3ViTGF5ZXJzLmxlbmd0aCkge1xuICAgICAgICBzdWJMYXllcnMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgIGlmIChpdGVtLmdldChrZXkua2V5KSAmJiBpdGVtLmdldChrZXkua2V5KSA9PT0ga2V5LnZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoa2V5TGF5ZXJzLmluZGV4T2YoaXRlbSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgIGtleUxheWVycy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdGhlcmUgY291bGQgbWF5YmUgbW9yZSB0aGUgb25lIGxheWVycyB3aXRoIHRoZSBzYW1lIGtleSEhISFcbiAgICBpZiAoa2V5TGF5ZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGtleUxheWVyc1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogc2V0IGEgRmlsdGVyVHlwZSB0byBhIExheWVyIG9yIEdyb3VwIHJlY3Vyc2l2ZWx5XG4gICAqXG4gICAqIEBwYXJhbSBrZXkgW2tleT0nZmlsdGVydHlwZSddXG4gICAqL1xuICBwcml2YXRlIHNldFJlY3Vyc2l2ZUtleShsYXllcjogb2xCYXNlTGF5ZXIsIHZhbHVlOiBzdHJpbmcsIGtleSA9IEZJTFRFUl9UWVBFX0tFWSkge1xuICAgIGxheWVyLnNldChrZXksIHZhbHVlKTtcbiAgICBpZiAobGF5ZXIgaW5zdGFuY2VvZiBvbExheWVyR3JvdXApIHtcbiAgICAgIGxheWVyLmdldExheWVycygpLmZvckVhY2gobCA9PiB7XG4gICAgICAgIHRoaXMuc2V0UmVjdXJzaXZlS2V5KGwsIHZhbHVlLCBrZXkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGFkZCBhIG9sTGF5ZXIgdG8gYSBncm91cCBpZiBpdCBpcyBub3QgdGhlcmVcbiAgICovXG4gIHB1YmxpYyBhZGRMYXllcihsYXllcjogb2xCYXNlTGF5ZXIsIGZpbHRlcnR5cGU6IFRncm91cGZpbHRlcnR5cGUpIHtcbiAgICBjb25zdCBsb3dlclR5cGUgPSBmaWx0ZXJ0eXBlLnRvTG93ZXJDYXNlKCkgYXMgVGdyb3VwZmlsdGVydHlwZTtcbiAgICBsZXQgbGF5ZXJzO1xuICAgIHRoaXMubWFwLmdldExheWVycygpLmdldEFycmF5KCkuZm9yRWFjaCgobGF5ZXJHcm91cDogb2xMYXllckdyb3VwKSA9PiB7XG4gICAgICBpZiAobGF5ZXJHcm91cC5nZXQoRklMVEVSX1RZUEVfS0VZKSA9PT0gbG93ZXJUeXBlKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0xheWVySW5Hcm91cChsYXllciwgbGF5ZXJHcm91cCkpIHtcbiAgICAgICAgICBsYXllcnMgPSBsYXllckdyb3VwLmdldExheWVycygpLmdldEFycmF5KCk7XG4gICAgICAgICAgdGhpcy5zZXRSZWN1cnNpdmVLZXkobGF5ZXIsIGxvd2VyVHlwZSwgRklMVEVSX1RZUEVfS0VZKTtcbiAgICAgICAgICBsYXllcnMucHVzaChsYXllcik7XG4gICAgICAgICAgbGF5ZXJHcm91cC5zZXRMYXllcnMobmV3IG9sQ29sbGVjdGlvbihsYXllcnMpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBsYXllcnM7XG4gIH1cblxuICBwcml2YXRlIGlzTGF5ZXJJbkdyb3VwKGxheWVyOiBvbEJhc2VMYXllciwgbGF5ZXJHcm91cDogb2xMYXllckdyb3VwKSB7XG4gICAgY29uc3QgbGF5ZXJzID0gbGF5ZXJHcm91cC5nZXRMYXllcnMoKS5nZXRBcnJheSgpO1xuICAgIGNvbnN0IGhhc2VMYXllciA9IGxheWVycy5maWx0ZXIobCA9PiBsLmdldCgnaWQnKSA9PT0gbGF5ZXIuZ2V0KCdpZCcpKTtcbiAgICBpZiAoaGFzZUxheWVyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgICogR2V0IGFsbCBkaXJla3QgTGF5ZXIgR3JvdXBzIGFkZGVkIHRvIHRoZSBtYXBcbiAgICAqXG4gICAgKiBAcGFyYW0gZmlsdGVydHlwZUtleSBbZmlsdGVydHlwZUtleT0nZmlsdGVydHlwZSddXG4gICAgKi9cbiAgcHJpdmF0ZSBnZXRMYXllckdyb3VwcyhmaWx0ZXJ0eXBlPzogc3RyaW5nKSB7XG4gICAgY29uc3QgbGF5ZXJHcm91cHM6IG9sTGF5ZXJHcm91cFtdID0gW107XG4gICAgdGhpcy5tYXAuZ2V0TGF5ZXJzKCkuZm9yRWFjaCgobGc6IG9sTGF5ZXJHcm91cCB8IG9sQmFzZUxheWVyKSA9PiB7XG4gICAgICBpZiAobGcgaW5zdGFuY2VvZiBvbExheWVyR3JvdXApIHtcbiAgICAgICAgaWYgKGZpbHRlcnR5cGUpIHtcbiAgICAgICAgICBpZiAobGcuZ2V0KEZJTFRFUl9UWVBFX0tFWSkgJiYgbGcuZ2V0KEZJTFRFUl9UWVBFX0tFWSkudG9Mb3dlckNhc2UoKSA9PT0gZmlsdGVydHlwZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBsYXllckdyb3Vwcy5wdXNoKGxnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGF5ZXJHcm91cHMucHVzaChsZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbGF5ZXJHcm91cHM7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBhZGQgYSBhcnJheSBvZiBvbExheWVycyB0byBhIGdyb3VwIGlmIHRoZXkgYXJlIG5vdCB0aGVyZVxuICAgKi9cbiAgcHVibGljIGFkZExheWVycyhsYXllcnM6IG9sQmFzZUxheWVyW10sIGZpbHRlcnR5cGU6IFRncm91cGZpbHRlcnR5cGUpIHtcbiAgICBjb25zdCBsb3dlclR5cGUgPSBmaWx0ZXJ0eXBlLnRvTG9jYWxlTG93ZXJDYXNlKCkgYXMgVGdyb3VwZmlsdGVydHlwZTtcbiAgICBsZXQgbmV3TGF5ZXJzOiBvbEJhc2VMYXllcltdO1xuICAgIGNvbnN0IGxheWVyR3JvdXBzID0gdGhpcy5nZXRMYXllckdyb3Vwcyhsb3dlclR5cGUpO1xuICAgIGxheWVyR3JvdXBzLmZvckVhY2gobGcgPT4ge1xuICAgICAgY29uc3QgZ3JvdXBMYXllcnMgPSBsZy5nZXRMYXllcnMoKTtcbiAgICAgIGlmIChncm91cExheWVycy5nZXRMZW5ndGgoKSA+IDApIHtcbiAgICAgICAgLy8gSSB0aGluayBkb2luZyBpdCBsaWtlIHRoaXMgc2hvdWxkIGJlIG1vcmUgcGVyZm9ybWFudCBsaWtlIGFzIHVzaW5nIHRoZSBhZGRMYXllciBpbiBhIGxvb3BcbiAgICAgICAgbmV3TGF5ZXJzID0gbGcuZ2V0TGF5ZXJzKCkuZ2V0QXJyYXkoKTtcbiAgICAgICAgbGF5ZXJzLm1hcChsYXllciA9PiB7XG4gICAgICAgICAgaWYgKCF0aGlzLmlzTGF5ZXJJbkdyb3VwKGxheWVyLCBsZykpIHtcbiAgICAgICAgICAgIG5ld0xheWVycy5wdXNoKGxheWVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3TGF5ZXJzID0gbGF5ZXJzO1xuICAgICAgfVxuICAgICAgbmV3TGF5ZXJzLmZvckVhY2gobCA9PiB7XG4gICAgICAgIGlmIChsIGluc3RhbmNlb2Ygb2xMYXllckdyb3VwKSB7XG4gICAgICAgICAgdGhpcy5zZXRSZWN1cnNpdmVLZXkobCwgbG93ZXJUeXBlLCBGSUxURVJfVFlQRV9LRVkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGxnLnNldExheWVycyhuZXcgb2xDb2xsZWN0aW9uKG5ld0xheWVycykpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXdMYXllcnM7XG4gIH1cblxuICAvKipcbiAgICogcmVzZXQgYSBncm91cCB3aXRoIGFuIGFycmF5IG9mIG9sTGF5ZXJzXG4gICAqL1xuICBwdWJsaWMgc2V0TGF5ZXJzKGxheWVyczogb2xCYXNlTGF5ZXJbXSwgZmlsdGVydHlwZTogVGdyb3VwZmlsdGVydHlwZSkge1xuICAgIGNvbnN0IGxvd2VyVHlwZSA9IGZpbHRlcnR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKSBhcyBUZ3JvdXBmaWx0ZXJ0eXBlO1xuICAgIGNvbnN0IGxheWVyR3JvdXBzID0gdGhpcy5nZXRMYXllckdyb3Vwcyhsb3dlclR5cGUpO1xuICAgIGxheWVycy5mb3JFYWNoKGwgPT4ge1xuICAgICAgaWYgKGwgaW5zdGFuY2VvZiBvbExheWVyR3JvdXApIHtcbiAgICAgICAgdGhpcy5zZXRSZWN1cnNpdmVLZXkobCwgZmlsdGVydHlwZS50b0xvY2FsZUxvd2VyQ2FzZSgpLCBGSUxURVJfVFlQRV9LRVkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxheWVyR3JvdXBzLmZvckVhY2gobCA9PiB7XG4gICAgICB0aGlzLmNsZWFuVXBFdmVudExpc3RlbmVycyhsLCBsYXllcnMpO1xuICAgICAgbC5zZXRMYXllcnMobmV3IG9sQ29sbGVjdGlvbihsYXllcnMpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbGF5ZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFuIHVwIGV2ZW50IGxpc3RlbmVycyBmcm9tIGxheWVycyBhbmQgc291cmNlc1xuICAgKlxuICAgKiBUT0RPOiBpcyB0aGlzIG5lZWRlZD8gd2hlbiBsYXllcnMgb3Igc291cmNlcyBhcmUgcmVtb3ZlZCwgdGhlbiB0aGVyZSBpcyBubyBUYXJnZXQgYW55bW9yZSB3aGljaCBsaXN0ZW5zIGZvciBldmVudHM/XG4gICAqIHRoZXJlIGFyZSBhbHNvIG90aGVyIGZ1bmN0aW9ucyBsaWtlIHJlbW92ZUxheWVyQnlLZXkoKSwgcmVtb3ZlQWxsTGF5ZXJzKClcbiAgICovXG4gIHByaXZhdGUgY2xlYW5VcEV2ZW50TGlzdGVuZXJzKGxheWVyR3JvdXA6IG9sTGF5ZXJHcm91cCwgbmV3TGF5ZXJzOiBvbEJhc2VMYXllcltdKSB7XG4gICAgLyoqIGdldCBEaWZmZXJlbmNlIG9mIG9sZCBsYXllcnMgYW5kIG5ldyBsYXllcnMgKi9cbiAgICBjb25zdCBsYXllcnNUb1JlbW92ZSA9IGxheWVyR3JvdXAuZ2V0TGF5ZXJzKCkuZ2V0QXJyYXkoKS5maWx0ZXIoeCA9PiAhbmV3TGF5ZXJzLm1hcChsID0+IGwuZ2V0KCdpZCcpKS5pbmNsdWRlcyh4LmdldCgnaWQnKSkpO1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzRnJvbU9sZExheWVycyhsYXllcnNUb1JlbW92ZSk7XG5cbiAgICAvLyBUT0RPOiBpcyB0aGlzIGRvbmUgYnkgc2V0TGF5ZXJzPz9cbiAgICBsYXllcnNUb1JlbW92ZS5mb3JFYWNoKGwgPT4gbGF5ZXJHcm91cC5nZXRMYXllcnMoKS5yZW1vdmUobCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIG9uKCkgYW5kIHVuKCkgYXJlIGZ1bmN0aW9ucyBvZiBvbE9ic2VydmFibGUgd2hpY2ggZXh0ZW5kcyBFdmVudFRhcmdldFxuICAgKlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vb3BlbmxheWVycy9vcGVubGF5ZXJzL2Jsb2IvdjYuNS4wL3NyYy9vbC9ldmVudHMvVGFyZ2V0LmpzI0wxNDVcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL29wZW5sYXllcnMvb3BlbmxheWVycy9ibG9iL3Y2LjUuMC9zcmMvb2wvZXZlbnRzL1RhcmdldC5qcyNMMTM0XG4gICAqL1xuICBwcml2YXRlIGFkZEV2ZW50c1RvTGF5ZXIodWtpc0xheWVyOiBMYXllciwgb2xMYXllcjogb2xMYXllcjxhbnk+LCBvbFNvdXJjZTogb2xTb3VyY2UpIHtcbiAgICBpZiAodWtpc0xheWVyLmV2ZW50cykge1xuICAgICAgaWYgKHVraXNMYXllci5ldmVudHMubGF5ZXIpIHtcbiAgICAgICAgdWtpc0xheWVyLmV2ZW50cy5sYXllci5mb3JFYWNoKGUgPT4ge1xuICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IG9sTGF5ZXIuZ2V0TGlzdGVuZXJzKGUuZXZlbnQpO1xuICAgICAgICAgIC8qKiBvbmx5IGFkZCBsaXN0ZW5lciBpZiBpdCB3YXMgbm90IHJlZ2lzdGVyZWQgb24gdGhlIG9sTGF5ZXIgb2JqZWN0IChmb3IgQ3VzdG9tTGF5ZXIpICovXG4gICAgICAgICAgaWYgKCFsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIC8qKiBUT0RPOiBjaGVjayBUeXBlcyBvbiB0aGUgbmV4dCBvbCB1cGRhdGUgLSB3ZSBvbmx5IGRlZmluZSBhIHN0cmluZyBzbyB0aGUgdXNlciBoYXMgdG8gY2hlY2sgaWYgdGhlIHJpZ2h0IGV2ZW50IGlzIHVzZWQgKi9cbiAgICAgICAgICAgIG9sTGF5ZXIub24oZS5ldmVudCBhcyBhbnksIGUubGlzdGVuZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh1a2lzTGF5ZXIuZXZlbnRzLnNvdXJjZSkge1xuICAgICAgICB1a2lzTGF5ZXIuZXZlbnRzLnNvdXJjZS5mb3JFYWNoKGUgPT4ge1xuICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IG9sU291cmNlLmdldExpc3RlbmVycyhlLmV2ZW50KTtcbiAgICAgICAgICAvKiogb25seSBhZGQgbGlzdGVuZXIgaWYgaXQgd2FzIG5vdCByZWdpc3RlcmVkIG9uIHRoZSBvbFNvdXJjZSBvYmplY3QgKGZvciBDdXN0b21MYXllcikgKi9cbiAgICAgICAgICBpZiAoIWxpc3RlbmVycykge1xuICAgICAgICAgICAgLyoqIFRPRE86IGNoZWNrIFR5cGVzIG9uIHRoZSBuZXh0IG9sIHVwZGF0ZSAtIHdlIG9ubHkgZGVmaW5lIGEgc3RyaW5nIHNvIHRoZSB1c2VyIGhhcyB0byBjaGVjayBpZiB0aGUgcmlnaHQgZXZlbnQgaXMgdXNlZCAqL1xuICAgICAgICAgICAgb2xTb3VyY2Uub24oZS5ldmVudCBhcyBhbnksIGUubGlzdGVuZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqIFRPRE86IHRyeSB0byByZW1vdmUvcmVwbGFjZSB0aGlzIGZ1bmN0aW9uIC0gUHJvcGVydHkgJ2Rpc3Bvc2VJbnRlcm5hbCcgaXMgcHJvdGVjdGVkIG9sIGZ1bmN0aW9uICovXG4gIHByaXZhdGUgcmVtb3ZlTGlzdGVuZXJzRnJvbU9sZExheWVycyhsYXllcnM6IEFycmF5PG9sQmFzZUxheWVyIHwgb2xMYXllckdyb3VwPikge1xuICAgIGNvbnN0IGRpc3Bvc2VMYXllckludGVybmFsID0gKGxheWVyOiBvbEJhc2VMYXllcikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiAobGF5ZXIgYXMgYW55KS5nZXRTb3VyY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3Qgc291cmNlID0gKGxheWVyIGFzIGFueSkuZ2V0U291cmNlKCkgYXMgb2xTb3VyY2U7XG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZGxyLWVvYy91a2lzLWZyb250ZW5kLWxpYnJhcmllcy9pc3N1ZXMvMTAwXG4gICAgICAgICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIG9sUmFzdGVyU291cmNlKSB7XG4gICAgICAgICAgICBzb3VyY2UuZGlzcG9zZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc291cmNlLmhhc0xpc3RlbmVyKCkpIHtcbiAgICAgICAgICAgIChzb3VyY2UgYXMgYW55KS5kaXNwb3NlSW50ZXJuYWwoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsYXllci5oYXNMaXN0ZW5lcigpKSB7XG4gICAgICAgIChsYXllciBhcyBhbnkpLmRpc3Bvc2VJbnRlcm5hbCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBsYXllcnMuZm9yRWFjaChsID0+IHtcbiAgICAgIGlmIChsIGluc3RhbmNlb2Ygb2xMYXllckdyb3VwKSB7XG4gICAgICAgIGwuZ2V0TGF5ZXJzKCkuZm9yRWFjaChzdWJMID0+IHtcbiAgICAgICAgICBkaXNwb3NlTGF5ZXJJbnRlcm5hbChzdWJMKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGwgaW5zdGFuY2VvZiBvbEJhc2VMYXllcikge1xuICAgICAgICBkaXNwb3NlTGF5ZXJJbnRlcm5hbChsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgY29ycmVzcG9uZGluZyBMYXllciBHcm91cCBvbiB3aGljaCB0aGUgbGF5ZXIgaXMgYWRkZWRcbiAgICovXG4gIHByaXZhdGUgZ2V0TGF5ZXJHcm91cEZvckxheWVyKGxheWVyOiBvbEJhc2VMYXllcikge1xuICAgIGNvbnN0IHN1YkxheWVycyA9IHRoaXMuZ2V0TGF5ZXJzRnJvbUdyb3VwKHRoaXMubWFwLmdldExheWVyR3JvdXAoKSwgbnVsbCwgdHJ1ZSk7XG4gICAgc3ViTGF5ZXJzLnB1c2godGhpcy5tYXAuZ2V0TGF5ZXJHcm91cCgpKTtcbiAgICBsZXQgbHllckdyb3VwOiB7IGdyb3VwOiBvbExheWVyR3JvdXAsIGxheWVyOiBvbEJhc2VMYXllciB9IHwgbnVsbCA9IG51bGw7XG4gICAgc3ViTGF5ZXJzLmZvckVhY2goKGwpID0+IHtcbiAgICAgIGlmIChsIGluc3RhbmNlb2Ygb2xMYXllckdyb3VwKSB7XG4gICAgICAgIGNvbnN0IGdyb3VwTGF5ZXJzID0gdGhpcy5nZXRMYXllcnNGcm9tR3JvdXAobCk7XG4gICAgICAgIGNvbnN0IGhhc0xheWVyID0gZ3JvdXBMYXllcnMuZmluZChpID0+IGkgPT09IGxheWVyKTtcbiAgICAgICAgaWYgKGhhc0xheWVyKSB7XG4gICAgICAgICAgbHllckdyb3VwID0ge1xuICAgICAgICAgICAgZ3JvdXA6IGwsXG4gICAgICAgICAgICBsYXllcjogaGFzTGF5ZXJcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGx5ZXJHcm91cDtcbiAgfVxuXG5cbiAgcHVibGljIHJlbW92ZUxheWVyQnlLZXkoa2V5OiB7IGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nIH0sIGZpbHRlcnR5cGU6IFRncm91cGZpbHRlcnR5cGUpIHtcbiAgICBjb25zdCBsb3dlclR5cGUgPSBmaWx0ZXJ0eXBlLnRvTG9jYWxlTG93ZXJDYXNlKCkgYXMgVGdyb3VwZmlsdGVydHlwZTtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuZ2V0TGF5ZXJCeUtleShrZXksIGxvd2VyVHlwZSk7XG4gICAgaWYgKGxheWVyKSB7XG4gICAgICBjb25zdCBncm9wT2JqID0gdGhpcy5nZXRMYXllckdyb3VwRm9yTGF5ZXIobGF5ZXIpO1xuICAgICAgaWYgKGdyb3BPYmouZ3JvdXApIHtcbiAgICAgICAgY29uc3QgZmlsdGVyZExheWVycyA9IHRoaXMuZ2V0TGF5ZXJzRnJvbUdyb3VwKGdyb3BPYmouZ3JvdXApLmZpbHRlcihpID0+IGkgIT09IGxheWVyKTtcbiAgICAgICAgZ3JvcE9iai5ncm91cC5zZXRMYXllcnMobmV3IG9sQ29sbGVjdGlvbihmaWx0ZXJkTGF5ZXJzKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHVwZGF0ZUxheWVyQnlLZXkoa2V5OiB7IGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nIH0sIG5ld0xheWVyOiBvbEJhc2VMYXllciwgZmlsdGVydHlwZTogVGdyb3VwZmlsdGVydHlwZSkge1xuICAgIGNvbnN0IGxvd2VyVHlwZSA9IGZpbHRlcnR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKSBhcyBUZ3JvdXBmaWx0ZXJ0eXBlO1xuICAgIHRoaXMubWFwLmdldExheWVycygpLmZvckVhY2goKGxheWVyR3JvdXA6IG9sTGF5ZXJHcm91cCkgPT4ge1xuICAgICAgaWYgKGxheWVyR3JvdXAuZ2V0KEZJTFRFUl9UWVBFX0tFWSkgPT09IGxvd2VyVHlwZSkge1xuICAgICAgICBjb25zdCBncm91cExheWVycyA9IGxheWVyR3JvdXAuZ2V0TGF5ZXJzKCk7XG4gICAgICAgIGdyb3VwTGF5ZXJzLmZvckVhY2goKG9sZExheWVyLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGlmIChvbGRMYXllci5nZXQoa2V5LmtleSkgJiYgb2xkTGF5ZXIuZ2V0KGtleS5rZXkpID09PSBrZXkudmFsdWUpIHtcblxuICAgICAgICAgICAgY29uc3QgbmV3UHJvcGVydGllcyA9IG5ld0xheWVyLmdldFByb3BlcnRpZXMoKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0V4dGVudCA9IG5ld0xheWVyLmdldEV4dGVudCgpO1xuXG4gICAgICAgICAgICBjb25zdCBuZXdNYXhab29tID0gbmV3TGF5ZXIuZ2V0TWF4Wm9vbSgpO1xuICAgICAgICAgICAgY29uc3QgbmV3TWluWm9vbSA9IG5ld0xheWVyLmdldE1pblpvb20oKTtcblxuICAgICAgICAgICAgY29uc3QgbmV3T3BhY2l0eSA9IG5ld0xheWVyLmdldE9wYWNpdHkoKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1Zpc2libGUgPSBuZXdMYXllci5nZXRWaXNpYmxlKCk7XG5cbiAgICAgICAgICAgIGNvbnN0IG5ld1pJbmRleCA9IG5ld0xheWVyLmdldFpJbmRleCgpO1xuXG4gICAgICAgICAgICBpZiAob2xkTGF5ZXIgaW5zdGFuY2VvZiBvbExheWVyICYmIG5ld0xheWVyIGluc3RhbmNlb2Ygb2xMYXllcikge1xuICAgICAgICAgICAgICBjb25zdCBuZXdTb3VyY2UgPSBuZXdMYXllci5nZXRTb3VyY2UoKTtcbiAgICAgICAgICAgICAgb2xkTGF5ZXIuc2V0U291cmNlKG5ld1NvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3UHJvcGVydGllcykge1xuICAgICAgICAgICAgICBvbGRMYXllci5zZXRQcm9wZXJ0aWVzKG5ld1Byb3BlcnRpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld0V4dGVudCkge1xuICAgICAgICAgICAgICBvbGRMYXllci5zZXRFeHRlbnQobmV3RXh0ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdNYXhab29tKSB7XG4gICAgICAgICAgICAgIG9sZExheWVyLnNldE1heFpvb20obmV3TWF4Wm9vbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3TWluWm9vbSkge1xuICAgICAgICAgICAgICBvbGRMYXllci5zZXRNaW5ab29tKG5ld01pblpvb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld09wYWNpdHkpIHtcbiAgICAgICAgICAgICAgb2xkTGF5ZXIuc2V0T3BhY2l0eShuZXdPcGFjaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdWaXNpYmxlKSB7XG4gICAgICAgICAgICAgIG9sZExheWVyLnNldFZpc2libGUobmV3VmlzaWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3WkluZGV4KSB7XG4gICAgICAgICAgICAgIG9sZExheWVyLnNldFpJbmRleChuZXdaSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2xkTGF5ZXIuY2hhbmdlZCgpO1xuICAgICAgICAgICAgZ3JvdXBMYXllcnMuc2V0QXQoaW5kZXgsIG9sZExheWVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsYXllckdyb3VwLnNldExheWVycyhncm91cExheWVycyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgcmVtb3ZlQWxsTGF5ZXJzKGZpbHRlcnR5cGU6IFRncm91cGZpbHRlcnR5cGUpIHtcbiAgICBjb25zdCBsb3dlclR5cGUgPSBmaWx0ZXJ0eXBlLnRvTG93ZXJDYXNlKCkgYXMgVGdyb3VwZmlsdGVydHlwZTtcbiAgICBsZXQgbGF5ZXJzO1xuICAgIHRoaXMubWFwLmdldExheWVycygpLmdldEFycmF5KCkuZm9yRWFjaCgobGF5ZXJHcm91cDogb2xMYXllckdyb3VwKSA9PiB7XG4gICAgICBpZiAobGF5ZXJHcm91cC5nZXQoRklMVEVSX1RZUEVfS0VZKSA9PT0gbG93ZXJUeXBlKSB7XG4gICAgICAgIGxheWVycyA9IGxheWVyR3JvdXAuZ2V0TGF5ZXJzKCk7XG4gICAgICAgIGxheWVycy5jbGVhcigpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gIH1cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiByZXNldHMvYWRkcyBhbGwgb2xMYXllcnMgb2YgYSB0eXBlIHdpdGggdGhlIG5ldyBVS0lTLUxheWVyc1xuICAgKlxuICAgKiBpZiBvbmx5IG9uZSBncm91cCBvZiB0aGVtIG1hcCBpcyB1c2VkIGFuZCBzZXRMYXllcnMgaXMgY2FsbGVkIHRoZW4gdGhlIG1hcCBmbGlja2VycyFcbiAgICogdGhpcyBpcyBiZWNhdXNlIGFsbCBsYXllcnMgYXJlIG5ld2x5IGNyZWF0ZWQgYW5kIGVhY2ggZ2V0IG5ldyBvbF91aWQnc1xuICAgKi9cbiAgcHVibGljIHNldFVraXNMYXllcnMobGF5ZXJzOiBBcnJheTxMYXllcj4sIGZpbHRlcnR5cGU6IFRncm91cGZpbHRlcnR5cGUpIHtcbiAgICBjb25zdCBsb3dlclR5cGUgPSBmaWx0ZXJ0eXBlLnRvTG93ZXJDYXNlKCkgYXMgVGdyb3VwZmlsdGVydHlwZTtcbiAgICBjb25zdCB0ZW1wTGF5ZXJzOiBvbEJhc2VMYXllcltdID0gW107XG4gICAgLy8gVE9ETyB0cnkgdG8gZGVlcCBjaGVjayBpZiBhIGxheWVyIGlmIGV4YWN0bHkgdGhlIHNhbWUgYW5kIGRvbnQgY3JlYXRlIGl0IG5ld1xuICAgIC8vIGNyZWF0ZSBoYXNoIGZyb20gbGF5ZXI/Pz9cblxuICAgIGlmIChsYXllcnMubGVuZ3RoIDwgMSAmJiBsb3dlclR5cGUgIT09ICdiYXNlbGF5ZXJzJykge1xuICAgICAgLy8gdGhpcy5yZW1vdmVBbGxMYXllcnMoJ292ZXJsYXlzJyk7XG4gICAgICAvLyB0aGlzLnJlbW92ZUFsbExheWVycygnbGF5ZXJzJyk7XG4gICAgICB0aGlzLnJlbW92ZUFsbExheWVycyhsb3dlclR5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXllcnMuZm9yRWFjaCgobmV3TGF5ZXIpID0+IHtcbiAgICAgICAgY29uc3QgbGF5ZXIgPSB0aGlzLmNyZWF0ZV9sYXllcnMobmV3TGF5ZXIpO1xuICAgICAgICAvLyBjaGVjayBpZiBsYXllciBub3QgdW5kZWZpbmVkXG4gICAgICAgIGlmIChsYXllcikge1xuICAgICAgICAgIHRlbXBMYXllcnMucHVzaChsYXllcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0ZW1wTGF5ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuc2V0TGF5ZXJzKHRlbXBMYXllcnMsIGxvd2VyVHlwZSk7XG4gICAgICAvLyBUT0RPOiBjaGVja3QgdG8gcmVwbGFjZSB0eXBlIHdpdGggZmlsdGVydHlwZSAtPiBidXQgYnJlYWtpbmcgQ2hhbmdlISFcbiAgICAgIGNvbnN0IG5ld1RlbXBMYXllcjogeyB0eXBlOiBUZ3JvdXBmaWx0ZXJ0eXBlLCBsYXllcnM6IG9sQmFzZUxheWVyW10gfSA9IHtcbiAgICAgICAgdHlwZTogbG93ZXJUeXBlLCBsYXllcnM6IHRlbXBMYXllcnNcbiAgICAgIH07XG4gICAgICByZXR1cm4gbmV3VGVtcExheWVyO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBUaGlzIGZ1bmN0aW9uIHJlc2V0cy9hZGRzIGEgb2xMYXllciBvZiBhIHR5cGUgd2l0aCB0aGUgbmV3IFVLSVMtTGF5ZXIgKi9cbiAgcHVibGljIHNldFVraXNMYXllcihuZXdMYXllcjogTGF5ZXIsIGZpbHRlcnR5cGU/OiBUZ3JvdXBmaWx0ZXJ0eXBlKTogdm9pZCB7XG4gICAgaWYgKCFmaWx0ZXJ0eXBlKSB7XG4gICAgICBmaWx0ZXJ0eXBlID0gbmV3TGF5ZXIuZmlsdGVydHlwZTtcbiAgICB9XG4gICAgY29uc3QgbG93ZXJUeXBlID0gZmlsdGVydHlwZS50b0xvd2VyQ2FzZSgpIGFzIFRncm91cGZpbHRlcnR5cGU7XG4gICAgY29uc3Qgb2xkTGF5ZXJzID0gdGhpcy5nZXRMYXllcnMobG93ZXJUeXBlKTtcbiAgICBjb25zdCBvbGRMYXllciA9IG9sZExheWVycy5maW5kKGwgPT4gbC5nZXQoJ2lkJykgPT09IG5ld0xheWVyLmlkKTtcbiAgICBjb25zdCBuZXdPbExheWVyID0gdGhpcy5jcmVhdGVfbGF5ZXJzKG5ld0xheWVyKTtcbiAgICBpZiAob2xkTGF5ZXIpIHtcbiAgICAgIHRoaXMucmVtb3ZlTGF5ZXJCeUtleSh7IGtleTogSURfS0VZLCB2YWx1ZTogb2xkTGF5ZXIuZ2V0KElEX0tFWSkgfSwgZmlsdGVydHlwZSk7XG4gICAgICB0aGlzLmFkZExheWVyKG5ld09sTGF5ZXIsIGZpbHRlcnR5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZExheWVyKG5ld09sTGF5ZXIsIGZpbHRlcnR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGVVa2lzTGF5ZXIobmV3TGF5ZXI6IExheWVyLCBmaWx0ZXJ0eXBlPzogVGdyb3VwZmlsdGVydHlwZSk6IHZvaWQge1xuICAgIGlmICghZmlsdGVydHlwZSkge1xuICAgICAgZmlsdGVydHlwZSA9IG5ld0xheWVyLmZpbHRlcnR5cGU7XG4gICAgfVxuICAgIGNvbnN0IGxvd2VyVHlwZSA9IGZpbHRlcnR5cGUudG9Mb3dlckNhc2UoKSBhcyBUZ3JvdXBmaWx0ZXJ0eXBlO1xuICAgIGNvbnN0IG9sZExheWVycyA9IHRoaXMuZ2V0TGF5ZXJzKGxvd2VyVHlwZSk7XG4gICAgY29uc3Qgb2xkTGF5ZXIgPSBvbGRMYXllcnMuZmluZChsID0+IGwuZ2V0KCdpZCcpID09PSBuZXdMYXllci5pZCk7XG4gICAgY29uc3QgbmV3T2xMYXllciA9IHRoaXMuY3JlYXRlX2xheWVycyhuZXdMYXllcik7XG4gICAgaWYgKG5ld09sTGF5ZXIpIHtcbiAgICAgIHRoaXMudXBkYXRlTGF5ZXJCeUtleSh7IGtleTogSURfS0VZLCB2YWx1ZTogb2xkTGF5ZXIuZ2V0KElEX0tFWSkgfSwgbmV3T2xMYXllciwgZmlsdGVydHlwZSk7XG4gICAgfVxuICB9XG5cblxuICBwcml2YXRlIGNyZWF0ZV9sYXllcnMobmV3TGF5ZXI6IExheWVyKSB7XG4gICAgbGV0IG5ld09sTGF5ZXI6IG9sVGlsZUxheWVyPG9sVGlsZVNvdXJjZT4gfCBvbFZlY3RvckxheWVyPG9sVmVjdG9yU291cmNlPG9sR2VvbWV0cnk+PiB8IG9sQmFzZUxheWVyO1xuICAgIHN3aXRjaCAobmV3TGF5ZXIudHlwZSkge1xuICAgICAgY2FzZSBYeXpMYXllcnR5cGU6XG4gICAgICAgIG5ld09sTGF5ZXIgPSB0aGlzLmNyZWF0ZV94eXpfbGF5ZXIobmV3TGF5ZXIgYXMgUmFzdGVyTGF5ZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgV21zTGF5ZXJ0eXBlOlxuICAgICAgICBuZXdPbExheWVyID0gdGhpcy5jcmVhdGVfd21zX2xheWVyKG5ld0xheWVyIGFzIFdtc0xheWVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFdtdHNMYXllcnR5cGU6XG4gICAgICAgIG5ld09sTGF5ZXIgPSB0aGlzLmNyZWF0ZV93bXRzX2xheWVyKG5ld0xheWVyIGFzIFdtdHNMYXllcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUbXNMYXllcnR5cGU6XG4gICAgICAgIG5ld09sTGF5ZXIgPSB0aGlzLmNyZWF0ZV90bXNfbGF5ZXIobmV3TGF5ZXIgYXMgVmVjdG9yTGF5ZXIgfCBSYXN0ZXJMYXllcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBHZW9qc29uTGF5ZXJ0eXBlOlxuICAgICAgICBuZXdPbExheWVyID0gdGhpcy5jcmVhdGVfZ2VvanNvbl9sYXllcihuZXdMYXllciBhcyBWZWN0b3JMYXllcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBLbWxMYXllcnR5cGU6XG4gICAgICAgIG5ld09sTGF5ZXIgPSB0aGlzLmNyZWF0ZV9rbWxfbGF5ZXIobmV3TGF5ZXIgYXMgVmVjdG9yTGF5ZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgV2ZzTGF5ZXJ0eXBlOlxuICAgICAgICBuZXdPbExheWVyID0gdGhpcy5jcmVhdGVfd2ZzX2xheWVyKG5ld0xheWVyIGFzIFZlY3RvckxheWVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEN1c3RvbUxheWVydHlwZTpcbiAgICAgICAgbmV3T2xMYXllciA9IHRoaXMuY3JlYXRlX2N1c3RvbV9sYXllcihuZXdMYXllciBhcyBDdXN0b21MYXllcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdGFja2VkTGF5ZXJ0eXBlOlxuICAgICAgICBuZXdPbExheWVyID0gdGhpcy5jcmVhdGVfc3RhY2tlZF9sYXllcihuZXdMYXllciBhcyBTdGFja2VkTGF5ZXIpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG5ld09sTGF5ZXI7XG4gIH1cblxuICAvKipcbiAgICogY3JlYXRlIGxheWVyb3B0aW9ucyBvbExheWVyT3B0aW9uczxPcHRpb25Tb3VyY2VzPiAmIElMYXllck9wdGlvbnNcbiAgICogLSBpZFxuICAgKiAtIG5hbWVcbiAgICogLSBmaWx0ZXJ0eXBlXG4gICAqIC0gdHlwZVxuICAgKiAtIGxlZ2VuZEltZ1xuICAgKiAtIHZpc2libGVcbiAgICogLSB6SW5kZXhcbiAgICogLSBvcGFjaXR5XG4gICAqIC0gYXR0cmlidXRpb25cbiAgICogLSBjb250aW51b3VzV29ybGRcbiAgICogLSBzZXQgY3Jvc3NPcmlnaW4gZm9yIHBvcHVwIGxheWVyc1xuICAgKiAtIHNldCBzb3VyY2Ugb24gbGF5ZXJvcHRpb25zXG4gICAqIC0gcG9wdXBcbiAgICogLSBtYXhSZXNvbHV0aW9uL21pblJlc29sdXRpb25cbiAgICogLSBtYXhab29tL21pblpvb21cbiAgICogLSBiYm94XG4gICAqL1xuICBwcml2YXRlIGNyZWF0ZU9sTGF5ZXJPcHRpb25zKGw6IExheWVyLCB0eXBlOiBMYXllclsndHlwZSddLCBzb3VyY2U/OiBvbFNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UpIHtcbiAgICAgIGlmIChsLmF0dHJpYnV0aW9uKSB7XG4gICAgICAgIHNvdXJjZS5zZXRBdHRyaWJ1dGlvbnMoW2wuYXR0cmlidXRpb25dKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGwuY29udGludW91c1dvcmxkKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzZXQgd3JhcFggYWZ0ZXIgc291cmNlIGNyZWF0aW9uIGlzIG5vdCBwb3NzaWJsZSBzbyB3ZSBoYXZlIHRvIHVzZSB0aGUgcHJpdmF0ZSBwcm9wZXJ0eVxuICAgICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vb3BlbmxheWVycy9vcGVubGF5ZXJzL2Jsb2IvdjYuMTMuMC9zcmMvb2wvc291cmNlL1NvdXJjZS5qcyNMNDhcbiAgICAgICAgICovXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tc3RyaW5nLWxpdGVyYWxcbiAgICAgICAgc291cmNlWyd3cmFwWF8nXSA9IGwuY29udGludW91c1dvcmxkO1xuICAgICAgfVxuXG4gICAgICAvKiogc2V0IGNyb3NzT3JpZ2luIGZvciBwb3B1cCBsYXllcnMgICovXG4gICAgICBpZiAobC5wb3B1cCAmJiAhbC5jcm9zc09yaWdpbiAmJiBsLmNyb3NzT3JpZ2luICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuc291cmNlU2V0Q3Jvc3Moc291cmNlKTtcbiAgICAgIH1cbiAgICAgIGlmIChsLmNyb3NzT3JpZ2luIHx8IGwuY3Jvc3NPcmlnaW4gPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5zb3VyY2VTZXRDcm9zcyhzb3VyY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGNvbnN0IGxheWVyb3B0aW9uczogb2xMYXllck9wdGlvbnM8TGF5ZXJPcHRpb25zU291cmNlcz4gJiBJTGF5ZXJPcHRpb25zID0ge1xuICAgICAgLy8gY2xhc3NOYW1lIC0gaWZcbiAgICAgIG9wYWNpdHk6IGwub3BhY2l0eSB8fCAxLFxuICAgICAgdmlzaWJsZTogbC52aXNpYmxlLFxuICAgICAgLy8gZXh0ZW50IC0gaWZcbiAgICAgIHpJbmRleDogMSxcbiAgICAgIC8vIG1pblJlc29sdXRpb24gLSBpZlxuICAgICAgLy8gbWF4UmVzb2x1dGlvbiAtIGlmXG4gICAgICAvLyBtaW5ab29tIC0gaWZcbiAgICAgIC8vIG1heFpvb20gLSBpZlxuICAgICAgLy8gc291cmNlIC0gaWZcbiAgICAgIC8vIG1hcCAtIG5vdCBzZXRcbiAgICAgIC8vIHJlbmRlciAtIG5vdCBzZXRcbiAgICAgIC8vIHByb3BlcnRpZXMgLSBub3Qgc2V0XG4gICAgICBpZDogbC5pZCxcbiAgICAgIG5hbWU6IGwubmFtZSxcbiAgICAgIGZpbHRlcnR5cGU6IGwuZmlsdGVydHlwZSxcbiAgICAgIHR5cGUsXG4gICAgICBsZWdlbmRJbWc6IGwubGVnZW5kSW1nXG4gICAgfTtcblxuICAgIGlmIChzb3VyY2UpIHtcbiAgICAgIGxheWVyb3B0aW9ucy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuXG4gICAgaWYgKGwucG9wdXApIHtcbiAgICAgIGxheWVyb3B0aW9ucy5wb3B1cCA9IGwucG9wdXA7XG4gICAgICAvKipcbiAgICAgICAqIG9sIDYueCBwcm9ibGVtIGlmIHBvcHVwIChtYXAuZm9yRWFjaExheWVyQXRQaXhlbCkgdXNlIGNsYXNzTmFtZVxuICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL29wZW5sYXllcnMvb3BlbmxheWVycy9yZWxlYXNlcy90YWcvdjYuMC4wXG4gICAgICAgKi9cbiAgICAgIGxheWVyb3B0aW9ucy5jbGFzc05hbWUgPSBsLmlkO1xuICAgIH1cblxuICAgIGlmIChsLm1heFJlc29sdXRpb24pIHtcbiAgICAgIGxheWVyb3B0aW9ucy5tYXhSZXNvbHV0aW9uID0gbC5tYXhSZXNvbHV0aW9uO1xuICAgIH1cbiAgICBpZiAobC5taW5SZXNvbHV0aW9uKSB7XG4gICAgICBsYXllcm9wdGlvbnMubWluUmVzb2x1dGlvbiA9IGwubWluUmVzb2x1dGlvbjtcbiAgICB9XG5cbiAgICBpZiAobC5tYXhab29tKSB7XG4gICAgICBsYXllcm9wdGlvbnMubWF4Wm9vbSA9IGwubWF4Wm9vbTtcbiAgICB9XG4gICAgaWYgKGwubWluWm9vbSkge1xuICAgICAgbGF5ZXJvcHRpb25zLm1pblpvb20gPSBsLm1pblpvb207XG4gICAgfVxuXG4gICAgaWYgKGwuYmJveCkge1xuICAgICAgbGF5ZXJvcHRpb25zLmV4dGVudCA9IHRyYW5zZm9ybUV4dGVudChsLmJib3guc2xpY2UoMCwgNCkgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIFdHUzg0LCB0aGlzLmdldFByb2plY3Rpb24oKS5nZXRDb2RlKCkpO1xuICAgIH1cblxuICAgIHJldHVybiBsYXllcm9wdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogZGVmaW5lIGxheWVyIHR5cGVzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBodHRwczovL29wZW5sYXllcnMub3JnL2VuL2xhdGVzdC9hcGlkb2MvbW9kdWxlLW9sX2xheWVyX1RpbGUtVGlsZUxheWVyLmh0bWxcbiAgICogaHR0cHM6Ly9vcGVubGF5ZXJzLm9yZy9lbi9sYXRlc3QvYXBpZG9jL21vZHVsZS1vbF9zb3VyY2VfWFlaLVhZWi5odG1sXG4gICAqL1xuICBwcml2YXRlIGNyZWF0ZV94eXpfbGF5ZXIobDogUmFzdGVyTGF5ZXIpOiBvbFRpbGVMYXllcjxvbFRpbGVTb3VyY2U+IHtcbiAgICBjb25zdCB4eXpPcHRpb25zOiBvbFhZWk9wdGlvbnMgPSB7XG4gICAgICB3cmFwWDogZmFsc2VcbiAgICB9O1xuXG4gICAgaWYgKGwuY3Jvc3NPcmlnaW4pIHtcbiAgICAgIHh5ek9wdGlvbnMuY3Jvc3NPcmlnaW4gPSBsLmNyb3NzT3JpZ2luO1xuICAgIH1cblxuICAgIGNvbnN0IG9sc291cmNlID0gbmV3IG9sWFlaKHh5ek9wdGlvbnMpO1xuXG4gICAgY29uc3QgbGF5ZXJvcHRpb25zID0gdGhpcy5jcmVhdGVPbExheWVyT3B0aW9ucyhsLCAneHl6Jywgb2xzb3VyY2UpO1xuXG4gICAgY29uc3QgYmFzZVRpbGVMYXllck9wdGlvbnM6IG9sQmFzZVRpbGVMYXllck9wdGlvbnM8b2xUaWxlU291cmNlPiA9IHtcbiAgICAgIHByZWxvYWQ6IDAsXG4gICAgICB1c2VJbnRlcmltVGlsZXNPbkVycm9yOiB0cnVlXG4gICAgfTtcbiAgICBjb25zdCBuZXdsYXllciA9IG5ldyBvbFRpbGVMYXllcihPYmplY3QuYXNzaWduKGxheWVyb3B0aW9ucywgYmFzZVRpbGVMYXllck9wdGlvbnMpKTtcbiAgICB0aGlzLnNldFN1YmRvbWFpbnMobCwgbmV3bGF5ZXIpO1xuICAgIHRoaXMuc2V0Q3Jvc3NPcmlnaW4obCwgbmV3bGF5ZXIpO1xuICAgIHRoaXMuYWRkRXZlbnRzVG9MYXllcihsLCBuZXdsYXllciwgb2xzb3VyY2UpO1xuICAgIHJldHVybiBuZXdsYXllcjtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIGNyZWF0ZV94eXpfbGF5ZXIgZm9yIFJhc3RlclxuICAgKlxuICAgKiBvclxuICAgKlxuICAgKiBodHRwczovL29wZW5sYXllcnMub3JnL2VuL2xhdGVzdC9hcGlkb2MvbW9kdWxlLW9sX2xheWVyX1ZlY3RvclRpbGUtVmVjdG9yVGlsZUxheWVyLmh0bWxcbiAgICogaHR0cHM6Ly9vcGVubGF5ZXJzLm9yZy9lbi9sYXRlc3QvYXBpZG9jL21vZHVsZS1vbF9zb3VyY2VfVmVjdG9yVGlsZS1WZWN0b3JUaWxlLmh0bWxcbiAgICogaHR0cHM6Ly9vcGVubGF5ZXJzLm9yZy9lbi9sYXRlc3QvYXBpZG9jL21vZHVsZS1vbF9mb3JtYXRfTVZULU1WVC5odG1sXG4gICAqL1xuICBwcml2YXRlIGNyZWF0ZV90bXNfbGF5ZXI8VCBleHRlbmRzIFJhc3RlckxheWVyIHwgVmVjdG9yTGF5ZXI+KGw6IFQpOiB0bXNSZXR1cm5UeXBlPFQ+IHtcbiAgICBsZXQgbmV3bGF5ZXIgPSBudWxsO1xuICAgIGlmIChsIGluc3RhbmNlb2YgUmFzdGVyTGF5ZXIpIHtcbiAgICAgIG5ld2xheWVyID0gdGhpcy5jcmVhdGVfeHl6X2xheWVyKGwpO1xuICAgICAgbmV3bGF5ZXIuc2V0KCd0eXBlJywgJ3RtcycpO1xuICAgICAgcmV0dXJuIG5ld2xheWVyO1xuXG4gICAgfSBlbHNlIGlmIChsIGluc3RhbmNlb2YgVmVjdG9yTGF5ZXIpIHtcbiAgICAgIGNvbnN0IG9sc291cmNlID0gbmV3IG9sVmVjdG9yVGlsZVNvdXJjZSh7XG4gICAgICAgIGZvcm1hdDogbmV3IG9sTVZUKCksXG4gICAgICAgIHRpbGVHcmlkOiBjcmVhdGVYWVooeyBtaW5ab29tOiBsLm1pblpvb20gfHwgdW5kZWZpbmVkLCBtYXhab29tOiBsLm1heFpvb20gfHwgdW5kZWZpbmVkIH0pLFxuICAgICAgICB1cmw6IGwudXJsLFxuICAgICAgICB3cmFwWDogZmFsc2VcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBsYXllcm9wdGlvbnMgPSB0aGlzLmNyZWF0ZU9sTGF5ZXJPcHRpb25zKGwsICd0bXMnLCBvbHNvdXJjZSk7XG5cbiAgICAgIGNvbnN0IHZlY3RvclRpbGVMYXllck9wdGlvbnM6IG9sVmVjdG9yVGlsZUxheWVyT3B0aW9ucyA9IHtcbiAgICAgICAgZGVjbHV0dGVyOiB0cnVlLFxuICAgICAgICByZW5kZXJNb2RlOiAnaHlicmlkJ1xuICAgICAgfTtcblxuICAgICAgbmV3bGF5ZXIgPSBuZXcgb2xWZWN0b3JUaWxlTGF5ZXIoT2JqZWN0LmFzc2lnbihsYXllcm9wdGlvbnMsIHZlY3RvclRpbGVMYXllck9wdGlvbnMpKTtcbiAgICAgIHRoaXMuc2V0U3ViZG9tYWlucyhsLCBuZXdsYXllcik7XG4gICAgICB0aGlzLnNldENyb3NzT3JpZ2luKGwsIG5ld2xheWVyKTtcbiAgICAgIHRoaXMuYWRkRXZlbnRzVG9MYXllcihsLCBuZXdsYXllciwgb2xzb3VyY2UpO1xuXG4gICAgICBjb25zdCBzdHlsZSA9IGw/Lm9wdGlvbnM/LnN0eWxlO1xuICAgICAgY29uc3QgbWFwYm94U291cmNlS2V5ID0gbD8ub3B0aW9ucz8uc3R5bGVTb3VyY2U7XG4gICAgICBpZiAoc3R5bGUgJiYgbWFwYm94U291cmNlS2V5KSB7XG4gICAgICAgIGFwcGx5U3R5bGUobmV3bGF5ZXIsIHN0eWxlLCBtYXBib3hTb3VyY2VLZXkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3bGF5ZXI7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVfd21zX2xheWVyKGw6IFdtc0xheWVyKSB7XG4gICAgbGV0IG5ld2xheWVyOiBvbFRpbGVMYXllcjxvbFRpbGVTb3VyY2U+IHwgb2xJbWFnZUxheWVyPG9sSW1hZ2VTb3VyY2U+O1xuICAgIGlmIChsLnBhcmFtcz8uVElMRUQgPT09ICd0cnVlJyB8fCBsLnBhcmFtcz8uVElMRUQgPT09IHVuZGVmaW5lZCB8fCBsLnBhcmFtcz8uVElMRUQgPT09IG51bGwpIHtcbiAgICAgIG5ld2xheWVyID0gdGhpcy5jcmVhdGVfdGlsZWRfd21zX2xheWVyKGwpO1xuICAgIH0gZWxzZSBpZiAobC5wYXJhbXM/LlRJTEVEID09PSAnZmFsc2UnKSB7XG4gICAgICBuZXdsYXllciA9IHRoaXMuY3JlYXRlX2ltYWdlX3dtc19sYXllcihsKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld2xheWVyO1xuICB9XG5cbiAgLyoqXG4gICAqIGh0dHBzOi8vb3BlbmxheWVycy5vcmcvZW4vbGF0ZXN0L2FwaWRvYy9tb2R1bGUtb2xfbGF5ZXJfVGlsZS1UaWxlTGF5ZXIuaHRtbFxuICAgKiBodHRwczovL29wZW5sYXllcnMub3JnL2VuL2xhdGVzdC9hcGlkb2MvbW9kdWxlLW9sX3NvdXJjZV9UaWxlV01TLVRpbGVXTVMuaHRtbFxuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVfdGlsZWRfd21zX2xheWVyKGw6IFdtc0xheWVyKTogb2xUaWxlTGF5ZXI8b2xUaWxlU291cmNlPiB7XG4gICAgY29uc3QgdGlsZU9wdGlvbnM6IG9sVGlsZVdNU09wdGlvbnMgPSB7XG4gICAgICAvKiogdXNlIGFzc2lnbiBoZXJlIG90aGVyd2lzZSBwYXJhbXMgaXMgcGFzc2VkIGJ5IG9iamVjdCByZWZlcmVuY2UgdG8gdGhlIG9wZW5sYXllcnMgbGF5ZXIhICovXG4gICAgICBwYXJhbXM6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMua2V5c1RvVXBwZXJjYXNlKGwucGFyYW1zKSksIC8vIHBhcmFtczoge30gPSB7IC4uLmwucGFyYW1zIH0gfiBzYW1lIGFzIGFzc2lnbiBkZXN0cnVjdHVyaW5nXG4gICAgICB3cmFwWDogZmFsc2VcbiAgICB9O1xuXG4gICAgaWYgKGwudGlsZVNpemUpIHtcbiAgICAgIHRpbGVPcHRpb25zWyd0aWxlR3JpZCddID0gdGhpcy5nZXRUaWxlR3JpZDxvbFRpbGVHcmlkPignZGVmYXVsdCcsIG51bGwsIGwudGlsZVNpemUpO1xuICAgICAgZGVsZXRlIHRpbGVPcHRpb25zLnBhcmFtc1sndGlsZVNpemUnXTtcbiAgICB9XG5cbiAgICBpZiAobC5jcm9zc09yaWdpbikge1xuICAgICAgdGlsZU9wdGlvbnMuY3Jvc3NPcmlnaW4gPSBsLmNyb3NzT3JpZ2luO1xuICAgIH1cbiAgICBjb25zdCBvbHNvdXJjZSA9IG5ldyBvbFRpbGVXTVModGlsZU9wdGlvbnMpO1xuICAgIGNvbnN0IGJhc2VUaWxlTGF5ZXJPcHRpb25zOiBvbEJhc2VUaWxlTGF5ZXJPcHRpb25zPG9sVGlsZVNvdXJjZT4gPSB7XG4gICAgICBwcmVsb2FkOiAwLFxuICAgICAgdXNlSW50ZXJpbVRpbGVzT25FcnJvcjogdHJ1ZVxuICAgIH07XG5cbiAgICBjb25zdCBsYXllcm9wdGlvbnMgPSB0aGlzLmNyZWF0ZU9sTGF5ZXJPcHRpb25zKGwsICd3bXMnLCBvbHNvdXJjZSk7XG4gICAgY29uc3QgbmV3bGF5ZXIgPSBuZXcgb2xUaWxlTGF5ZXIoT2JqZWN0LmFzc2lnbihsYXllcm9wdGlvbnMsIGJhc2VUaWxlTGF5ZXJPcHRpb25zKSk7XG4gICAgdGhpcy5zZXRTdWJkb21haW5zKGwsIG5ld2xheWVyKTtcbiAgICB0aGlzLmFkZEV2ZW50c1RvTGF5ZXIobCwgbmV3bGF5ZXIsIG9sc291cmNlKTtcbiAgICByZXR1cm4gbmV3bGF5ZXI7XG4gIH1cblxuICAvKipcbiAgICogaHR0cHM6Ly9vcGVubGF5ZXJzLm9yZy9lbi9sYXRlc3QvYXBpZG9jL21vZHVsZS1vbF9sYXllcl9JbWFnZS1JbWFnZUxheWVyLmh0bWxcbiAgICogaHR0cHM6Ly9vcGVubGF5ZXJzLm9yZy9lbi9sYXRlc3QvYXBpZG9jL21vZHVsZS1vbF9zb3VyY2VfSW1hZ2VXTVMtSW1hZ2VXTVMuaHRtbFxuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVfaW1hZ2Vfd21zX2xheWVyKGw6IFdtc0xheWVyKTogb2xJbWFnZUxheWVyPG9sSW1hZ2VTb3VyY2U+IHtcbiAgICBjb25zdCBvcHRpb25zOiBvbEltYWdlV01TT3B0aW9ucyA9IHtcbiAgICAgIC8qKlxuICAgICAgICogdXNlIGFzc2lnbiBoZXJlIG90aGVyd2lzZSBwYXJhbXMgaXMgcGFzc2VkIGJ5IG9iamVjdCByZWZlcmVuY2UgdG8gdGhlIG9wZW5sYXllcnMgbGF5ZXIhXG4gICAgICAgKiBodHRwczovL3RoZWNvZGViYXJiYXJpYW4uY29tL29iamVjdC1hc3NpZ24tdnMtb2JqZWN0LXNwcmVhZC5odG1sXG4gICAgICAgKi9cbiAgICAgIHBhcmFtczogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5rZXlzVG9VcHBlcmNhc2UobC5wYXJhbXMpKSwgLy8gcGFyYW1zOiB7fSA9IHsgLi4ubC5wYXJhbXMgfSB+IHNhbWUgYXMgYXNzaWduIGRlc3RydWN0dXJpbmdcbiAgICAgIHVybDogbC51cmxcbiAgICB9O1xuICAgIGNvbnN0IG9sc291cmNlID0gbmV3IG9sSW1hZ2VXTVMob3B0aW9ucyk7XG4gICAgY29uc3QgbGF5ZXJvcHRpb25zID0gdGhpcy5jcmVhdGVPbExheWVyT3B0aW9ucyhsLCAnd21zJywgb2xzb3VyY2UpO1xuICAgIGNvbnN0IGJhc2VJbWFnZUxheWVyT3B0aW9uczogb2xCYXNlSW1hZ2VMYXllck9wdGlvbnM8b2xJbWFnZVNvdXJjZT4gPSB7XG5cbiAgICB9O1xuICAgIGNvbnN0IG5ld2xheWVyID0gbmV3IG9sSW1hZ2VMYXllcihPYmplY3QuYXNzaWduKGxheWVyb3B0aW9ucywgYmFzZUltYWdlTGF5ZXJPcHRpb25zKSk7XG4gICAgdGhpcy5hZGRFdmVudHNUb0xheWVyKGwsIG5ld2xheWVyLCBvbHNvdXJjZSk7XG4gICAgcmV0dXJuIG5ld2xheWVyO1xuICB9XG5cbiAgLyoqXG4gICAqIGh0dHBzOi8vb3BlbmxheWVycy5vcmcvZW4vbGF0ZXN0L2FwaWRvYy9tb2R1bGUtb2xfbGF5ZXJfVGlsZS1UaWxlTGF5ZXIuaHRtbFxuICAgKiBodHRwczovL29wZW5sYXllcnMub3JnL2VuL2xhdGVzdC9hcGlkb2MvbW9kdWxlLW9sX3NvdXJjZV9XTVRTLVdNVFMuaHRtbFxuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVfd210c19sYXllcihsOiBXbXRzTGF5ZXIpOiBvbFRpbGVMYXllcjxvbFRpbGVTb3VyY2U+IHtcbiAgICBpZiAobCBpbnN0YW5jZW9mIFdtdHNMYXllcikge1xuXG4gICAgICBsZXQgdGlsZUdyaWQgPSB0aGlzLmdldFRpbGVHcmlkPG9sV01UU1RpbGVHcmlkPignd210cycpO1xuICAgICAgbGV0IG1hdHJpeFNldCA9IHRoaXMuRVBTRztcbiAgICAgIGlmIChsLnBhcmFtcy5tYXRyaXhTZXRPcHRpb25zKSB7XG4gICAgICAgIG1hdHJpeFNldCA9IGwucGFyYW1zLm1hdHJpeFNldE9wdGlvbnMubWF0cml4U2V0O1xuICAgICAgICBpZiAoJ3Jlc29sdXRpb25zJyBpbiBsLnBhcmFtcy5tYXRyaXhTZXRPcHRpb25zKSB7XG4gICAgICAgICAgY29uc3QgcmVzb2x1dGlvbnM6IEFycmF5PHN0cmluZyB8IG51bWJlcj4gPSBsLnBhcmFtcy5tYXRyaXhTZXRPcHRpb25zLnJlc29sdXRpb25zO1xuICAgICAgICAgIHRpbGVHcmlkID0gdGhpcy5nZXRUaWxlR3JpZDxvbFdNVFNUaWxlR3JpZD4oJ3dtdHMnLCBudWxsLCBsLnRpbGVTaXplLCBudWxsLCByZXNvbHV0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAoJ3Jlc29sdXRpb25MZXZlbHMnIGluIGwucGFyYW1zLm1hdHJpeFNldE9wdGlvbnMgfHwgJ3RpbGVNYXRyaXhQcmVmaXgnIGluIGwucGFyYW1zLm1hdHJpeFNldE9wdGlvbnMpIHsgLyoqIElTaW1wbGVNYXRyaXhTZXQgKi9cbiAgICAgICAgICBjb25zdCByZXNvbHV0aW9uTGV2ZWxzID0gbC5wYXJhbXMubWF0cml4U2V0T3B0aW9ucy5yZXNvbHV0aW9uTGV2ZWxzO1xuICAgICAgICAgIGNvbnN0IHRpbGVNYXRyaXhQcmVmaXggPSBsLnBhcmFtcy5tYXRyaXhTZXRPcHRpb25zLnRpbGVNYXRyaXhQcmVmaXg7XG4gICAgICAgICAgdGlsZUdyaWQgPSB0aGlzLmdldFRpbGVHcmlkPG9sV01UU1RpbGVHcmlkPignd210cycsIHJlc29sdXRpb25MZXZlbHMsIGwudGlsZVNpemUsIHRpbGVNYXRyaXhQcmVmaXgsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnbWF0cml4SWRzJyBpbiBsLnBhcmFtcy5tYXRyaXhTZXRPcHRpb25zKSB7XG4gICAgICAgICAgY29uc3QgbWF0cml4SWRzID0gbC5wYXJhbXMubWF0cml4U2V0T3B0aW9ucy5tYXRyaXhJZHM7XG4gICAgICAgICAgdGlsZUdyaWQgPSB0aGlzLmdldFRpbGVHcmlkPG9sV01UU1RpbGVHcmlkPignd210cycsIG51bGwsIGwudGlsZVNpemUsIG51bGwsIG51bGwsIG1hdHJpeElkcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV0IHdtdHNPcHRpb25zOiBvbFdNVFNPcHRpb25zID0ge1xuICAgICAgICB1cmw6IGwudXJsLFxuICAgICAgICB0aWxlR3JpZCxcbiAgICAgICAgbWF0cml4U2V0LFxuICAgICAgICB3cmFwWDogZmFsc2UsXG4gICAgICAgIGxheWVyOiBsLnBhcmFtcy5sYXllcixcbiAgICAgICAgc3R5bGU6IGwucGFyYW1zLnN0eWxlXG4gICAgICB9O1xuICAgICAgd210c09wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB3bXRzT3B0aW9ucywgbC5wYXJhbXMpO1xuXG5cbiAgICAgIGlmIChsLmNyb3NzT3JpZ2luKSB7XG4gICAgICAgIHdtdHNPcHRpb25zLmNyb3NzT3JpZ2luID0gbC5jcm9zc09yaWdpbjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb2xzb3VyY2UgPSBuZXcgb2xXTVRTKHdtdHNPcHRpb25zKTtcbiAgICAgIGNvbnN0IGxheWVyb3B0aW9ucyA9IHRoaXMuY3JlYXRlT2xMYXllck9wdGlvbnMobCwgJ3dtdHMnLCBvbHNvdXJjZSk7XG4gICAgICBjb25zdCBiYXNlVGlsZUxheWVyT3B0aW9uczogb2xCYXNlVGlsZUxheWVyT3B0aW9uczxvbFRpbGVTb3VyY2U+ID0ge307XG5cbiAgICAgIGNvbnN0IG5ld2xheWVyID0gbmV3IG9sVGlsZUxheWVyKE9iamVjdC5hc3NpZ24obGF5ZXJvcHRpb25zLCBiYXNlVGlsZUxheWVyT3B0aW9ucykpO1xuICAgICAgdGhpcy5zZXRTdWJkb21haW5zKGwsIG5ld2xheWVyKTtcbiAgICAgIHRoaXMuc2V0Q3Jvc3NPcmlnaW4obCwgbmV3bGF5ZXIpO1xuICAgICAgdGhpcy5hZGRFdmVudHNUb0xheWVyKGwsIG5ld2xheWVyLCBvbHNvdXJjZSk7XG4gICAgICByZXR1cm4gbmV3bGF5ZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxheWVyID0gbCBhcyBMYXllcjtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYGxheWVyIHdpdGggaWQ6ICR7bGF5ZXIuaWR9IGFuZCB0eXBlICR7bGF5ZXIudHlwZX0gaXMgbm8gaW5zdGFuY2VvZiBXbXRzTGF5ZXIhYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGNoZWNrIHByb2plY3RzL2RlbW8tbWFwcy9zcmMvYXBwL3JvdXRlLWNvbXBvbmVudHMvcm91dGUtZXhhbXBsZS1vbHBlcmZvcm1hbmNlL3NlcnZpY2VzL2xhcmdlbGF5ZXJzLnNlcnZpY2UudHNcbiAgICogZm9yIFdGUyBleGFtcGxlcy5cbiAgICpcbiAgICogaHR0cHM6Ly9vcGVubGF5ZXJzLm9yZy9lbi9sYXRlc3QvYXBpZG9jL21vZHVsZS1vbF9sYXllcl9WZWN0b3ItVmVjdG9yTGF5ZXIuaHRtbFxuICAgKiBodHRwczovL29wZW5sYXllcnMub3JnL2VuL2xhdGVzdC9hcGlkb2MvbW9kdWxlLW9sX3NvdXJjZV9WZWN0b3ItVmVjdG9yU291cmNlLmh0bWxcbiAgICovXG4gIHByaXZhdGUgY3JlYXRlX3dmc19sYXllcihsOiBWZWN0b3JMYXllcik6IG9sVmVjdG9yTGF5ZXI8b2xWZWN0b3JTb3VyY2U8b2xHZW9tZXRyeT4+IHtcbiAgICBsZXQgdXJsID0gbnVsbDtcbiAgICBpZiAobC51cmwuaW5kZXhPZignaHR0cDovLycpID09PSAwIHx8IGwudXJsLmluZGV4T2YoJ2h0dHBzOi8vJykgPT09IDApIHtcbiAgICAgIHVybCA9IG5ldyBVUkwobC51cmwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cmwgPSBuZXcgVVJMKGwudXJsLCB3aW5kb3cubG9jYXRpb24ub3JpZ2luKTtcbiAgICB9XG5cbiAgICAvLyBtYWtpbmcgc3VyZSB0aGF0IHNyc25hbWUgaXMgc2V0IHRvIGN1cnJlbnQgcHJvamVjdGlvblxuICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdzcnNuYW1lJywgdGhpcy5FUFNHKTtcbiAgICAvLyBub3RlIHRoYXQgd2UgZG9uJ3QgbmVlZCB0byBhZGp1c3QgdGhlIGJib3guIGNvbnRyYXJ5IHRvIHdtcydlcywgaW4gYSB3ZnMsXG4gICAgLy8gYSBiYm94IG1heSB1c2UgYW5vdGhlciBwcm9qZWN0aW9uIHRoYW4gdGhlIHNyc25hbWUuXG5cbiAgICBjb25zdCBvbHNvdXJjZSA9IG5ldyBvbFZlY3RvclNvdXJjZSh7XG4gICAgICBmb3JtYXQ6IG5ldyBvbEdlb0pTT04oKSxcbiAgICAgIHVybDogdXJsLnRvU3RyaW5nKClcbiAgICB9KTtcblxuICAgIGNvbnN0IGxheWVyb3B0aW9ucyA9IHRoaXMuY3JlYXRlT2xMYXllck9wdGlvbnMobCwgJ3dmcycsIG9sc291cmNlKTtcbiAgICBjb25zdCBiYXNlVmVjdG9yTGF5ZXJPcHRpb25zOiBvbEJhc2VWZWN0b3JMYXllck9wdGlvbnM8b2xWZWN0b3JTb3VyY2U8b2xHZW9tZXRyeT4+ID0ge307XG5cbiAgICBpZiAobC5vcHRpb25zKSB7XG4gICAgICAvLyBoZXJlIE9iamVjdC5hc3NpZ24gbW9kaWZpZXMgdGhlIHRhcmdldCBvYmplY3QgLSBzdHlsZS4uLiBpcyBpbmNsdWRlZFxuICAgICAgT2JqZWN0LmFzc2lnbihiYXNlVmVjdG9yTGF5ZXJPcHRpb25zLCBsLm9wdGlvbnMpO1xuICAgIH1cblxuICAgIGNvbnN0IG5ld2xheWVyID0gbmV3IG9sVmVjdG9yTGF5ZXIoT2JqZWN0LmFzc2lnbihsYXllcm9wdGlvbnMsIGJhc2VWZWN0b3JMYXllck9wdGlvbnMpKTtcbiAgICBpZiAobC5jbHVzdGVyKSB7XG4gICAgICB0aGlzLnNldENsdXN0ZXIobCwgbmV3bGF5ZXIsIG9sc291cmNlLCB7fSk7XG4gICAgfVxuICAgIHRoaXMuc2V0U3ViZG9tYWlucyhsLCBuZXdsYXllcik7XG4gICAgdGhpcy5zZXRDcm9zc09yaWdpbihsLCBuZXdsYXllcik7XG4gICAgdGhpcy5hZGRFdmVudHNUb0xheWVyKGwsIG5ld2xheWVyLCBvbHNvdXJjZSk7XG4gICAgcmV0dXJuIG5ld2xheWVyO1xuICB9XG5cbiAgLyoqXG4gICAqIGh0dHBzOi8vb3BlbmxheWVycy5vcmcvZW4vbGF0ZXN0L2FwaWRvYy9tb2R1bGUtb2xfbGF5ZXJfVmVjdG9yLVZlY3RvckxheWVyLmh0bWxcbiAgICogaHR0cHM6Ly9vcGVubGF5ZXJzLm9yZy9lbi9sYXRlc3QvYXBpZG9jL21vZHVsZS1vbF9zb3VyY2VfVmVjdG9yLVZlY3RvclNvdXJjZS5odG1sXG4gICAqIGh0dHBzOi8vb3BlbmxheWVycy5vcmcvZW4vbGF0ZXN0L2FwaWRvYy9tb2R1bGUtb2xfZm9ybWF0X0dlb0pTT04tR2VvSlNPTi5odG1sXG4gICAqL1xuICBwcml2YXRlIGNyZWF0ZV9nZW9qc29uX2xheWVyKGw6IFZlY3RvckxheWVyKSB7XG4gICAgbGV0IG9sc291cmNlOiBvbFZlY3RvclNvdXJjZTtcbiAgICBpZiAobC5kYXRhKSB7XG4gICAgICBvbHNvdXJjZSA9IG5ldyBvbFZlY3RvclNvdXJjZSh7XG4gICAgICAgIGZlYXR1cmVzOiB0aGlzLmdlb0pzb25Ub0ZlYXR1cmVzKGwuZGF0YSksXG4gICAgICAgIGZvcm1hdDogbmV3IG9sR2VvSlNPTigpLFxuICAgICAgICB3cmFwWDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAobC51cmwpIHtcbiAgICAgIG9sc291cmNlID0gbmV3IG9sVmVjdG9yU291cmNlKHtcbiAgICAgICAgdXJsOiBsLnVybCxcbiAgICAgICAgZm9ybWF0OiBuZXcgb2xHZW9KU09OKHtcbiAgICAgICAgICBkYXRhUHJvamVjdGlvbjogV0dTODQsXG4gICAgICAgICAgZmVhdHVyZVByb2plY3Rpb246IHRoaXMuRVBTR1xuICAgICAgICB9KSxcbiAgICAgICAgd3JhcFg6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBsYXllcm9wdGlvbnMgPSB0aGlzLmNyZWF0ZU9sTGF5ZXJPcHRpb25zKGwsICdnZW9qc29uJywgb2xzb3VyY2UpO1xuXG4gICAgY29uc3QgYmFzZVZlY3RvckxheWVyT3B0aW9uczogb2xCYXNlVmVjdG9yTGF5ZXJPcHRpb25zPG9sVmVjdG9yU291cmNlPG9sR2VvbWV0cnk+PiA9IHt9O1xuICAgIGlmIChsLm9wdGlvbnMpIHtcbiAgICAgIC8vIGhlcmUgT2JqZWN0LmFzc2lnbiBtb2RpZmllcyB0aGUgdGFyZ2V0IG9iamVjdCAtIHN0eWxlLi4uIGlzIGluY2x1ZGVkXG4gICAgICBPYmplY3QuYXNzaWduKGJhc2VWZWN0b3JMYXllck9wdGlvbnMsIGwub3B0aW9ucyk7XG4gICAgfVxuXG4gICAgY29uc3QgbmV3bGF5ZXIgPSBuZXcgb2xWZWN0b3JMYXllcihPYmplY3QuYXNzaWduKGxheWVyb3B0aW9ucywgYmFzZVZlY3RvckxheWVyT3B0aW9ucykpO1xuICAgIGlmIChsLmNsdXN0ZXIpIHtcbiAgICAgIHRoaXMuc2V0Q2x1c3RlcihsLCBuZXdsYXllciwgb2xzb3VyY2UsIHt9KTtcbiAgICB9XG4gICAgdGhpcy5zZXRDcm9zc09yaWdpbihsLCBuZXdsYXllcik7XG4gICAgdGhpcy5hZGRFdmVudHNUb0xheWVyKGwsIG5ld2xheWVyLCBvbHNvdXJjZSk7XG4gICAgcmV0dXJuIG5ld2xheWVyO1xuICB9XG5cbiAgLyoqXG4gICAqIGh0dHBzOi8vb3BlbmxheWVycy5vcmcvZW4vbGF0ZXN0L2FwaWRvYy9tb2R1bGUtb2xfbGF5ZXJfVmVjdG9yLVZlY3RvckxheWVyLmh0bWxcbiAgICogaHR0cHM6Ly9vcGVubGF5ZXJzLm9yZy9lbi9sYXRlc3QvYXBpZG9jL21vZHVsZS1vbF9zb3VyY2VfVmVjdG9yLVZlY3RvclNvdXJjZS5odG1sXG4gICAqIGh0dHBzOi8vb3BlbmxheWVycy5vcmcvZW4vbGF0ZXN0L2FwaWRvYy9tb2R1bGUtb2xfZm9ybWF0X0tNTC1LTUwuaHRtbFxuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVfa21sX2xheWVyKGw6IFZlY3RvckxheWVyKSB7XG4gICAgbGV0IG9sc291cmNlOiBvbFZlY3RvclNvdXJjZTtcbiAgICBpZiAobC5kYXRhKSB7XG4gICAgICBvbHNvdXJjZSA9IG5ldyBvbFZlY3RvclNvdXJjZSh7XG4gICAgICAgIGZlYXR1cmVzOiBuZXcgb2xLTUwoeyBleHRyYWN0U3R5bGVzOiB0cnVlIH0pLnJlYWRGZWF0dXJlcyhsLmRhdGEsIHtcbiAgICAgICAgICBkYXRhUHJvamVjdGlvbjogV0dTODQsXG4gICAgICAgICAgZmVhdHVyZVByb2plY3Rpb246IHRoaXMuRVBTR1xuICAgICAgICB9KSxcbiAgICAgICAgZm9ybWF0OiBuZXcgb2xLTUwoKSxcbiAgICAgICAgd3JhcFg6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGwudXJsKSB7XG4gICAgICBvbHNvdXJjZSA9IG5ldyBvbFZlY3RvclNvdXJjZSh7XG4gICAgICAgIHVybDogbC51cmwsXG4gICAgICAgIGZvcm1hdDogbmV3IG9sS01MKHtcbiAgICAgICAgICBleHRyYWN0U3R5bGVzOiB0cnVlLFxuICAgICAgICAgIGNyb3NzT3JpZ2luOiAobC5jcm9zc09yaWdpbiAmJiBsLmNyb3NzT3JpZ2luID09PSBudWxsKSA/IGwuY3Jvc3NPcmlnaW4gOiAnYW5vbnltb3VzJyxcbiAgICAgICAgfSksXG4gICAgICAgIHdyYXBYOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgbGF5ZXJvcHRpb25zID0gdGhpcy5jcmVhdGVPbExheWVyT3B0aW9ucyhsLCAna21sJywgb2xzb3VyY2UpO1xuXG4gICAgY29uc3QgYmFzZVZlY3RvckxheWVyT3B0aW9uczogb2xCYXNlVmVjdG9yTGF5ZXJPcHRpb25zPG9sVmVjdG9yU291cmNlPG9sR2VvbWV0cnk+PiA9IHt9O1xuICAgIGlmIChsLm9wdGlvbnMpIHtcbiAgICAgIC8vIGhlcmUgT2JqZWN0LmFzc2lnbiBtb2RpZmllcyB0aGUgdGFyZ2V0IG9iamVjdCAtIHN0eWxlLi4uIGlzIGluY2x1ZGVkXG4gICAgICBPYmplY3QuYXNzaWduKGJhc2VWZWN0b3JMYXllck9wdGlvbnMsIGwub3B0aW9ucyk7XG4gICAgfVxuXG4gICAgY29uc3QgbmV3bGF5ZXIgPSBuZXcgb2xWZWN0b3JMYXllcihPYmplY3QuYXNzaWduKGxheWVyb3B0aW9ucywgYmFzZVZlY3RvckxheWVyT3B0aW9ucykpO1xuICAgIGlmIChsLmNsdXN0ZXIpIHtcbiAgICAgIHRoaXMuc2V0Q2x1c3RlcihsLCBuZXdsYXllciwgb2xzb3VyY2UsIHt9KTtcbiAgICB9XG4gICAgdGhpcy5zZXRDcm9zc09yaWdpbihsLCBuZXdsYXllcik7XG4gICAgdGhpcy5hZGRFdmVudHNUb0xheWVyKGwsIG5ld2xheWVyLCBsYXllcm9wdGlvbnMuc291cmNlKTtcbiAgICByZXR1cm4gbmV3bGF5ZXI7XG4gIH1cblxuICAvKiogYnVnIGZpeDogaHR0cHM6Ly9naXRodWIuY29tL29wZW5sYXllcnMvb3BlbmxheWVycy9pc3N1ZXMvMTAwOTkgKi9cbiAgcHJpdmF0ZSBzZXRDcm9zc09yaWdpbihsOiBMYXllciwgbGF5ZXI6IG9sTGF5ZXI8b2xTb3VyY2U+KTogdm9pZCB7XG4gICAgaWYgKGxheWVyIGluc3RhbmNlb2Ygb2xMYXllcikge1xuICAgICAgY29uc3Qgb2xzb3VyY2UgPSBsYXllci5nZXRTb3VyY2UoKTtcbiAgICAgIC8qKiBzZXQgY3Jvc3NPcmlnaW4gZm9yIHBvcHVwIGxheWVycyAgKi9cbiAgICAgIGlmIChsLnBvcHVwICYmICFsLmNyb3NzT3JpZ2luICYmIGwuY3Jvc3NPcmlnaW4gIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5zb3VyY2VTZXRDcm9zcyhvbHNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChsLmNyb3NzT3JpZ2luIHx8IGwuY3Jvc3NPcmlnaW4gPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5zb3VyY2VTZXRDcm9zcyhvbHNvdXJjZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHNldCBjbHVzdGVyIHNvdXJjZSBhbmQgc3R5bGUgZm9yIHBvaW50IGxheWVyc1xuICAgKi9cbiAgcHJpdmF0ZSBzZXRDbHVzdGVyKGw6IFZlY3RvckxheWVyLCBsYXllcjogb2xWZWN0b3JMYXllcjxvbFZlY3RvclNvdXJjZT4sIHNvdXJjZTogb2xWZWN0b3JTb3VyY2UsIHN0eWxlQ2FjaGU6IHsgW2tleTogc3RyaW5nXTogYW55IH0pOiB2b2lkIHtcbiAgICBpZiAobC5jbHVzdGVyKSB7XG4gICAgICBjb25zdCBjbHVzdGVyb3B0aW9uczogb2xDbHVzdGVyT3B0aW9ucyA9IHt9O1xuICAgICAgaWYgKHR5cGVvZiBsLmNsdXN0ZXIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIGhlcmUgT2JqZWN0LmFzc2lnbiBtb2RpZmllcyB0aGUgdGFyZ2V0IG9iamVjdFxuICAgICAgICBPYmplY3QuYXNzaWduKGNsdXN0ZXJvcHRpb25zLCBsLmNsdXN0ZXIpO1xuICAgICAgfVxuICAgICAgY2x1c3Rlcm9wdGlvbnMuc291cmNlID0gc291cmNlO1xuICAgICAgY29uc3QgY2x1c3RlclNvdXJjZSA9IG5ldyBvbENsdXN0ZXIoY2x1c3Rlcm9wdGlvbnMpO1xuICAgICAgLy8gbGF5ZXJvcHRpb25zLnNvdXJjZSA9IGNsdXN0ZXJTb3VyY2U7XG4gICAgICBsYXllci5zZXRTb3VyY2UoY2x1c3RlclNvdXJjZSk7XG4gICAgICBsYXllci5zZXRTdHlsZSgoZmVhdHVyZSkgPT4ge1xuICAgICAgICBjb25zdCBzaXplID0gZmVhdHVyZS5nZXQoJ2ZlYXR1cmVzJykubGVuZ3RoO1xuICAgICAgICBsZXQgc3R5bGUgPSBzdHlsZUNhY2hlW3NpemVdO1xuICAgICAgICBpZiAoIXN0eWxlKSB7XG4gICAgICAgICAgc3R5bGUgPSBuZXcgb2xTdHlsZSh7XG4gICAgICAgICAgICBpbWFnZTogbmV3IG9sQ2lyY2xlU3R5bGUoe1xuICAgICAgICAgICAgICByYWRpdXM6IDEwLFxuICAgICAgICAgICAgICBzdHJva2U6IG5ldyBvbFN0cm9rZSh7XG4gICAgICAgICAgICAgICAgY29sb3I6ICcjZmZmJ1xuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgZmlsbDogbmV3IG9sRmlsbCh7XG4gICAgICAgICAgICAgICAgY29sb3I6ICcjMzM5OUNDJ1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0ZXh0OiBuZXcgb2xUZXh0KHtcbiAgICAgICAgICAgICAgdGV4dDogc2l6ZS50b1N0cmluZygpLFxuICAgICAgICAgICAgICBmaWxsOiBuZXcgb2xGaWxsKHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJyNmZmYnXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0eWxlQ2FjaGVbc2l6ZV0gPSBzdHlsZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKiogdXNlIHN1YmRvbWFpbnMgdG8gc2V0VXJsL3Mgb24gc291cmNlICovXG4gIHByaXZhdGUgc2V0U3ViZG9tYWlucyhsOiBMYXllciwgbGF5ZXI6IG9sTGF5ZXI8b2xTb3VyY2U+KTogdm9pZCB7XG4gICAgaWYgKGwgaW5zdGFuY2VvZiBWZWN0b3JMYXllciB8fCBsIGluc3RhbmNlb2YgUmFzdGVyTGF5ZXIpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGxheWVyLmdldFNvdXJjZSgpIGFzIG9sWFlaIHwgb2xWZWN0b3JUaWxlIHwgb2xUaWxlV01TIHwgb2xXTVRTIHwgb2xWZWN0b3JTb3VyY2U8b2xHZW9tZXRyeT47XG4gICAgICBpZiAobC5zdWJkb21haW5zKSB7XG4gICAgICAgIGlmIChsLnR5cGUgPT09ICd3ZnMnICYmIChzb3VyY2UgaW5zdGFuY2VvZiBvbFZlY3RvclNvdXJjZSkpIHtcbiAgICAgICAgICBsLnVybCA9IGwudXJsLnJlcGxhY2UoJ3tzfScsIGAke2wuc3ViZG9tYWluc1swXX0tJHtsLnN1YmRvbWFpbnNbbC5zdWJkb21haW5zLmxlbmd0aCAtIDFdfWApO1xuICAgICAgICAgIHNvdXJjZS5zZXRVcmwobC51cmwpO1xuICAgICAgICB9IGVsc2UgaWYgKCEoc291cmNlIGluc3RhbmNlb2Ygb2xWZWN0b3JTb3VyY2UpKSB7XG4gICAgICAgICAgY29uc3QgdXJscyA9IGwuc3ViZG9tYWlucy5tYXAoKGl0ZW0pID0+IGwudXJsLnJlcGxhY2UoJ3tzfScsIGAke2l0ZW19YCkpO1xuICAgICAgICAgIHNvdXJjZS5zZXRVcmxzKHVybHMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb3VyY2Uuc2V0VXJsKGwudXJsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNvdXJjZVNldENyb3NzKHNvdXJjZTogb2xTb3VyY2UpOiB2b2lkIHtcbiAgICAvKipcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vc2VhcmNoP3E9Y3Jvc3NPcmlnaW4rcmVwbyUzQW9wZW5sYXllcnMlMkZvcGVubGF5ZXJzK3BhdGglM0FzcmMlMkZvbCUyRnNvdXJjZSUyRiZ0eXBlPUNvZGUmcmVmPWFkdnNlYXJjaCZsPSZsPVxuICAgICAqL1xuICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBvbEltYWdlU291cmNlIHx8IHNvdXJjZSBpbnN0YW5jZW9mIG9sVGlsZUltYWdlU291cmNlIHx8IHNvdXJjZSBpbnN0YW5jZW9mIG9sVGlsZVNvdXJjZSkge1xuICAgICAgc291cmNlWydjcm9zc09yaWdpbiddID0gJ2Fub255bW91cyc7XG4gICAgICBzb3VyY2VbJ2Nyb3NzT3JpZ2luXyddID0gJ2Fub255bW91cyc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIExheWVyIHRvIGFkZCBhIG5vdCBzdXBwb3J0ZWQgT3BlbkxheWVycyBsYXllclxuICAgKlxuICAgKiBjdXN0b21fbGF5ZXI6IG9sQmFzZUxheWVyXG4gICAqL1xuICBwcml2YXRlIGNyZWF0ZV9jdXN0b21fbGF5ZXIobDogQ3VzdG9tTGF5ZXI8b2xCYXNlTGF5ZXI+KSB7XG4gICAgaWYgKGwuY3VzdG9tX2xheWVyKSB7XG4gICAgICBjb25zdCBsYXllciA9IGwuY3VzdG9tX2xheWVyO1xuXG4gICAgICBpZiAobGF5ZXIgaW5zdGFuY2VvZiBvbExheWVyKSB7XG4gICAgICAgIGNvbnN0IG9sc291cmNlID0gbGF5ZXIuZ2V0U291cmNlKCkgYXMgb2xTb3VyY2U7XG4gICAgICAgIGlmIChsLmF0dHJpYnV0aW9uKSB7XG4gICAgICAgICAgb2xzb3VyY2Uuc2V0QXR0cmlidXRpb25zKFtsLmF0dHJpYnV0aW9uXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobC5jb250aW51b3VzV29ybGQpIHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBzZXQgd3JhcFggYWZ0ZXIgc291cmNlIGNyZWF0aW9uIGlzIG5vdCBwb3NzaWJsZSBzbyB3ZSBoYXZlIHRvIHVzZSB0aGUgcHJpdmF0ZSBwcm9wZXJ0eVxuICAgICAgICAgICAqIEl0IHdvcmtzIGJhc2VkIG9uIGEgdGVzdCBpbiBjb2Rlc2FuZGJveC5pb1xuICAgICAgICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVubGF5ZXJzL29wZW5sYXllcnMvYmxvYi92Ni4xMy4wL3NyYy9vbC9zb3VyY2UvU291cmNlLmpzI0w0OFxuICAgICAgICAgICAqL1xuICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tc3RyaW5nLWxpdGVyYWxcbiAgICAgICAgICBvbHNvdXJjZVsnd3JhcFhfJ10gPSBsLmNvbnRpbnVvdXNXb3JsZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLXN0cmluZy1saXRlcmFsXG4gICAgICAgICAgb2xzb3VyY2VbJ3dyYXBYXyddID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRDcm9zc09yaWdpbihsLCBsYXllcik7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRzVG9MYXllcihsLCBsYXllciwgb2xzb3VyY2UpO1xuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kbHItZW9jL3VraXMtZnJvbnRlbmQtbGlicmFyaWVzL2lzc3Vlcy8xMDBcbiAgICAgICAgaWYgKG9sc291cmNlIGluc3RhbmNlb2Ygb2xSYXN0ZXJTb3VyY2UpIHtcbiAgICAgICAgICBsYXllci5vbignY2hhbmdlOnNvdXJjZScsIChldnQpID0+IHtcbiAgICAgICAgICAgIGV2dC5vbGRWYWx1ZS5kaXNwb3NlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobGF5ZXIgaW5zdGFuY2VvZiBvbExheWVyR3JvdXApIHtcbiAgICAgICAgbGF5ZXIuZ2V0TGF5ZXJzKCkuZm9yRWFjaChnbCA9PiB7XG4gICAgICAgICAgY29uc3QgbGF5ZXJJZCA9IGAke2wuaWR9XyR7b2xHZXRVaWQoZ2wpfWA7XG4gICAgICAgICAgaWYgKCFnbC5nZXQoJ2lkJykpIHtcbiAgICAgICAgICAgIGdsLnNldCgnaWQnLCBsYXllcklkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGdsIGluc3RhbmNlb2Ygb2xMYXllcikge1xuICAgICAgICAgICAgdGhpcy5zZXRDcm9zc09yaWdpbihsLCBnbCk7XG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50c1RvTGF5ZXIobCwgZ2wsIGdsLmdldFNvdXJjZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogZ3JvdXBzIGFyZSBmbGF0dGVuZWQgaW4gbWFwLmZvckVhY2hMYXllckF0UGl4ZWwgc28gYWRkIHBvcHVwIHRvIGVhY2ggbGF5ZXJcbiAgICAgICAgICAgKiBwb3B1cCB3aWxsIGJlIHNob3duIGZvciB0b3AgbGF5ZXIgaW4gdGhlIEdyb3VwIGlmIHRoZXJlIGlzIGEgcGl4ZWwgY29sb3JcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBpZiAobC5wb3B1cCAmJiAhZ2wuZ2V0KCdwb3B1cCcpKSB7XG4gICAgICAgICAgICBnbC5zZXQoJ3BvcHVwJywgbC5wb3B1cCk7XG4gICAgICAgICAgICAvKiogc2V0IGNsYXNzTmFtZSBpZiBub3QgZGVmYXVsdCBvbC1sYXllciAqL1xuICAgICAgICAgICAgaWYgKGdsLmdldENsYXNzTmFtZSgpID09PSAnb2wtbGF5ZXInKSB7XG4gICAgICAgICAgICAgIGdsWydjbGFzc05hbWVfJ10gPSBsYXllcklkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBUaGUgY3VzdG9tX2xheWVyIG9mICR7bC5pZH0gaW4gbm90IGEgb3BlbmxheWVycyBMYXllcmApO1xuICAgICAgfVxuXG4gICAgICBpZiAobC5tYXhSZXNvbHV0aW9uKSB7XG4gICAgICAgIGxheWVyLnNldE1heFJlc29sdXRpb24obC5tYXhSZXNvbHV0aW9uKTtcbiAgICAgIH1cbiAgICAgIGlmIChsLm1pblJlc29sdXRpb24pIHtcbiAgICAgICAgbGF5ZXIuc2V0TWluUmVzb2x1dGlvbihsLm1pblJlc29sdXRpb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAobC5tYXhab29tKSB7XG4gICAgICAgIGxheWVyLnNldE1heFpvb20obC5tYXhab29tKTtcbiAgICAgIH1cbiAgICAgIGlmIChsLm1pblpvb20pIHtcbiAgICAgICAgbGF5ZXIuc2V0TWluWm9vbShsLm1pblpvb20pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsYXllcm9wdGlvbnM6IElMYXllck9wdGlvbnMgJiBvbExheWVyT3B0aW9uczxMYXllck9wdGlvbnNTb3VyY2VzPiA9IHtcbiAgICAgICAgdHlwZTogJ2N1c3RvbScsXG4gICAgICAgIG5hbWU6IGwubmFtZSxcbiAgICAgICAgaWQ6IGwuaWQsXG4gICAgICAgIHZpc2libGU6IGwudmlzaWJsZSxcbiAgICAgICAgbGVnZW5kSW1nOiBsLmxlZ2VuZEltZyxcbiAgICAgICAgb3BhY2l0eTogbC5vcGFjaXR5IHx8IDEsXG4gICAgICAgIHpJbmRleDogMSxcbiAgICAgIH07XG5cbiAgICAgIGlmIChsLnBvcHVwICYmICEobGF5ZXIgaW5zdGFuY2VvZiBvbExheWVyR3JvdXApKSB7XG4gICAgICAgIGxheWVyb3B0aW9ucy5wb3B1cCA9IGwucG9wdXA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBvbCA2LnggcHJvYmxlbSBpZiBwb3B1cCAobWFwLmZvckVhY2hMYXllckF0UGl4ZWwpIHVzZSBjbGFzc05hbWVcbiAgICAgICAgICogbmVlZHMgdGhlIGNsYXNzIE5hbWUgdG8gZGV0ZWN0IGlmIGl0IGlzIGEgZGlmZmVyZW50IGxheWVyIGF0IHRoZSBwaXhlbCB2YWx1ZVxuICAgICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vb3BlbmxheWVycy9vcGVubGF5ZXJzL3JlbGVhc2VzL3RhZy92Ni4wLjBcbiAgICAgICAgICovXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tc3RyaW5nLWxpdGVyYWxcbiAgICAgICAgbGF5ZXJbJ2NsYXNzTmFtZV8nXSA9IGwuaWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChsLmJib3gpIHtcbiAgICAgICAgY29uc3QgZXh0ZW50ID0gdHJhbnNmb3JtRXh0ZW50KGwuYmJveC5zbGljZSgwLCA0KSBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgV0dTODQsIHRoaXMuZ2V0UHJvamVjdGlvbigpLmdldENvZGUoKSk7XG4gICAgICAgIGxheWVyLnNldEV4dGVudChleHRlbnQpO1xuICAgICAgfVxuXG4gICAgICBsYXllci5zZXRQcm9wZXJ0aWVzKGxheWVyb3B0aW9ucyk7XG4gICAgICAvLyBkb24ndCBkZWxldGUgdGhlIGN1c3RvbSBMYXllciwgaXQgaXMgdXNlZCB0byBuZXdseSBjcmVhdGUgYWxsIGxheWVycyBmcm9tIGxheWVyc2VydmljZSBhZnRlciBtYXAgYWxsIGxheWVycyByZW1vdmVkIVxuICAgICAgLy8gZGVsZXRlIGwuY3VzdG9tX2xheWVyO1xuICAgICAgcmV0dXJuIGxheWVyO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKCdhdHRyaWJ1dGUgY3VzdG9tX2xheWVyIG5vdCBzZXQgb24gbGF5ZXIgdHlwZSBjdXN0b20hJywgbCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIExheWVyIHRvIHN0YWNrIG11bHRpcGxlIHVraXMgbGF5ZXJzIGluIG9uZS5cbiAgICogY3JlYXRlcyBhIG9sTGF5ZXJHcm91cCBmcm9tIGNyZWF0ZV9sYXllcnNcbiAgICovXG4gIHByaXZhdGUgY3JlYXRlX3N0YWNrZWRfbGF5ZXIobDogU3RhY2tlZExheWVyKSB7XG4gICAgaWYgKGwgaW5zdGFuY2VvZiBTdGFja2VkTGF5ZXIpIHtcbiAgICAgIGNvbnN0IGxheWVycyA9IGwubGF5ZXJzLm1hcChtbCA9PiB7XG4gICAgICAgIC8qKiBTZXQgYWxsIHRvIHZpc2libGUgYmVjYXVzZSB0aGUgdmlzaWJpbGl0eSBvZiBtZXJnZSBsYXllcnMgY2Fubm90IGJlIGNvbnRyb2xsZWQgbGF0ZXIgKi9cbiAgICAgICAgbWwudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIC8qKiBwb3B1cHMgYXJlIGdldCBmcm9tIHRoZSBvbExheWVyIGxhdGVyIHNvIGFkZCB0aGVtICovXG4gICAgICAgIG1sLnBvcHVwID0gbC5wb3B1cDtcbiAgICAgICAgLyoqIGV2ZW50cyBhcmUgZ2V0IGZyb20gdGhlIG9sTGF5ZXIgbGF0ZXIgc28gYWRkIHRoZW0gKi9cbiAgICAgICAgbWwuZXZlbnRzID0gbC5ldmVudHM7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZV9sYXllcnMobWwpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGJhc2VMYXllck9wdGlvbnMgPSB0aGlzLmNyZWF0ZU9sTGF5ZXJPcHRpb25zKGwsICdjdXN0b20nKTtcbiAgICAgIGNvbnN0IGdyb3VwT3B0aW9uczogb2xMYXllckdyb3VwT3B0aW9ucyA9IHtcbiAgICAgICAgbGF5ZXJzXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBsYXllckdyb3VwID0gbmV3IG9sTGF5ZXJHcm91cChPYmplY3QuYXNzaWduKGJhc2VMYXllck9wdGlvbnMsIGdyb3VwT3B0aW9ucykpO1xuICAgICAgcmV0dXJuIGxheWVyR3JvdXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKCdsYXllciBpcyBub3Qgb2YgdHlwZSBTdGFja2VkTGF5ZXIhJywgbCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSByZXNvbHV0aW9uc0Zyb21FeHRlbnQoZXh0ZW50LCBvcHRNYXhab29tOiBudW1iZXIsIHRpbGVTaXplOiBudW1iZXIpIHtcbiAgICBjb25zdCBtYXhab29tID0gb3B0TWF4Wm9vbTtcblxuICAgIGNvbnN0IGhlaWdodCA9IG9sR2V0SGVpZ2h0KGV4dGVudCk7XG4gICAgY29uc3Qgd2lkdGggPSBvbEdldFdpZHRoKGV4dGVudCk7XG5cbiAgICBjb25zdCBtYXhSZXNvbHV0aW9uID0gTWF0aC5tYXgod2lkdGggLyB0aWxlU2l6ZSwgaGVpZ2h0IC8gdGlsZVNpemUpO1xuXG4gICAgY29uc3QgbGVuZ3RoID0gbWF4Wm9vbSArIDE7XG4gICAgY29uc3QgcmVzb2x1dGlvbnMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCB6ID0gMDsgeiA8IGxlbmd0aDsgKyt6KSB7XG4gICAgICByZXNvbHV0aW9uc1t6XSA9IG1heFJlc29sdXRpb24gLyBNYXRoLnBvdygyLCB6KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc29sdXRpb25zO1xuICB9XG5cbiAgcHJpdmF0ZSBtYXRyaXhJZHNGcm9tUmVzb2x1dGlvbnMocmVzb2x1dGlvbkxldmVsczogbnVtYmVyLCBtYXRyaXhJZFByZWZpeD86IHN0cmluZykge1xuICAgIHJldHVybiBBcnJheS5mcm9tKEFycmF5KHJlc29sdXRpb25MZXZlbHMpLmtleXMoKSkubWFwKGwgPT4ge1xuICAgICAgaWYgKG1hdHJpeElkUHJlZml4KSB7XG4gICAgICAgIHJldHVybiBgJHttYXRyaXhJZFByZWZpeH06JHtsfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRUaWxlR3JpZDxUPih0eXBlOiAnd210cycgfCAnZGVmYXVsdCcgPSAnZGVmYXVsdCcsIHJlc29sdXRpb25MZXZlbHM/OiBudW1iZXIsIHRpbGVTaXplPzogbnVtYmVyLCBtYXRyaXhJZFByZWZpeD86IHN0cmluZywgcmVzb2x1dGlvbnM/OiBBcnJheTxzdHJpbmcgfCBudW1iZXI+LCBtYXRyaXhJZHM/OiBBcnJheTxzdHJpbmcgfCBudW1iZXI+KTogVCB7XG4gICAgY29uc3QgbmV3UmVzb2x1dGlvbkxldmVscyA9IHJlc29sdXRpb25MZXZlbHMgfHwgREVGQVVMVF9NQVhfWk9PTTtcbiAgICBjb25zdCBuZXdUaWxlU2l6ZSA9IHRpbGVTaXplIHx8IERFRkFVTFRfVElMRV9TSVpFO1xuICAgIGNvbnN0IG5ld01hdHJpeElkUHJlZml4ID0gbWF0cml4SWRQcmVmaXggfHwgJyc7XG5cbiAgICBjb25zdCBwcm9qZWN0aW9uRXh0ZW50ID0gdGhpcy5nZXRQcm9qZWN0aW9uKCkuZ2V0RXh0ZW50KCk7XG4gICAgY29uc3QgZGVmYXVsdFJlc29sdXRpb25zID0gdGhpcy5yZXNvbHV0aW9uc0Zyb21FeHRlbnQocHJvamVjdGlvbkV4dGVudCwgbmV3UmVzb2x1dGlvbkxldmVscywgbmV3VGlsZVNpemUpO1xuICAgIGNvbnN0IGRlZmF1bHRNYXRyaXhJZHMgPSB0aGlzLm1hdHJpeElkc0Zyb21SZXNvbHV0aW9ucyhkZWZhdWx0UmVzb2x1dGlvbnMubGVuZ3RoLCBuZXdNYXRyaXhJZFByZWZpeCk7XG4gICAgLyoqIGhvdyB0byBnZW5lcmF0ZSBtYXRyaXggaWRzIGlzIG5vdCBpbiB0aGUgd21zIEdldENhcGFiaWxpdGllcyA/PyAqL1xuXG4gICAgY29uc3QgdGlsZUdyaWRPcHRpb25zOiBhbnkgPSB7XG4gICAgICBleHRlbnQ6IHByb2plY3Rpb25FeHRlbnQsXG4gICAgICBvcmlnaW46IG9sR2V0VG9wTGVmdChwcm9qZWN0aW9uRXh0ZW50KSxcbiAgICAgIHJlc29sdXRpb25zOiByZXNvbHV0aW9ucyB8fCBkZWZhdWx0UmVzb2x1dGlvbnMsXG4gICAgICB0aWxlU2l6ZTogW25ld1RpbGVTaXplLCBuZXdUaWxlU2l6ZV1cbiAgICB9O1xuXG4gICAgaWYgKHR5cGUgPT09ICd3bXRzJykge1xuICAgICAgdGlsZUdyaWRPcHRpb25zLm1hdHJpeElkcyA9IG1hdHJpeElkcyB8fCBkZWZhdWx0TWF0cml4SWRzO1xuICAgICAgY29uc3QgZ3JpZCA9IG5ldyBvbFdNVFNUaWxlR3JpZCh0aWxlR3JpZE9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGdyaWQgYXMgdW5rbm93biBhcyBUO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2RlZmF1bHQnKSB7XG4gICAgICBjb25zdCBncmlkID0gbmV3IG9sVGlsZUdyaWQodGlsZUdyaWRPcHRpb25zKTtcbiAgICAgIHJldHVybiBncmlkIGFzIHVua25vd24gYXMgVDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGlzUG9wdXBPYmoobGF5ZXJwb3B1cDogTGF5ZXJbJ3BvcHVwJ10gfCBzdHJpbmcpOiBsYXllcnBvcHVwIGlzIHBvcHVwIHtcbiAgICByZXR1cm4gKGxheWVycG9wdXAgJiYgdHlwZW9mIGxheWVycG9wdXAgPT09ICdvYmplY3QnKSAmJiAhQXJyYXkuaXNBcnJheShsYXllcnBvcHVwKTtcbiAgfVxuXG4gIHByaXZhdGUgaXNQb3B1cE9iak1vdmUobGF5ZXJwb3B1cDogTGF5ZXJbJ3BvcHVwJ10pOiBsYXllcnBvcHVwIGlzIHBvcHVwIHtcbiAgICByZXR1cm4gKHRoaXMuaXNQb3B1cE9iaihsYXllcnBvcHVwKSAmJiBsYXllcnBvcHVwLmV2ZW50ID09PSAnbW92ZScpO1xuICB9XG5cbiAgcHJpdmF0ZSBpc1BvcHVwT2JqQ2xpY2sobGF5ZXJwb3B1cDogTGF5ZXJbJ3BvcHVwJ10pOiBsYXllcnBvcHVwIGlzIHBvcHVwIHtcbiAgICByZXR1cm4gKHRoaXMuaXNQb3B1cE9iaihsYXllcnBvcHVwKSAmJiBsYXllcnBvcHVwLmV2ZW50ID09PSAnY2xpY2snKTtcbiAgfVxuXG4gIHByaXZhdGUgaXNQb3B1cE9iakFycmF5KGxheWVycG9wdXA6IExheWVyWydwb3B1cCddKTogbGF5ZXJwb3B1cCBpcyBwb3B1cFtdIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShsYXllcnBvcHVwKSAmJiBsYXllcnBvcHVwLmxlbmd0aCAmJiB0aGlzLmlzUG9wdXBPYmoobGF5ZXJwb3B1cFswXSk7XG4gIH1cblxuICBwcml2YXRlIGlzUG9wdXBTdHJpbmdBcnJheShsYXllcnBvcHVwOiBMYXllclsncG9wdXAnXSk6IGxheWVycG9wdXAgaXMgc3RyaW5nW10ge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGxheWVycG9wdXApICYmIGxheWVycG9wdXAubGVuZ3RoICYmIHR5cGVvZiBsYXllcnBvcHVwWzBdID09PSAnc3RyaW5nJztcbiAgfVxuXG4gIHByaXZhdGUgZXZlbnRJc0Jyb3dzZXJFdmVudChwb3B1cEV2dDogcG9wdXBbJ2V2ZW50J10sIGV2dDogb2xNYXBCcm93c2VyRXZlbnQ8UG9pbnRlckV2ZW50Pikge1xuICAgIGlmIChwb3B1cEV2dCA9PT0gJ21vdmUnICYmIGV2dC50eXBlID09PSAncG9pbnRlcm1vdmUnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHBvcHVwRXZ0ID09PSAnY2xpY2snICYmIGV2dC50eXBlID09PSAnY2xpY2snKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuXG5cbiAgLyoqIFVTRUQgaW4gbWFwLW9sLmNvbXBvbmVudCAqL1xuICAvKipcbiAgICogVE9ETzpcbiAgICogLSBjaGVjayB0aGUgcG9pbnRlciBldmVudFxuICAgKiAtIG9uIG1vdmUgZXZlbnQgc2V0IGN1cnNvciAtPiBkZXBlbmRzIG9uIHdoaWNoIGtpbmQgb2YgbGF5ZXI/P1xuICAgKiAgIGxheWVycyB3aXRoIGZlYXR1cmVzIGFuZCBvbmx5IGNvbG9yIHBpeGVsXG4gICAqXG4gICAqIC0gZm9yRWFjaEZlYXR1cmVBdFBpeGVsOiBEZXRlY3QgZmVhdHVyZXMgdGhhdCBpbnRlcnNlY3QgYSBwaXhlbCBvbiB0aGUgdmlld3BvcnRcbiAgICogICBWZWN0b3IgTGF5ZXJzPz8/XG4gICAqXG4gICAqIC0gZm9yRWFjaExheWVyQXRQaXhlbDogRGV0ZWN0IGxheWVycyB0aGF0IGhhdmUgYSBjb2xvciB2YWx1ZSBhdCBhIHBpeGVsIG9uIHRoZSB2aWV3cG9ydCAoZmFsc2UgcG9zaXRpdmVzIHVubGVzcyB0aGUgbWFwIGxheWVycyBoYXZlIGhhZCBkaWZmZXJlbnQgY2xhc3NOYW1lKVxuICAgKiAgIFJhc3RlciBMYXllcnM/Pz9cbiAgICovXG5cbiAgLyoqXG4gICAqICBsYXllcnNfb25fY2xpY2soKSBhbmQgbGF5ZXJzX29uX3BvaW50ZXJtb3ZlKCkgc2hvdWxkIGJlIHJlbW92ZWRcbiAgICogIHRoaXMgZmlsdGVyaW5nIG11c3QgYmUgZG9uZSBsYXRlclxuICAgKlxuICAgKiAgMS4gb24gYSBNYXAgZXZlbnQgRmlsdGVyIGlmIG1hcCBoYXMgbGF5ZXJzIG9uIHRoZSBwaXhlbFxuICAgKiAgZm9yRWFjaExheWVyQXRQaXhlbDogRGV0ZWN0IGxheWVycyB0aGF0IGhhdmUgYSBjb2xvciB2YWx1ZSBhdCBhIHBpeGVsIG9uIHRoZSB2aWV3cG9ydCAoZmFsc2UgcG9zaXRpdmVzIHVubGVzcyB0aGUgbWFwIGxheWVycyBoYXZlIGhhZCBkaWZmZXJlbnQgY2xhc3NOYW1lKVxuICAgKiAgY2hlY2sgbGF5ZXIgc291cmNlIGNyb3NzT3JpZ2luID0gYW5vbnltb3VzXG4gICAqXG4gICAqICAyLiBGaWx0ZXIgaWYgaXQgaXMgdGhlIHRvcCB2aXNpYmxlIGxheWVyIC0gc28gbm8gcG9wdXBzIGFyZSBzaG93biBmb3IgbGF5ZXJzIGJlbmVhdGggaHR0cHM6Ly9naXRodWIuY29tL2Rsci1lb2MvdWtpcy1mcm9udGVuZC1saWJyYXJpZXMvaXNzdWVzLzk0I2lzc3VlY29tbWVudC05MTY3NTk2MjhcbiAgICogIDMuIGNoZWNrIGlmIHRoZSB0b3AgdmlzaWJsZSBsYXllciBoYXMgYSBwb3B1cCBwcm9wZXJ0eVxuICAgKiAgNC4gRm9yIHRoaXMgTGF5ZXIgY2hhbmdlIHRoZSBjdXJzb3Igb24gZm9yRWFjaExheWVyQXRQaXhlbCAtPiBoaXRcbiAgICpcbiAgICogIDUuIERpZmZlcmVudGlhdGUgYmV0d2VlbiByYXN0ZXIgYW5kIHZlY3RvciB0byBnZXQgZmVhdHVyZXMgb3IgbGF5ZXIuY29sb3IgZm9yIHRoZSBwcm9wZXJ0aWVzIHBhc3NlZCB0byB0aGUgcG9wdXBcbiAgICogIEZvciBGZWF0dXJlcyBjaGFuZ2UgdGhlIGN1cnNvciBvbiBmb3JFYWNoRmVhdHVyZUF0UGl4ZWwgLT4gaGl0XG4gICAqXG4gICAqICA2LiBsaW1pdCBwcm9wZXJ0aWVzIGlmIHBvcHVwIHByb3BlcnR5IGlzOiBBcnJheTxzdHJpbmc+IHwgcG9wdXAgfCBwb3B1cFtdIC0+IHBvcHVwPy5maWx0ZXJrZXlzXG4gICAqICA3LiBvdmVyd3JpdGUgcHJvcGVydGllcyBpZiBwb3B1cCBwcm9wZXJ0eSBpczogcG9wdXAgfCBwb3B1cFtdXG4gICAqICA4LiBjaGVjayBmb3IgcG9wdXBGdW5jdGlvbiwgYXN5bmNQb3B1cCBhbmQgZHluYW1pY1BvcHVwXG4gICAqICA5LiB1c2UgYWRkUG9wdXAoKSBvciBhZGRQb3B1cE9iaigpXG4gICAqXG4gICAqICAxMC4gY2hlY2sgcG9wdXAgZXZlbnQgYW5kIGlmIG1vdmUgcG9wdXAgZXhpc3RzID0+IHJldXNlIG9sZCBwb3B1cFxuICAgKiAgMTEuIHJlbW92ZSBtb3ZlIHBvcHVwcyBpZiBkaWZmZXJlbnQgZXZlbnQgb3IgIXBvcHVwLmV2ZW50XG4gICAqICAxMi4gY3JlYXRlIG5ldyBwb3B1cCBpZiBub3QgMTAuIG9yIDExLlxuICAgKiAgMTMuIHByZXBhcmUgb2wgb3ZlcmxheW9wdGlvbnNcbiAgICogIDE0LiByZW1vdmUgRHluYW1pY1BvcHVwIGlmIGV4aXN0c1xuICAgKiAgMTUuIGNyZWF0ZVBvcHVwQ29udGFpbmVyXG4gICAqICAxNi4gc2V0IG9sIG92ZXJsYXkgYWRkRXZlbnQgYW5kIHR5cGUgPSBwb3B1cFxuICAgKiAgMTcuIGdldCBjb29yZGluYXRlIGZyb20gZ2VvbWV0cnkgb3IgbWFwLmV2ZW50XG4gICAqICAxOC4gc2V0IFBvc2l0aW9uIGFuZCBtYXAuYWRkT3ZlcmxheShvdmVybGF5KSBpZiBwb3B1cCBub3QgZXhpc3RzXG4gICAqL1xuICBwdWJsaWMgbGF5ZXJzT25NYXBFdmVudChldnQ6IG9sTWFwQnJvd3NlckV2ZW50PFBvaW50ZXJFdmVudD4pIHtcbiAgICBsZXQgbGF5ZXJIaXQgPSBmYWxzZTtcblxuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IGxheWVycyB0aGF0IGhhdmUgYSBjb2xvciB2YWx1ZSBhdCBhIHBpeGVsIG9uIHRoZSB2aWV3cG9ydCwgYW5kIGV4ZWN1dGUgYSBjYWxsYmFjayB3aXRoIGVhY2ggbWF0Y2hpbmcgbGF5ZXIuXG4gICAgICogTGF5ZXJzIGluY2x1ZGVkIGluIHRoZSBkZXRlY3Rpb24gY2FuIGJlIGNvbmZpZ3VyZWQgdGhyb3VnaCBvcHRfbGF5ZXJGaWx0ZXIuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIG1heSBnaXZlIGZhbHNlIHBvc2l0aXZlcyB1bmxlc3MgdGhlIG1hcCBsYXllcnMgaGF2ZSBoYWQgZGlmZmVyZW50ICpjbGFzc05hbWUqIHByb3BlcnRpZXMgYXNzaWduZWQgdG8gdGhlbS5cbiAgICAgKiBBbHNvIHRoZXJlIGNvdWxkIGJlIGNyb3NzLW9yaWdpbiBkYXRhLCBzbyBzZXQgY3Jvc3NPcmlnaW46ICdhbm9ueW1vdXMnIGZvciBsYXllcnMgd2hlcmUgeW91IHdhbnQgZ2V0IHBpeGVsIGRhdGEhIVxuICAgICAqL1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLm1hcC5mb3JFYWNoTGF5ZXJBdFBpeGVsKGV2dC5waXhlbCwgKGxheWVyLCBjb2xvcikgPT4ge1xuICAgICAgLyoqXG4gICAgICAgKiByZXR1cm4gdG8gc3RvcCBkZXRlY3Rpb24gYW5kIHVzZSB0aGUgdG9wIChmaXJzdCBkZXRlY3RlZCkgbGF5ZXJcbiAgICAgICAqIFRoaXMgaXMgZmFzdGVyIHRoYW4gcHVzaGluZyB0aGUgbGF5ZXJzIGludG8gYW4gYXJyYXkgYW5kIGl0ZXJhdGUgb3ZlciBpdC5cbiAgICAgICAqIEFuZCBub3JtYWxseSB0aGUgdXNlciBpcyBvbmx5IGludGVyZXN0ZWQgaW4gdGhlIHRvcCBMYXllci4gSWYgaXQgaXMgc3RpbGwgbmVjZXNzYXJ5IHRvIGRldGVjdCBzZXZlcmFsIGxheWVycyBhdCB0aGUgc2FtZSB0aW1lLCB0aGVuIHVzZSBhIG5ldyBmdW5jdGlvbiBmb3IgbWFwLm9uKClcbiAgICAgICAqL1xuICAgICAgcmV0dXJuIHsgbGF5ZXIsIGNvbG9yIH07XG4gICAgfSwge1xuICAgICAgbGF5ZXJGaWx0ZXI6IHRoaXMuZmlsdGVyTGF5ZXJOb1BvcHVwXG4gICAgfSk7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIC8qKlxuICAgICAgICogb25seSBzaG93IGZvciB0b3AgbGF5ZXIgYW5kIGlmIHRvcCBsYXllciBoYXMgcG9wdXBcbiAgICAgICAqL1xuICAgICAgY29uc3QgaGFzUG9wdXA6IExheWVyWydwb3B1cCddID0gKGl0ZW0ubGF5ZXIuZ2V0KCdwb3B1cCcpKTtcbiAgICAgIGlmIChoYXNQb3B1cCkge1xuICAgICAgICAvKiogY2hlY2sgaWYgY3Vyc29yIHdhcyBzZXQgKHdlIG5lZWQgdGhpcyBvbmx5IG9uIG1vdmU/KSAqL1xuICAgICAgICB0aGlzLmhpdExheWVyQ3VyciA9IGl0ZW0ubGF5ZXIuZ2V0KCdpZCcpO1xuICAgICAgICBpZiAoIXRoaXMuaGl0TGF5ZXJQcmV2KSB7XG4gICAgICAgICAgdGhpcy5oaXRMYXllclByZXYgPSB0aGlzLmhpdExheWVyQ3VycjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBzZXQgY3Vyc29yIGZvciBMYXllcnMgd2l0aCBhIGNvbG9yIHZhbHVlICovXG4gICAgICAgIGlmIChpdGVtLmNvbG9yKSB7XG4gICAgICAgICAgbGF5ZXJIaXQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIHJlbW92ZSBjdXJzb3IgYW5kIG1vdmUtcG9wdXBzIG9uIGxheWVyIGNoYW5nZSAqL1xuICAgICAgICBpZiAodGhpcy5oaXRMYXllclByZXYgJiYgdGhpcy5oaXRMYXllclByZXYgIT09IHRoaXMuaGl0TGF5ZXJDdXJyKSB7XG4gICAgICAgICAgbGF5ZXJIaXQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmhpdExheWVyUHJldiA9IHRoaXMuaGl0TGF5ZXJDdXJyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVzZUV2ZW50ID0gdGhpcy50b3BMYXllckNoZWNrRXZlbnQoZXZ0LCBoYXNQb3B1cCk7XG4gICAgICAgIGlmICh1c2VFdmVudCkge1xuICAgICAgICAgIHRoaXMubGF5ZXJPbkV2ZW50KGV2dCwgaXRlbS5sYXllciwgaXRlbS5jb2xvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobGF5ZXJIaXQpIHtcbiAgICAgIHRoaXMubWFwLmdldFRhcmdldEVsZW1lbnQoKS5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQWxsUG9wdXBzKChpdGVtKSA9PiB7XG4gICAgICAgIHJldHVybiBpdGVtLmdldCgnYWRkRXZlbnQnKSA9PT0gJ3BvaW50ZXJtb3ZlJztcbiAgICAgIH0pO1xuICAgICAgdGhpcy5tYXAuZ2V0VGFyZ2V0RWxlbWVudCgpLnN0eWxlLmN1cnNvciA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUbyBmaWx0ZXJlZCBvdXQgbGF5ZXJzIGFuZCBzaG93IHRoZSBwb3B1cCBiZW5lYXRoIGUuZy4gdGV4dCBvdmVybGF5c1xuICAgKiBpbiBtYXAuZm9yRWFjaExheWVyQXRQaXhlbCBmb3IgcmFzdGVyIGFuZCBtYXAuZm9yRWFjaEZlYXR1cmVBdFBpeGVsIGZvciB2ZWN0b3JcbiAgICovXG4gIHByaXZhdGUgZmlsdGVyTGF5ZXJOb1BvcHVwID0gKGw6IG9sTGF5ZXI8b2xTb3VyY2U+KSA9PiB7XG4gICAgY29uc3QgcG9wdXA6IExheWVyWydwb3B1cCddID0gKGwuZ2V0KCdwb3B1cCcpKTtcbiAgICBsZXQgc2hvdWxkTm90RmlsdGVyTGF5ZXIgPSB0cnVlO1xuICAgIGlmIChwb3B1cCAmJiB0aGlzLmlzUG9wdXBPYmoocG9wdXApKSB7XG4gICAgICBpZiAocG9wdXAuZmlsdGVyTGF5ZXIgPT09IHRydWUpIHtcbiAgICAgICAgc2hvdWxkTm90RmlsdGVyTGF5ZXIgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNob3VsZE5vdEZpbHRlckxheWVyO1xuICB9XG5cbiAgcHJpdmF0ZSB0b3BMYXllckNoZWNrRXZlbnQoZXZ0OiBvbE1hcEJyb3dzZXJFdmVudDxQb2ludGVyRXZlbnQ+LCBwb3B1cDogTGF5ZXJbJ3BvcHVwJ10pIHtcbiAgICBsZXQgdXNlRXZlbnQ6ICdjbGljaycgfCAnbW92ZScgPSBudWxsO1xuICAgIGNvbnN0IGNsaWNrT3JNb3ZlID0gKGV2dDogb2xNYXBCcm93c2VyRXZlbnQ8UG9pbnRlckV2ZW50PiwgcG9wdXA6IHBvcHVwKSA9PiB7XG4gICAgICBpZiAocG9wdXAuZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRJc0Jyb3dzZXJFdmVudChwb3B1cC5ldmVudCwgZXZ0KSAmJiB0aGlzLmlzUG9wdXBPYmpDbGljayhwb3B1cCkpIHtcbiAgICAgICAgICB1c2VFdmVudCA9ICdjbGljayc7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5ldmVudElzQnJvd3NlckV2ZW50KHBvcHVwLmV2ZW50LCBldnQpICYmIHRoaXMuaXNQb3B1cE9iak1vdmUocG9wdXApKSB7XG4gICAgICAgICAgdXNlRXZlbnQgPSAnbW92ZSc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qKiBvbmx5IHNob3cgcG9wdXBzIHdpdGhvdXQgYW4gZXZlbnQgZm9yIGJyb3dzZXIgY2xpY2sgICovXG4gICAgICAgIGlmIChldnQudHlwZSA9PT0gJ2NsaWNrJykge1xuICAgICAgICAgIHVzZUV2ZW50ID0gJ2NsaWNrJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBjaGVjayBldmVudCBpcyBicm93c2VyIGV2ZW50XG4gICAgaWYgKHR5cGVvZiBwb3B1cCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBpZiAocG9wdXAgPT09IHRydWUpIHtcbiAgICAgICAgLyoqIG9ubHkgc2hvdyBwb3B1cHMgd2l0aG91dCBhbiBldmVudCBmb3IgYnJvd3NlciBjbGljayAgKi9cbiAgICAgICAgaWYgKGV2dC50eXBlID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgdXNlRXZlbnQgPSAnY2xpY2snO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzUG9wdXBTdHJpbmdBcnJheShwb3B1cCkpIHtcbiAgICAgIC8qKiBvbmx5IHNob3cgcG9wdXBzIHdpdGhvdXQgYW4gZXZlbnQgZm9yIGJyb3dzZXIgY2xpY2sgICovXG4gICAgICBpZiAoZXZ0LnR5cGUgPT09ICdjbGljaycpIHtcbiAgICAgICAgdXNlRXZlbnQgPSAnY2xpY2snO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiogcG9wdXAgaXMgIHBvcHVwIHwgcG9wdXBbXSAqL1xuICAgICAgaWYgKHRoaXMuaXNQb3B1cE9iakFycmF5KHBvcHVwKSkge1xuICAgICAgICBwb3B1cC5tYXAocCA9PiB7XG4gICAgICAgICAgY2xpY2tPck1vdmUoZXZ0LCBwKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGlja09yTW92ZShldnQsIHBvcHVwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdXNlRXZlbnQ7XG4gIH1cblxuICAvKipcbiAgICogaHR0cHM6Ly9vcGVubGF5ZXJzLm9yZy9lbi9sYXRlc3QvYXBpZG9jL21vZHVsZS1vbF9sYXllcl9MYXllci1MYXllci5odG1sI1N1YmNsYXNzZXNcbiAgICovXG4gIHByaXZhdGUgY2hlY2tJc1Jhc3RlcihsYXllcjogb2xMYXllcjxhbnk+KTogbGF5ZXIgaXMgb2xCYXNlSW1hZ2VMYXllcjxvbEltYWdlU291cmNlLCBDYW52YXNJbWFnZUxheWVyUmVuZGVyZXI+IHwgb2xCYXNlVGlsZUxheWVyPG9sVGlsZVNvdXJjZSwgQ2FudmFzVGlsZUxheWVyUmVuZGVyZXI+IHtcbiAgICBpZiAobGF5ZXIgaW5zdGFuY2VvZiBvbEJhc2VJbWFnZUxheWVyIHx8IGxheWVyIGluc3RhbmNlb2Ygb2xCYXNlVGlsZUxheWVyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBodHRwczovL29wZW5sYXllcnMub3JnL2VuL2xhdGVzdC9hcGlkb2MvbW9kdWxlLW9sX2xheWVyX0xheWVyLUxheWVyLmh0bWwjU3ViY2xhc3Nlc1xuICAgKi9cbiAgcHJpdmF0ZSBjaGVja0lzVmVjdG9yKGxheWVyOiBvbExheWVyPGFueT4pOiBsYXllciBpcyBvbEJhc2VWZWN0b3JMYXllcjxvbFZlY3RvclNvdXJjZTxhbnk+LCBDYW52YXNWZWN0b3JMYXllclJlbmRlcmVyPiB7XG4gICAgaWYgKGxheWVyIGluc3RhbmNlb2Ygb2xCYXNlVmVjdG9yTGF5ZXIgJiYgIXRoaXMuY2hlY2tJc1Jhc3RlcihsYXllcikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGxheWVyT25FdmVudChldnQ6IG9sTWFwQnJvd3NlckV2ZW50PFBvaW50ZXJFdmVudD4sIGxheWVyOiBvbExheWVyPGFueT4sIGNvbG9yPzogVWludDhDbGFtcGVkQXJyYXkgfCBVaW50OEFycmF5KSB7XG4gICAgaWYgKHRoaXMuY2hlY2tJc1Jhc3RlcihsYXllcikpIHtcbiAgICAgIHRoaXMucmFzdGVyT25FdmVudChldnQsIGxheWVyLCBjb2xvcik7XG4gICAgfSBlbHNlIGlmICh0aGlzLmNoZWNrSXNWZWN0b3IobGF5ZXIpKSB7XG4gICAgICB0aGlzLnZlY3Rvck9uRXZlbnQoZXZ0KTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgdmVjdG9yT25FdmVudChldnQ6IG9sTWFwQnJvd3NlckV2ZW50PFBvaW50ZXJFdmVudD4pIHtcbiAgICBsZXQgZmVhdHVyZUhpdCA9IGZhbHNlO1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLm1hcC5mb3JFYWNoRmVhdHVyZUF0UGl4ZWwoZXZ0LnBpeGVsLCAoZmVhdHVyZSwgbGF5ZXIpID0+IHtcbiAgICAgIC8qKiBzZXQgY3Vyc29yIGZvciBmZWF0dXJlcyB3aXRoIGEgY29sb3IgdmFsdWUgKi9cbiAgICAgIGZlYXR1cmVIaXQgPSB0cnVlO1xuXG4gICAgICAvKipcbiAgICAgICAqIHJldHVybiB0byBzdG9wIGRldGVjdGlvbiBhbmQgdXNlIHRoZSB0b3AgKGZpcnN0IGRldGVjdGVkKSBmZWF0dXJlXG4gICAgICAgKiBUaGlzIGlzIGZhc3RlciB0aGFuIHB1c2hpbmcgdGhlIGZlYXR1cmUgaW50byBhbiBhcnJheSBhbmQgaXRlcmF0ZSBvdmVyIGl0LlxuICAgICAgICovXG4gICAgICByZXR1cm4geyBmZWF0dXJlLCBsYXllciB9O1xuICAgIH0sIHtcbiAgICAgIGxheWVyRmlsdGVyOiAobGF5ZXIpID0+IHtcbiAgICAgICAgbGV0IHNob3VsZE5vdEZpbHRlckxheWVyID0gdHJ1ZTtcbiAgICAgICAgaWYgKGxheWVyIGluc3RhbmNlb2Ygb2xCYXNlVmVjdG9yTGF5ZXIpIHtcbiAgICAgICAgICBjb25zdCBvbFNvdXJjZTogb2xDbHVzdGVyIHwgb2xWZWN0b3JTb3VyY2U8YW55PiB8IG9sVmVjdG9yVGlsZSA9IGxheWVyLmdldFNvdXJjZSgpO1xuICAgICAgICAgIGlmIChvbFNvdXJjZSBpbnN0YW5jZW9mIG9sQ2x1c3Rlcikge1xuICAgICAgICAgICAgc2hvdWxkTm90RmlsdGVyTGF5ZXIgPSAob2xTb3VyY2UgYXMgYW55KS5nZXRTb3VyY2UoKSBpbnN0YW5jZW9mIG9sVmVjdG9yU291cmNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaG91bGROb3RGaWx0ZXJMYXllciA9IG9sU291cmNlIGluc3RhbmNlb2Ygb2xWZWN0b3JTb3VyY2UgfHwgb2xTb3VyY2UgaW5zdGFuY2VvZiBvbFZlY3RvclRpbGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZmlsdGVyID0gdGhpcy5maWx0ZXJMYXllck5vUG9wdXAobGF5ZXIpO1xuICAgICAgICBpZiAoZmlsdGVyID09PSBmYWxzZSkge1xuICAgICAgICAgIHNob3VsZE5vdEZpbHRlckxheWVyID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogZml4IGZvciBodHRwczovL2dpdGh1Yi5jb20vb3BlbmxheWVycy9vcGVubGF5ZXJzL2lzc3Vlcy8xMjg4NiAqL1xuICAgICAgICBjb25zdCBsYXllckV4dGVudCA9IGxheWVyLmdldEV4dGVudCgpO1xuICAgICAgICBpZiAobGF5ZXJFeHRlbnQpIHtcbiAgICAgICAgICBjb25zdCBwaXhlbENvb3JkaW5hdGUgPSB0aGlzLm1hcC5nZXRDb29yZGluYXRlRnJvbVBpeGVsKGV2dC5waXhlbCk7XG4gICAgICAgICAgaWYgKCFvbENvbnRhaW5zQ29vcmRpbmF0ZShsYXllckV4dGVudCwgcGl4ZWxDb29yZGluYXRlKSkge1xuICAgICAgICAgICAgc2hvdWxkTm90RmlsdGVyTGF5ZXIgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2hvdWxkTm90RmlsdGVyTGF5ZXI7XG4gICAgICB9LFxuICAgICAgaGl0VG9sZXJhbmNlOiB0aGlzLmhpdFRvbGVyYW5jZVxuICAgIH0pO1xuXG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIC8qKlxuICAgICAgICogb25seSBzaG93IGZvciB0b3AgZmVhdHVyZSBhbmQgaWYgdG9wIGxheWVyIGhhcyBwb3B1cFxuICAgICAgICovXG4gICAgICBjb25zdCBoYXNQb3B1cDogTGF5ZXJbJ3BvcHVwJ10gPSAoaXRlbS5sYXllci5nZXQoJ3BvcHVwJykpO1xuICAgICAgaWYgKGhhc1BvcHVwKSB7XG4gICAgICAgIGNvbnN0IGxheWVyID0gaXRlbS5sYXllcjtcbiAgICAgICAgY29uc3QgZmVhdHVyZSA9IGl0ZW0uZmVhdHVyZTtcblxuICAgICAgICBsZXQgcHJvcGVydGllczogYW55ID0ge307XG5cbiAgICAgICAgY29uc3QgY2hpbGRGZWF0dXJlcyA9IGZlYXR1cmUuZ2V0UHJvcGVydGllcygpLmZlYXR1cmVzO1xuICAgICAgICBpZiAoY2hpbGRGZWF0dXJlcyAmJiBjaGlsZEZlYXR1cmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGNvbnN0IGNoaWxkRmVhdHVyZSA9IGNoaWxkRmVhdHVyZXNbMF07XG4gICAgICAgICAgcHJvcGVydGllcyA9IGNoaWxkRmVhdHVyZS5nZXRQcm9wZXJ0aWVzKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hpbGRGZWF0dXJlcyAmJiBjaGlsZEZlYXR1cmVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiB6b29tIHRvIGNsdXN0ZXIgb24gY2xpY2tcbiAgICAgICAgICAgKiBvciBjaGVjayBmb3IgbGF5ZXJwb3B1cC5ldmVudCAhPT0gbW92ZVxuICAgICAgICAgICAqL1xuICAgICAgICAgIGlmIChldnQudHlwZSA9PT0gJ2NsaWNrJykge1xuICAgICAgICAgICAgY29uc3QgZXh0ZW50ID0gdGhpcy5nZXRGZWF0dXJlc0V4dGVudChmZWF0dXJlLmdldFByb3BlcnRpZXMoKS5mZWF0dXJlcyk7XG4gICAgICAgICAgICB0aGlzLnNldEV4dGVudChleHRlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdHlwZSBubyBjbHVzdGVyXG4gICAgICAgICAgcHJvcGVydGllcyA9IGZlYXR1cmUuZ2V0UHJvcGVydGllcygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlcGFyZUFkZFBvcHVwKHByb3BlcnRpZXMsIGxheWVyLCBmZWF0dXJlLCBldnQsIGhhc1BvcHVwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZmVhdHVyZUhpdCkge1xuICAgICAgdGhpcy5tYXAuZ2V0VGFyZ2V0RWxlbWVudCgpLnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tYXAuZ2V0VGFyZ2V0RWxlbWVudCgpLnN0eWxlLmN1cnNvciA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByYXN0ZXJPbkV2ZW50KGV2dDogb2xNYXBCcm93c2VyRXZlbnQ8UG9pbnRlckV2ZW50PiwgbGF5ZXI6IG9sTGF5ZXI8YW55PiwgY29sb3I/OiBVaW50OENsYW1wZWRBcnJheSB8IFVpbnQ4QXJyYXkpIHtcbiAgICBjb25zdCBsYXllcnBvcHVwOiBMYXllclsncG9wdXAnXSA9IGxheWVyLmdldCgncG9wdXAnKTtcbiAgICBsZXQgcHJvcGVydGllczogYW55ID0ge307XG5cbiAgICBpZiAobGF5ZXJwb3B1cCkge1xuICAgICAgcHJvcGVydGllcyA9IGxheWVyLmdldFByb3BlcnRpZXMoKTtcbiAgICAgIHByb3BlcnRpZXMuZXZ0ID0gZXZ0O1xuICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgIHByb3BlcnRpZXMuY29sb3IgPSBjb2xvcjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcmVwYXJlQWRkUG9wdXAocHJvcGVydGllcywgbGF5ZXIsIG51bGwsIGV2dCwgbGF5ZXJwb3B1cCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwcmVwYXJlQWRkUG9wdXAobGF5ZXJQcm9wZXJ0aWVzOiBhbnksIGxheWVyOiBvbExheWVyPGFueT4sIGZlYXR1cmU6IG9sRmVhdHVyZTxhbnk+IHwgb2xSZW5kZXJGZWF0dXJlLCBldnQ6IG9sTWFwQnJvd3NlckV2ZW50PFBvaW50ZXJFdmVudD4sIGxheWVycG9wdXA6IExheWVyWydwb3B1cCddKSB7XG4gICAgY29uc3QgYXJnczogSVBvcHVwQXJncyA9IHtcbiAgICAgIG1vZGVsTmFtZTogbGF5ZXJQcm9wZXJ0aWVzLmlkLFxuICAgICAgcHJvcGVydGllczogbGF5ZXJQcm9wZXJ0aWVzLFxuICAgICAgbGF5ZXIsXG4gICAgICBmZWF0dXJlLFxuICAgICAgZXZlbnQ6IGV2dFxuICAgIH07XG5cbiAgICBsZXQgcG9wdXBQcm9wZXJ0aWVzID0gT2JqZWN0LmFzc2lnbih7fSwgbGF5ZXJQcm9wZXJ0aWVzKTtcbiAgICBpZiAocG9wdXBQcm9wZXJ0aWVzLmdlb21ldHJ5KSB7XG4gICAgICBkZWxldGUgcG9wdXBQcm9wZXJ0aWVzLmdlb21ldHJ5O1xuICAgIH1cblxuICAgIGNvbnN0IGxpbWl0UG9wdXBPYmpQcm9wZXJ0aWVzID0gKHBvcHVwT2JqOiBwb3B1cCkgPT4ge1xuICAgICAgaWYgKHBvcHVwT2JqICYmIHBvcHVwT2JqLmZpbHRlcmtleXMpIHtcbiAgICAgICAgcG9wdXBQcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMocG9wdXBQcm9wZXJ0aWVzKVxuICAgICAgICAgIC5maWx0ZXIoa2V5ID0+IHBvcHVwT2JqLmZpbHRlcmtleXMuaW5jbHVkZXMoa2V5KSlcbiAgICAgICAgICAucmVkdWNlKChvYmosIGtleSkgPT4ge1xuICAgICAgICAgICAgb2JqW2tleV0gPSBwb3B1cFByb3BlcnRpZXNba2V5XTtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgfSwge30pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBQb3B1cCBpcyBhcnJheSAtIGxpbWl0IHByb3BlcnRpZXMgKi9cbiAgICBpZiAodGhpcy5pc1BvcHVwU3RyaW5nQXJyYXkobGF5ZXJwb3B1cCkpIHtcbiAgICAgIHBvcHVwUHJvcGVydGllcyA9IE9iamVjdC5rZXlzKHBvcHVwUHJvcGVydGllcylcbiAgICAgICAgLmZpbHRlcihrZXkgPT4gbGF5ZXJwb3B1cC5pbmNsdWRlcyhrZXkpKVxuICAgICAgICAucmVkdWNlKChvYmosIGtleSkgPT4ge1xuICAgICAgICAgIG9ialtrZXldID0gcG9wdXBQcm9wZXJ0aWVzW2tleV07XG4gICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfSwge30pO1xuICAgIH1cbiAgICAvKiogUG9wdXAgaXMgYXJyYXkgb2YgcG9wdXBPYmogLSBsaW1pdCBwcm9wZXJ0aWVzICovXG4gICAgZWxzZSBpZiAodGhpcy5pc1BvcHVwT2JqQXJyYXkobGF5ZXJwb3B1cCkpIHtcbiAgICAgIC8vIGlzIHRoZSBmaXJzdCBwb3B1cE9iaiBpbiB0aGUgYXJyYXkgd2l0aCB0aGUgc2FtZSBldmVudCBhcyBldnQudHlwZVxuICAgICAgY29uc3QgcG9wdXBPYmogPSBsYXllcnBvcHVwLmZpbmQocCA9PiB0aGlzLmV2ZW50SXNCcm93c2VyRXZlbnQocC5ldmVudCwgZXZ0KSk7XG4gICAgICBsaW1pdFBvcHVwT2JqUHJvcGVydGllcyhwb3B1cE9iaik7XG4gICAgfVxuICAgIC8qKiBQb3B1cCBpcyBvYmplY3QgLSBsaW1pdCBwcm9wZXJ0aWVzICovXG4gICAgZWxzZSBpZiAodGhpcy5pc1BvcHVwT2JqKGxheWVycG9wdXApKSB7XG4gICAgICBsaW1pdFBvcHVwT2JqUHJvcGVydGllcyhsYXllcnBvcHVwKTtcbiAgICB9XG5cblxuICAgIGNvbnN0IG92ZXJ3cml0ZVBvcHVwID0gKHBvcHVwT2JqOiBwb3B1cCkgPT4ge1xuICAgICAgLyoqIG92ZXJ3cml0ZSB0aGUga2V5cyBvZiB0aGUgbGF5ZXIgcHJvcGVydGllcyAqL1xuICAgICAgaWYgKHBvcHVwT2JqLnByb3BlcnRpZXMpIHtcbiAgICAgICAgY29uc3QgdXNlZFByb3BlcnRpZXMgPSBPYmplY3Qua2V5cyhwb3B1cE9iai5wcm9wZXJ0aWVzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodXNlZFByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgcG9wdXBQcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMocG9wdXBQcm9wZXJ0aWVzKVxuICAgICAgICAgICAgLyogLmZpbHRlcihrZXkgPT4gdXNlZFByb3BlcnRpZXMuaW5jbHVkZXMoa2V5KSkgKi9cbiAgICAgICAgICAgIC5yZWR1Y2UoKG9iaiwga2V5KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IG5ld0tleSA9IHBvcHVwT2JqLnByb3BlcnRpZXNba2V5XTtcbiAgICAgICAgICAgICAgaWYgKG5ld0tleSkge1xuICAgICAgICAgICAgICAgIG9ialtuZXdLZXldID0gcG9wdXBQcm9wZXJ0aWVzW2tleV07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb2JqW2tleV0gPSBwb3B1cFByb3BlcnRpZXNba2V5XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG5cblxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBvdmVyd3JpdGUgYW5kIHVzIHBvcHVwRnVuY3Rpb24gb3IgZHluYW1pY1BvcHVwICovXG4gICAgaWYgKHRoaXMuaXNQb3B1cE9iakFycmF5KGxheWVycG9wdXApKSB7XG4gICAgICBsYXllcnBvcHVwLmZvckVhY2gocCA9PiB7XG4gICAgICAgIGlmICh0aGlzLmV2ZW50SXNCcm93c2VyRXZlbnQocC5ldmVudCwgZXZ0KSkge1xuICAgICAgICAgIG92ZXJ3cml0ZVBvcHVwKHApO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0gZWxzZSBpZiAodGhpcy5pc1BvcHVwT2JqKGxheWVycG9wdXApKSB7XG4gICAgICBvdmVyd3JpdGVQb3B1cChsYXllcnBvcHVwKTtcbiAgICB9XG5cbiAgICBjb25zdCBhZGRQb3B1cE9iaiA9IChwb3B1cE9iajogcG9wdXApID0+IHtcbiAgICAgIC8qKiBhc3luYyBmdW5jdGlvbiB3aGVyZSB5b3UgY2FuIHBhc3RlIGEgaHRtbCBzdHJpbmcgdG8gdGhlIGNhbGxiYWNrICovXG4gICAgICBpZiAoJ2FzeW5jUG9wdXAnIGluIHBvcHVwT2JqKSB7XG4gICAgICAgIHBvcHVwT2JqLmFzeW5jUG9wdXAocG9wdXBQcm9wZXJ0aWVzLCAoaHRtbCkgPT4ge1xuICAgICAgICAgIHRoaXMuYWRkUG9wdXAoYXJncywgbnVsbCwgaHRtbCwgcG9wdXBPYmouZXZlbnQsIHBvcHVwT2JqLnNpbmdsZSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvKiogYWRkIGV2ZW50IGlmIHBvcHVwIG9iamVjdCAqL1xuICAgICAgfSBlbHNlIHtcblxuICAgICAgICAvKiogYWRqdXN0IGFyZ3MgaWYgcG9wdXBGdW5jdGlvbiBvciBkeW5hbWljUG9wdXAqL1xuICAgICAgICBpZiAocG9wdXBPYmoucG9wdXBGdW5jdGlvbikge1xuICAgICAgICAgIGFyZ3MucG9wdXBGbiA9IHBvcHVwT2JqLnBvcHVwRnVuY3Rpb247IC8vVGhpcyBjb3VsZCBiZSBkb25lIGluIGNyZWF0ZVBvcHVwQ29udGFpbmVyKClcbiAgICAgICAgfSBlbHNlIGlmIChwb3B1cE9iai5keW5hbWljUG9wdXApIHtcbiAgICAgICAgICBhcmdzLmR5bmFtaWNQb3B1cCA9IHBvcHVwT2JqLmR5bmFtaWNQb3B1cDsgLy8gVGhpcyBjb3VsZCBiZSBkb25lIGluIGNyZWF0ZVBvcHVwQ29udGFpbmVyKClcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYWRkUG9wdXAoYXJncywgcG9wdXBQcm9wZXJ0aWVzLCBudWxsLCBwb3B1cE9iai5ldmVudCwgcG9wdXBPYmouc2luZ2xlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogcG9wdXAgaXMgYm9vbGVhbiBvciBzdHJpbmcgYXJyYXkgKi9cbiAgICBpZiAodHlwZW9mIGxheWVycG9wdXAgPT09ICdib29sZWFuJyB8fCB0aGlzLmlzUG9wdXBTdHJpbmdBcnJheShsYXllcnBvcHVwKSkge1xuICAgICAgdGhpcy5hZGRQb3B1cChhcmdzLCBwb3B1cFByb3BlcnRpZXMsIG51bGwpO1xuICAgIH1cbiAgICAvKiogcG9wdXAgYXJyYXkgb2YgcG9wdXBPYmogKi9cbiAgICBlbHNlIGlmICh0aGlzLmlzUG9wdXBPYmpBcnJheShsYXllcnBvcHVwKSkge1xuICAgICAgbGF5ZXJwb3B1cC5mb3JFYWNoKHAgPT4ge1xuICAgICAgICAvLyBmaWx0ZXIgdGhhdCBicm93c2VyIGV2ZW50IGFuZCBwb3B1cCBldmVudCBhcmUgdGhlIHNhbWVcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRJc0Jyb3dzZXJFdmVudChwLmV2ZW50LCBldnQpKSB7XG4gICAgICAgICAgYWRkUG9wdXBPYmoocCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogcG9wdXAgaXMgYSBwb3B1cE9iaiAqL1xuICAgIGVsc2UgaWYgKGxheWVycG9wdXApIHtcbiAgICAgIGFkZFBvcHVwT2JqKGxheWVycG9wdXApO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IG92ZXJsYXBwaW5nIGxheWVycyAtIG1vdmUgcG9wdXAgaXMgYWRkZWQgb24gY2xpY2sgPz8/XG4gIHB1YmxpYyBhZGRQb3B1cChhcmdzOiBJUG9wdXBBcmdzLCBwb3B1cE9iajogYW55LCBodG1sPzogc3RyaW5nLCBldmVudD86ICdjbGljaycgfCAnbW92ZScsIHJlbW92ZVBvcHVwcz86IGJvb2xlYW4pIHtcbiAgICBjb25zdCBsYXllcnBvcHVwOiBMYXllclsncG9wdXAnXSA9IGFyZ3MubGF5ZXIuZ2V0KCdwb3B1cCcpO1xuICAgIC8vIGNoZWNrIGlmIHBvcHVwIGlzIGFscmVhZHkgdGhlcmUgYW5kIGV2ZW50IGlzIG1vdmVcbiAgICBjb25zdCBsYXllcklEID0gYXJncy5sYXllci5nZXQoJ2lkJyk7XG4gICAgY29uc3QgbW92ZUlEID0gYHBvcHVwX21vdmVfSURgO1xuICAgIGNvbnN0IG1vdmVLZXlMYXllckZlYXR1cmUgPSAnbW92ZV9JRF9MX0YnO1xuICAgIGNvbnN0IG1vdmVQb3B1cCA9IHRoaXMuZ2V0UG9wdXBzKCkuZmluZChpdGVtID0+IGl0ZW0uZ2V0SWQoKSA9PT0gbW92ZUlEKTtcbiAgICBjb25zdCBicm93c2VyRXZlbnQgPSBhcmdzLmV2ZW50O1xuXG4gICAgbGV0IG1vdmVJRGxmID0gbnVsbDtcbiAgICBpZiAoZXZlbnQgPT09ICdtb3ZlJykge1xuICAgICAgLyoqIG9ubHkgb24gcmFzdGVyIGNvbG9yIGlzIGFkZGVkIC0gc2VlIHJhc3Rlck9uRXZlbnQoKSovXG4gICAgICBpZiAoYXJncy5wcm9wZXJ0aWVzPy5jb2xvcikge1xuICAgICAgICBtb3ZlSURsZiA9IGAke2xheWVySUR9OiR7YXJncy5wcm9wZXJ0aWVzPy5jb2xvci50b1N0cmluZygpfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYXJncy5mZWF0dXJlKSB7XG4gICAgICAgICAgbW92ZUlEbGYgPSBgJHtsYXllcklEfToke29sR2V0VWlkKGFyZ3MuZmVhdHVyZSl9YDtcbiAgICAgICAgfSBlbHNlIGlmIChhcmdzLmxheWVyKSB7XG4gICAgICAgICAgbW92ZUlEbGYgPSBgJHtsYXllcklEfToke29sR2V0VWlkKGFyZ3MubGF5ZXIpfWA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiBldmVudCBtb3ZlIGFuZCB0aGUgbWFwIGFscmVhZHkgaGFzIGEgT3ZlcmxheSBmb3IgbW92ZVxuICAgICAqIHRoZW4gb25seSBjcmVhdGUgbmV3IGh0bWwgY29udGFpbmVyIGFuZCBzZXQgdGhlIHBvc2l0aW9uXG4gICAgICovXG4gICAgaWYgKGV2ZW50ID09PSAnbW92ZScgJiYgYnJvd3NlckV2ZW50LnR5cGUgPT09ICdwb2ludGVybW92ZScgJiYgbW92ZVBvcHVwKSB7XG4gICAgICBsZXQgY29vcmRpbmF0ZTtcbiAgICAgIGlmIChhcmdzLnByb3BlcnRpZXMgJiYgYXJncy5wcm9wZXJ0aWVzLmdlb21ldHJ5ICYmIGFyZ3MucHJvcGVydGllcy5nZW9tZXRyeS5nZXRUeXBlKCkgPT09ICdQb2ludCcpIHtcbiAgICAgICAgY29vcmRpbmF0ZSA9IGFyZ3MucHJvcGVydGllcy5nZW9tZXRyeS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29vcmRpbmF0ZSA9IGJyb3dzZXJFdmVudC5jb29yZGluYXRlO1xuICAgICAgfVxuXG4gICAgICAvKiogY2hlY2sgaWYgbGF5ZXIgb3IgZmVhdHVyZSBjaGFuZ2VzLCB0aGVuIG9ubHkgY3JlYXRlIG5ldyBjb250YWluZXIgKi9cbiAgICAgIGlmIChtb3ZlSURsZiAhPT0gbW92ZVBvcHVwLmdldChtb3ZlS2V5TGF5ZXJGZWF0dXJlKSkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNyZWF0ZVBvcHVwQ29udGFpbmVyKG1vdmVQb3B1cCwgYXJncywgcG9wdXBPYmosIGh0bWwsIGV2ZW50KTtcbiAgICAgICAgbW92ZVBvcHVwLnNldEVsZW1lbnQoY29udGFpbmVyKTtcbiAgICAgIH1cblxuICAgICAgbW92ZVBvcHVwLnNldFBvc2l0aW9uKGNvb3JkaW5hdGUpO1xuICAgICAgLyoqIHVwZGF0ZSBtb3ZlUG9wdXAgdG8gYmUgcmVuZGVyZWQgb3ZlciB0aGUgcHJldmlvdXMgYWRkZWQgcG9wdXAgKi9cbiAgICAgIG1vdmVQb3B1cC5nZXRFbGVtZW50KCkucGFyZW50RWxlbWVudC5zdHlsZS56SW5kZXggPSAnMSc7XG4gICAgfSBlbHNlIGlmIChicm93c2VyRXZlbnQudHlwZSA9PT0gJ3BvaW50ZXJtb3ZlJyAmJiAhZXZlbnQpIHtcbiAgICAgIC8qKiByZW1vdmUgbW92ZSBwb3B1cCBpZiBtb3ZlIG9uIGEgY2xpY2sgbGF5ZXIgKi9cbiAgICAgIGlmIChtb3ZlUG9wdXApIHtcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxQb3B1cHMoKGl0ZW0pID0+IHtcbiAgICAgICAgICByZXR1cm4gaXRlbS5nZXQoJ2FkZEV2ZW50JykgPT09ICdwb2ludGVybW92ZSc7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYnJvd3NlckV2ZW50LnR5cGUgPT09ICdwb2ludGVybW92ZScgJiYgZXZlbnQgPT09ICdjbGljaycpIHtcbiAgICAgIGlmIChtb3ZlUG9wdXApIHtcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxQb3B1cHMoKGl0ZW0pID0+IHtcbiAgICAgICAgICByZXR1cm4gaXRlbS5nZXQoJ2FkZEV2ZW50JykgPT09ICdwb2ludGVybW92ZSc7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcG9wdXBJRCA9IG51bGw7XG4gICAgICBpZiAoZXZlbnQgPT09ICdtb3ZlJykge1xuICAgICAgICBwb3B1cElEID0gbW92ZUlEO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGFyZ3MuZmVhdHVyZSkge1xuICAgICAgICAgIHBvcHVwSUQgPSBgJHtsYXllcklEfToke29sR2V0VWlkKGFyZ3MuZmVhdHVyZSl9YDtcbiAgICAgICAgfSBlbHNlIGlmIChhcmdzLmxheWVyKSB7XG4gICAgICAgICAgcG9wdXBJRCA9IGAke2xheWVySUR9OiR7b2xHZXRVaWQoYXJncy5sYXllcil9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb3B1cElEID0gYCR7bGF5ZXJJRH06cG9wdXBfJHtuZXcgRGF0ZSgpLmdldFRpbWUoKX1gO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zOiBvbE92ZXJsYXlPcHRpb25zID0ge1xuICAgICAgICAvLyBlbGVtZW50OiBjb250YWluZXIsXG4gICAgICAgIGF1dG9QYW46IHRydWUsXG4gICAgICAgIGlkOiBwb3B1cElELFxuICAgICAgICBhdXRvUGFuQW5pbWF0aW9uOiB7XG4gICAgICAgICAgZHVyYXRpb246IDI1MFxuICAgICAgICB9LFxuICAgICAgICBwb3NpdGlvbmluZzogT3ZlcmxheVBvc2l0aW9uaW5nLkJPVFRPTV9DRU5URVIsXG4gICAgICAgIHN0b3BFdmVudDogdHJ1ZSxcbiAgICAgICAgaW5zZXJ0Rmlyc3Q6IGZhbHNlLFxuICAgICAgfTtcblxuICAgICAgbGV0IG92ZXJsYXlvcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2hlY2sgaWYgcG9wdXAgaXMgYW4gYXJyYXkgb2YgcG9wdXAgb2JqJ3Mgb3IgYSBwb3B1cCBvYmpcbiAgICAgICAqIHRoZW4gbWVyZ2UgdGhlIHBvcHVwPy5vcHRpb25zIHdpdGggdGhlIGRlZmF1bHQgb2wvb3ZlcmxheSBvcHRpb25zXG4gICAgICAgKi9cbiAgICAgIGlmICh0aGlzLmlzUG9wdXBPYmpBcnJheShsYXllcnBvcHVwKSkge1xuICAgICAgICBjb25zdCBvYmpGb3JFdmVudCA9IGxheWVycG9wdXAuZmluZChwID0+IHRoaXMuZXZlbnRJc0Jyb3dzZXJFdmVudChwLmV2ZW50LCBicm93c2VyRXZlbnQpKTtcbiAgICAgICAgaWYgKG9iakZvckV2ZW50Lm9wdGlvbnMpIHtcbiAgICAgICAgICBvdmVybGF5b3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdE9wdGlvbnMsIG9iakZvckV2ZW50Lm9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNQb3B1cE9iaihsYXllcnBvcHVwKSAmJiBsYXllcnBvcHVwLm9wdGlvbnMpIHtcbiAgICAgICAgb3ZlcmxheW9wdGlvbnMgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRPcHRpb25zLCBsYXllcnBvcHVwLm9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBvdmVybGF5ID0gbmV3IG9sT3ZlcmxheShvdmVybGF5b3B0aW9ucyk7XG4gICAgICBpZiAobW92ZUlEbGYpIHtcbiAgICAgICAgb3ZlcmxheS5zZXQobW92ZUtleUxheWVyRmVhdHVyZSwgbW92ZUlEbGYpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVtb3ZlUG9wdXBzKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsUG9wdXBzKChpdGVtKSA9PiB7XG4gICAgICAgICAgLy8gb25seSByZW1vdmUgdGhlIHBvcHVwcyBmcm9tIHRoZSBjdXJyZW50IGxheWVyXG4gICAgICAgICAgY29uc3QgZWxlbWVudElEID0gaXRlbS5nZXRJZCgpO1xuICAgICAgICAgIGNvbnN0IGxheWVyID0gZWxlbWVudElELnRvU3RyaW5nKCkuc3BsaXQoJzonKVswXTtcbiAgICAgICAgICBpZiAobGF5ZXIpIHtcbiAgICAgICAgICAgIGlmIChsYXllcklEID09PSBsYXllcikge1xuICAgICAgICAgICAgICByZXR1cm4gbGF5ZXJJRCA9PT0gbGF5ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGhhc1BvcHVwID0gdGhpcy5nZXRQb3B1cHMoKS5maW5kKGl0ZW0gPT4gKGl0ZW0uZ2V0SWQoKSA9PT0gb3ZlcmxheS5nZXRJZCgpICYmIG92ZXJsYXkuZ2V0SWQoKSAhPT0gbW92ZUlEKSk7XG4gICAgICBpZiAoaGFzUG9wdXApIHtcbiAgICAgICAgLy8gcmVtb3ZlcyBvbC1wYXJ0IG9mIHBvcHVwXG4gICAgICAgIHRoaXMubWFwLnJlbW92ZU92ZXJsYXkoaGFzUG9wdXApO1xuICAgICAgICAvLyByZW1vdmVzIGFuZ3VsYXItcGFydCBvZiBwb3B1cFxuICAgICAgICB0aGlzLmRlc3Ryb3lEeW5hbWljUG9wdXBDb21wb25lbnQoaGFzUG9wdXAuZ2V0SWQoKS50b1N0cmluZygpKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jcmVhdGVQb3B1cENvbnRhaW5lcihvdmVybGF5LCBhcmdzLCBwb3B1cE9iaiwgaHRtbCwgZXZlbnQpO1xuICAgICAgLyoqIGVkZ2UgY2FzZSB3aGVuIG1vdmluZyBhbmQgY2xpY2tpbmcgc29tZXRpbWVzIHRoZSBicm93c2VyIGV2ZW50IGlzIG5vdCBsaWtlIHRoZSBwb3B1cCBldmVudCAqL1xuICAgICAgaWYgKG92ZXJsYXkuZ2V0SWQoKSA9PT0gbW92ZUlEKSB7XG4gICAgICAgIG92ZXJsYXkuc2V0KCdhZGRFdmVudCcsICdwb2ludGVybW92ZScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3ZlcmxheS5zZXQoJ2FkZEV2ZW50JywgYnJvd3NlckV2ZW50LnR5cGUpO1xuICAgICAgfVxuICAgICAgb3ZlcmxheS5zZXQoT1ZFUkxBWV9UWVBFX0tFWSwgJ3BvcHVwJyk7XG4gICAgICBvdmVybGF5LnNldEVsZW1lbnQoY29udGFpbmVyKTtcblxuICAgICAgbGV0IGNvb3JkaW5hdGU7XG4gICAgICBpZiAoYXJncy5wcm9wZXJ0aWVzICYmIGFyZ3MucHJvcGVydGllcy5nZW9tZXRyeSAmJiBhcmdzLnByb3BlcnRpZXMuZ2VvbWV0cnkuZ2V0VHlwZSgpID09PSAnUG9pbnQnKSB7XG4gICAgICAgIGNvb3JkaW5hdGUgPSBhcmdzLnByb3BlcnRpZXMuZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvb3JkaW5hdGUgPSBicm93c2VyRXZlbnQuY29vcmRpbmF0ZTtcbiAgICAgIH1cblxuICAgICAgb3ZlcmxheS5zZXRQb3NpdGlvbihjb29yZGluYXRlKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBlZGdlIGNhc2UgcHJldmVudCBhZGQgbXVsdGlwbGUgbW92ZVBvcHVwJ3NcbiAgICAgICAqIG9ubHkgYWRkIGEgbmV3IHBvcHVwIGlmIGl0J3Mgbm90IGEgbW92ZVBvcHVwIG9yIHRoZXJlIGlzbid0IGEgYWxyZWFkeSBleGlzdGluZyBtb3ZlUG9wdXBcbiAgICAgICAqL1xuICAgICAgaWYgKCEobW92ZVBvcHVwICYmIGV2ZW50ID09PSAnbW92ZScpKSB7XG4gICAgICAgIHRoaXMubWFwLmFkZE92ZXJsYXkob3ZlcmxheSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVQb3B1cENvbnRhaW5lcihvdmVybGF5OiBvbE92ZXJsYXksIGFyZ3M6IElQb3B1cEFyZ3MsIHBvcHVwT2JqOiBhbnksIGh0bWw/OiBzdHJpbmcsIGV2ZW50PzogJ2NsaWNrJyB8ICdtb3ZlJykge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250ZW50LmNsYXNzTmFtZSA9ICdvbC1wb3B1cC1jb250ZW50JztcbiAgICBsZXQgcG9wdXBIdG1sID0gJyc7XG4gICAgaWYgKGFyZ3MucG9wdXBGbikge1xuICAgICAgcG9wdXBIdG1sID0gYXJncy5wb3B1cEZuKHBvcHVwT2JqKTtcbiAgICB9IGVsc2UgaWYgKGh0bWwgJiYgKCFwb3B1cE9iaiB8fCBPYmplY3Qua2V5cyhwb3B1cE9iaikubGVuZ3RoID09PSAwKSkge1xuICAgICAgcG9wdXBIdG1sID0gaHRtbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9wdXBIdG1sID0gdGhpcy5jcmVhdGVQb3B1cEh0bWwocG9wdXBPYmopO1xuICAgIH1cbiAgICBjb250ZW50LmlubmVySFRNTCA9IHBvcHVwSHRtbDtcbiAgICBpZiAoYXJncy5keW5hbWljUG9wdXApIHtcbiAgICAgIC8vIFRvIHByZXZlbnQgbWVtb3J5IGxlYWs6XG4gICAgICAvLyBpZiB0aGlzIHZlcnkgcG9wdXAgYWxyZWFkeSBoYXMgYmVlbiBjcmVhdGVkIChmb3IgZXhhbXBsZSBgcG9wdXBfbW92ZV9JRGApLFxuICAgICAgLy8gdGhlbiBkZXN0cm95IGl0IGJlZm9yZSBjcmVhdGluZyBhIG5ldyBvbmUuXG4gICAgICBjb25zdCBpZCA9IG92ZXJsYXkuZ2V0SWQoKS50b1N0cmluZygpO1xuICAgICAgdGhpcy5kZXN0cm95RHluYW1pY1BvcHVwQ29tcG9uZW50KGlkKTtcbiAgICAgIC8vIE9ubHkgbm93IGNyZWF0ZSBhIG5ldyBvbmUuXG4gICAgICBjb25zdCBkQXJnczogSUR5bmFtaWNQb3B1cEFyZ3MgPSB7XG4gICAgICAgIGV2ZW50OiBhcmdzLmV2ZW50LFxuICAgICAgICBsYXllcjogYXJncy5sYXllcixcbiAgICAgICAgZmVhdHVyZTogYXJncy5mZWF0dXJlIHx8IG51bGwsXG4gICAgICAgIGR5bmFtaWNQb3B1cDogYXJncy5keW5hbWljUG9wdXAsXG4gICAgICAgIHByb3BlcnRpZXM6IHBvcHVwT2JqLFxuICAgICAgfTtcbiAgICAgIHRoaXMuY3JlYXRlRHluYW1pY1BvcHVwQ29tcG9uZW50KGlkLCBjb250ZW50LCBkQXJncyk7XG4gICAgfVxuXG4gICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmNsYXNzTmFtZSA9ICdvbC1wb3B1cCc7XG4gICAgY29udGFpbmVyLmlkID0gb3ZlcmxheS5nZXRJZCgpLnRvU3RyaW5nKCk7XG4gICAgY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG4gICAgaWYgKCFldmVudCB8fCBldmVudCAhPT0gJ21vdmUnKSB7XG4gICAgICBjb25zdCBjbG9zZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICBjbG9zZXIuY2xhc3NOYW1lID0gJ29sLXBvcHVwLWNsb3Nlcic7XG4gICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY2xvc2VyKTtcblxuICAgICAgY29uc3QgY2xvc2VGdW5jdGlvbiA9ICgpID0+IHtcbiAgICAgICAgY2xvc2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2xvc2VGdW5jdGlvbiwgZmFsc2UpO1xuICAgICAgICAvLyByZW1vdmVzIG9sLXBhcnQgb2YgcG9wdXBcbiAgICAgICAgdGhpcy5tYXAucmVtb3ZlT3ZlcmxheShvdmVybGF5KTtcbiAgICAgICAgLy8gcmVtb3ZlcyBhbmd1bGFyLXBhcnQgb2YgcG9wdXBcbiAgICAgICAgdGhpcy5kZXN0cm95RHluYW1pY1BvcHVwQ29tcG9uZW50KG92ZXJsYXkuZ2V0SWQoKS50b1N0cmluZygpKTtcbiAgICAgIH07XG4gICAgICBjbG9zZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjbG9zZUZ1bmN0aW9uLCBmYWxzZSk7XG4gICAgfVxuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICByZXR1cm4gY29udGFpbmVyO1xuICB9XG5cbiAgLyoqIFVTRUQgaW4gbWFwLW9sLmNvbXBvbmVudCAqL1xuICBwdWJsaWMgcmVtb3ZlQWxsUG9wdXBzKGZpbHRlcj86IChpdGVtOiBvbE92ZXJsYXkpID0+IGJvb2xlYW4pIHtcbiAgICBsZXQgcG9wdXBzID0gdGhpcy5nZXRQb3B1cHMoKTtcbiAgICBpZiAoZmlsdGVyKSB7XG4gICAgICBwb3B1cHMgPSB0aGlzLmdldFBvcHVwcygpLmZpbHRlcihmaWx0ZXIpO1xuICAgIH1cbiAgICBwb3B1cHMuZm9yRWFjaCgob3ZlcmxheSkgPT4ge1xuICAgICAgaWYgKG92ZXJsYXkuZ2V0KE9WRVJMQVlfVFlQRV9LRVkpID09PSAncG9wdXAnKSB7XG4gICAgICAgIC8vIHJlbW92ZXMgb2wtcGFydCBvZiBwb3B1cFxuICAgICAgICB0aGlzLm1hcC5yZW1vdmVPdmVybGF5KG92ZXJsYXkpO1xuICAgICAgICAvLyByZW1vdmVzIGFuZ3VsYXItcGFydCBvZiBwb3B1cFxuICAgICAgICB0aGlzLmRlc3Ryb3lEeW5hbWljUG9wdXBDb21wb25lbnQob3ZlcmxheS5nZXRJZCgpLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGNyZWF0ZVBvcHVwSHRtbChvYmo6IGFueSkge1xuICAgIGxldCBodG1sU3RyID0gJzx0YWJsZT4nO1xuICAgIGZvciAoY29uc3QgbyBpbiBvYmopIHtcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkobykpIHtcbiAgICAgICAgaHRtbFN0ciArPSAnPHRyPjx0ZCBzdHlsZT1cInZlcnRpY2FsLWFsaWduOiB0b3A7IHBhZGRpbmctcmlnaHQ6IDdweDtcIj48Yj4nICsgbyArICc6IDwvYj48L3RkPjx0ZD4nICsgb2JqW29dICtcbiAgICAgICAgICAnPC90ZD48L3RyPic7XG4gICAgICB9XG4gICAgfVxuICAgIGh0bWxTdHIgPSBodG1sU3RyICsgJzwvdGFibGU+JztcbiAgICByZXR1cm4gaHRtbFN0cjtcbiAgfVxuXG4gIHB1YmxpYyBnZXRQb3B1cHMoKTogb2xPdmVybGF5W10ge1xuICAgIGNvbnN0IHBvcHVwcyA9IFtdO1xuICAgIHRoaXMubWFwLmdldE92ZXJsYXlzKCkuZ2V0QXJyYXkoKS5zbGljZSgwKS5mb3JFYWNoKChvdmVybGF5KSA9PiB7XG4gICAgICBpZiAob3ZlcmxheS5nZXQoT1ZFUkxBWV9UWVBFX0tFWSkgPT09ICdwb3B1cCcpIHtcbiAgICAgICAgcG9wdXBzLnB1c2gob3ZlcmxheSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHBvcHVwcztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyBhIHBvcHVwLWNvbXBvbmVudC5cbiAgICogIC0ga2lsbHMgdGhlIGNvbXBvbmVudCAod2l0aCBgLmRlc3Ryb3koKWApXG4gICAqICAtIGRldGFjaGVzIGl0IGZyb20gYW5ndWxhci1hcHBsaWNhdGlvbiAod2l0aCBgLmRlc3Ryb3koKWApXG4gICAqICAtIHJlbW92ZXMgdGhlIGVudHJ5IGZyb20gYHRoaXMuZHluYW1pY1BvcHVwQ29tcG9uZW50c2BcbiAgICogQHBhcmFtIGlkIDogVGhlIHN0cmluZyB1bmRlciB3aGljaCB0aGUgcG9wdXAtY29tcG9uZW50IGhhcyBiZWVuIHN0b3JlZCBpbiBgdGhpcy5keW5hbWljUG9wdXBDb21wb25lbnRzYFxuICAgKi9cbiAgcHJpdmF0ZSBkZXN0cm95RHluYW1pY1BvcHVwQ29tcG9uZW50KGlkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5keW5hbWljUG9wdXBDb21wb25lbnRzLmhhcyhpZCkpIHtcbiAgICAgIHRoaXMuZHluYW1pY1BvcHVwQ29tcG9uZW50cy5nZXQoaWQpLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuZHluYW1pY1BvcHVwQ29tcG9uZW50cy5kZWxldGUoaWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGFuZ3VsYXIgY29tcG9uZW50IHRvIGJlIHVzZWQgYXMgcG9wdXAtYm9keS5cbiAgICogIC0gY3JlYXRlcyBjb21wb25lbnRcbiAgICogIC0gYXR0YWNoZXMgY29tcG9uZW50LXZpZXcgdG8gYW5ndWxhci1hcHBsaWNhdGlvblxuICAgKiAgLSBrZWVwcyByZWZlcmVuY2UgdG8gY29tcG9uZW50IGluIGB0aGlzLmR5bmFtaWNQb3B1cENvbXBvbmVudHNgIGZvciBsYXRlciByZW1vdmFsLlxuICAgKlxuICAgKiBAcGFyYW0gaWQgOiBUaGUgY29udGFpbmVyLWlkLiBBbHNvIHRoZSBpZCB1bmRlciB3aGljaCB0aGUgY29tcG9uZW50IHdpbGwgYmUgc3RvcmVkIGluIGB0aGlzLmR5bmFtaWNQb3B1cENvbXBvbmVudHNgLlxuICAgKiBAcGFyYW0gYW5jaG9yRWxlbWVudCA6IFRoZSBodG1sLWVsZW1lbnQgdG8gd2hpY2ggdGhlIHBvcHVwLWNvbXBvbmVudCBzaGFsbCBiZSBhdHRhY2hlZFxuICAgKiBAcGFyYW0gYXJncyA6IE11c3QgY29udGFpbiBgZHluYW1pY1BvcHVwYFxuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVEeW5hbWljUG9wdXBDb21wb25lbnQoaWQ6IHN0cmluZywgYW5jaG9yRWxlbWVudDogSFRNTEVsZW1lbnQsIGFyZ3M6IElEeW5hbWljUG9wdXBBcmdzKTogdm9pZCB7XG4gICAgY29uc3QgZmFjdG9yeSA9IHRoaXMuY3JmLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KGFyZ3MuZHluYW1pY1BvcHVwLmNvbXBvbmVudCk7XG4gICAgY29uc3QgcG9wdXBCb2R5ID0gZmFjdG9yeS5jcmVhdGUodGhpcy5pbmplY3RvciwgW10sIGFuY2hvckVsZW1lbnQpO1xuXG4gICAgaWYgKGFyZ3MuZHluYW1pY1BvcHVwLmdldEF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBhcmdzLmR5bmFtaWNQb3B1cC5nZXRBdHRyaWJ1dGVzKGFyZ3MpO1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgICBpZiAoYXR0cmlidXRlc1trZXldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHBvcHVwQm9keS5pbnN0YW5jZVtrZXldID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYXBwLmF0dGFjaFZpZXcocG9wdXBCb2R5Lmhvc3RWaWV3KTtcbiAgICB0aGlzLmR5bmFtaWNQb3B1cENvbXBvbmVudHMuc2V0KGlkLCBwb3B1cEJvZHkpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBleHRlbnQ6IFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXVxuICAgKiBAcGFyYW0gZ2VvZ3JhcGhpYzogYm9vbGVhblxuICAgKiBAcGFyYW0gZml0T3B0aW9uczogb2xGaXRPcHRpb25zXG4gICAqIEByZXR1cm5zIG9sRXh0ZW5kOiBbbWluWCwgbWluWSwgbWF4WCwgbWF4WV1cbiAgICovXG4gIHB1YmxpYyBzZXRFeHRlbnQoZXh0ZW50OiBUR2VvRXh0ZW50LCBnZW9ncmFwaGljPzogYm9vbGVhbiwgZml0T3B0aW9ucz86IGFueSk6IFRHZW9FeHRlbnQge1xuICAgIGNvbnN0IHByb2plY3Rpb24gPSAoZ2VvZ3JhcGhpYykgPyBnZXRQcm9qZWN0aW9uKFdHUzg0KSA6IGdldFByb2plY3Rpb24odGhpcy5FUFNHKTtcbiAgICBjb25zdCB0cmFuc2ZvbUV4dGVudCA9IHRyYW5zZm9ybUV4dGVudChleHRlbnQuc2xpY2UoMCwgNCkgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIHByb2plY3Rpb24sIHRoaXMuZ2V0UHJvamVjdGlvbigpLmdldENvZGUoKSk7XG4gICAgY29uc3QgbmV3Rml0T3B0aW9ucyA9IHtcbiAgICAgIHNpemU6IHRoaXMubWFwLmdldFNpemUoKSxcbiAgICAgIC8vIHBhZGRpbmc6IFsxMDAsIDIwMCwgMTAwLCAxMDBdIC8vIFBhZGRpbmcgKGluIHBpeGVscykgdG8gYmUgY2xlYXJlZCBpbnNpZGUgdGhlIHZpZXcuIFZhbHVlcyBpbiB0aGUgYXJyYXkgYXJlIHRvcCwgcmlnaHQsIGJvdHRvbSBhbmQgbGVmdCBwYWRkaW5nLiBEZWZhdWx0IGlzIFswLCAwLCAwLCAwXS5cbiAgICB9O1xuICAgIGlmIChmaXRPcHRpb25zKSB7XG4gICAgICBPYmplY3QuYXNzaWduKG5ld0ZpdE9wdGlvbnMsIGZpdE9wdGlvbnMpO1xuICAgIH1cbiAgICB0aGlzLm1hcC5nZXRWaWV3KCkuZml0KHRyYW5zZm9tRXh0ZW50LCBmaXRPcHRpb25zKTtcbiAgICByZXR1cm4gKHRyYW5zZm9tRXh0ZW50IGFzIFRHZW9FeHRlbnQpO1xuICB9XG5cbiAgLyoqIFVTRUQgaW4gbWFwLW9sLmNvbXBvbmVudCAqL1xuICAvKiogb2wuQ29vcmRpbmF0ZSB4eSAqL1xuICBwdWJsaWMgc2V0Q2VudGVyKGNlbnRlcjogbnVtYmVyW10sIGdlb2dyYXBoaWM/OiBib29sZWFuKTogbnVtYmVyW10ge1xuICAgIGNvbnN0IHByb2plY3Rpb24gPSAoZ2VvZ3JhcGhpYykgPyBnZXRQcm9qZWN0aW9uKFdHUzg0KSA6IGdldFByb2plY3Rpb24odGhpcy5FUFNHKTtcbiAgICBjb25zdCB0cmFuc2ZvbUNlbnRlciA9IHRyYW5zZm9ybShjZW50ZXIsIHByb2plY3Rpb24sIHRoaXMuZ2V0UHJvamVjdGlvbigpLmdldENvZGUoKSk7XG4gICAgLy8gY29uc29sZS5sb2coJ3NldCBjZW50ZXIgaW4gc3ZjJywgdHJhbnNmb21DZW50ZXIpXG4gICAgLy8gY29uc29sZS5sb2codGhpcy5tYXAuZ2V0VmlldygpLmdldENlbnRlcigpKVxuICAgIHRoaXMubWFwLmdldFZpZXcoKS5zZXRDZW50ZXIodHJhbnNmb21DZW50ZXIpO1xuICAgIHJldHVybiB0cmFuc2ZvbUNlbnRlcjtcbiAgfVxuXG4gIC8qKiBVU0VEIGluIG1hcC1vbC5jb21wb25lbnQgKi9cbiAgcHVibGljIGdldENlbnRlcihnZW9ncmFwaGljPzogYm9vbGVhbik6IGFueSB7XG4gICAgY29uc3QgZHN0UHJvamVjdGlvbiA9IChnZW9ncmFwaGljKSA/IGdldFByb2plY3Rpb24oV0dTODQpIDogZ2V0UHJvamVjdGlvbih0aGlzLkVQU0cpO1xuICAgIGNvbnN0IHNyY1Byb2plY3Rpb24gPSBnZXRQcm9qZWN0aW9uKHRoaXMuZ2V0UHJvamVjdGlvbigpLmdldENvZGUoKSk7XG4gICAgY29uc3QgdHJhbnNmb21DZW50ZXIgPSB0cmFuc2Zvcm0odGhpcy5tYXAuZ2V0VmlldygpLmdldENlbnRlcigpLCBzcmNQcm9qZWN0aW9uLCBkc3RQcm9qZWN0aW9uKTtcbiAgICByZXR1cm4gdHJhbnNmb21DZW50ZXI7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBmZWF0dXJlczogb2xGZWF0dXJlW11cbiAgICogQHBhcmFtIGdlb2dyYXBoaWM6IGJvb2xlYW5cbiAgICogQHJldHVybnMgb2xFeHRlbmQ6IFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXVxuICAgKi9cbiAgcHVibGljIGdldEZlYXR1cmVzRXh0ZW50KGZlYXR1cmVzOiBvbEZlYXR1cmU8YW55PltdLCBnZW9ncmFwaGljPzogYm9vbGVhbik6IFRHZW9FeHRlbnQge1xuICAgIGNvbnN0IGV4dGVudDogYW55ID0gZmVhdHVyZXNbMF0uZ2V0R2VvbWV0cnkoKS5nZXRFeHRlbnQoKS5zbGljZSgwKTtcbiAgICBmZWF0dXJlcy5mb3JFYWNoKChmZWF0dXJlKSA9PiB7XG4gICAgICBvbEV4dGVuZChleHRlbnQsIGZlYXR1cmUuZ2V0R2VvbWV0cnkoKS5nZXRFeHRlbnQoKSk7XG4gICAgfSk7XG4gICAgaWYgKGdlb2dyYXBoaWMpIHtcbiAgICAgIGNvbnN0IHByb2plY3Rpb24gPSBnZXRQcm9qZWN0aW9uKFdHUzg0KTtcbiAgICAgIGNvbnN0IHRyYW5zZm9tRXh0ZW50ID0gdHJhbnNmb3JtRXh0ZW50KGV4dGVudCwgdGhpcy5nZXRQcm9qZWN0aW9uKCkuZ2V0Q29kZSgpLCBwcm9qZWN0aW9uKTtcbiAgICAgIHJldHVybiAodHJhbnNmb21FeHRlbnQgYXMgVEdlb0V4dGVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBleHRlbnQ7XG4gICAgfVxuICB9XG5cbiAgLyoqIFVTRUQgaW4gbWFwLW9sLmNvbXBvbmVudCAqL1xuICAvKipcbiAgICogQHBhcmFtIGdlb2dyYXBoaWM6IGJvb2xlYW5cbiAgICogQHJldHVybnMgb2xFeHRlbmQ6IFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXVxuICAgKi9cbiAgcHVibGljIGdldEN1cnJlbnRFeHRlbnQoZ2VvZ3JhcGhpYz86IGJvb2xlYW4pOiBUR2VvRXh0ZW50IHtcbiAgICBjb25zdCBwcm9qZWN0aW9uID0gKGdlb2dyYXBoaWMpID8gZ2V0UHJvamVjdGlvbihXR1M4NCkgOiBnZXRQcm9qZWN0aW9uKHRoaXMuRVBTRyk7XG4gICAgY29uc3QgZXh0ZW50ID0gdGhpcy5tYXAuZ2V0VmlldygpLmNhbGN1bGF0ZUV4dGVudCgpO1xuICAgIGNvbnN0IHRyYW5zZm9tRXh0ZW50ID0gdHJhbnNmb3JtRXh0ZW50KGV4dGVudCwgdGhpcy5nZXRQcm9qZWN0aW9uKCkuZ2V0Q29kZSgpLCBwcm9qZWN0aW9uKTtcbiAgICByZXR1cm4gKHRyYW5zZm9tRXh0ZW50IGFzIFRHZW9FeHRlbnQpO1xuICB9XG5cbiAgLyoqIFVTRUQgaW4gbWFwLW9sLmNvbXBvbmVudCAqL1xuICBwdWJsaWMgc2V0Wm9vbSh6b29tOiBudW1iZXIsIG5vdGlmaWVyPzogJ21hcCcgfCAndXNlcicpIHtcbiAgICBjb25zdCB2aWV3ID0gdGhpcy5tYXAuZ2V0VmlldygpO1xuICAgIHZpZXcuc2V0Wm9vbSh6b29tKTtcbiAgfVxuXG4gIC8qKiBVU0VEIGluIG1hcC1vbC5jb21wb25lbnQgKi9cbiAgcHVibGljIGdldFpvb20oKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5tYXAuZ2V0VmlldygpLmdldFpvb20oKTtcbiAgfVxuXG4gIHB1YmxpYyB6b29tSW5PdXQodmFsdWU6ICctJyB8ICcrJykge1xuICAgIGNvbnN0IHZpZXcgPSB0aGlzLm1hcC5nZXRWaWV3KCk7XG4gICAgaWYgKCF2aWV3KSB7XG4gICAgICAvLyB0aGUgbWFwIGRvZXMgbm90IGhhdmUgYSB2aWV3LCBzbyB3ZSBjYW4ndCBhY3RcbiAgICAgIC8vIHVwb24gaXRcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZHVyYXRpb24gPSAyNTA7XG4gICAgY29uc3QgZGVsdGEgPSB2YWx1ZSA9PT0gJysnID8gMSA6IC0xO1xuICAgIGNvbnN0IGN1cnJlbnRab29tID0gdmlldy5nZXRab29tKCk7XG4gICAgaWYgKGN1cnJlbnRab29tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IG5ld1pvb20gPSB2aWV3LmdldENvbnN0cmFpbmVkWm9vbShjdXJyZW50Wm9vbSArIGRlbHRhKTtcbiAgICAgIGlmIChkdXJhdGlvbiA+IDApIHtcbiAgICAgICAgaWYgKHZpZXcuZ2V0QW5pbWF0aW5nKCkpIHtcbiAgICAgICAgICB2aWV3LmNhbmNlbEFuaW1hdGlvbnMoKTtcbiAgICAgICAgfVxuICAgICAgICB2aWV3LmFuaW1hdGUoe1xuICAgICAgICAgIHpvb206IG5ld1pvb20sXG4gICAgICAgICAgZHVyYXRpb24sXG4gICAgICAgICAgZWFzaW5nOiBlYXNlT3V0XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmlldy5zZXRab29tKG5ld1pvb20pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZW9Kc29uVG9GZWF0dXJlKGdlb2pzb246IGFueSk6IG9sRmVhdHVyZTxhbnk+IHtcbiAgICBjb25zdCBHRU9KU09OID0gbmV3IG9sR2VvSlNPTih7XG4gICAgICBkYXRhUHJvamVjdGlvbjogV0dTODQsXG4gICAgICBmZWF0dXJlUHJvamVjdGlvbjogdGhpcy5FUFNHXG4gICAgfSk7XG4gICAgcmV0dXJuIEdFT0pTT04ucmVhZEZlYXR1cmUoZ2VvanNvbik7XG4gIH1cblxuICBwdWJsaWMgZ2VvSnNvblRvRmVhdHVyZXMoZ2VvanNvbjogYW55KTogQXJyYXk8b2xGZWF0dXJlPGFueT4+IHtcbiAgICBjb25zdCBHRU9KU09OID0gbmV3IG9sR2VvSlNPTih7XG4gICAgICBkYXRhUHJvamVjdGlvbjogV0dTODQsXG4gICAgICBmZWF0dXJlUHJvamVjdGlvbjogdGhpcy5FUFNHXG4gICAgfSk7XG4gICAgcmV0dXJuIEdFT0pTT04ucmVhZEZlYXR1cmVzKGdlb2pzb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zICdvbFByb2plY3Rpb24nXG4gICAqL1xuICBwdWJsaWMgZ2V0UHJvamVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAuZ2V0VmlldygpLmdldFByb2plY3Rpb24oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBmdW5jdGlvbiB0byByZXByb2plY3QgdmVjdG9yIGZlYXR1cmVzXG4gICAqIEBwYXJhbSBzb3VyY2U6ICBvbFZlY3RvclNvdXJjZVxuICAgKiBAcGFyYW0gc3JjUHJvajogc3RyaW5nIChlLmcuICdFUFNHOjQzMjYnKVxuICAgKiBAcGFyYW0gZHN0UHJvajogc3RyaW5nIChlLmcuICdFUFNHOjM4NTcnKVxuICAgKi9cbiAgcHVibGljIHJlcHJvamVjdEZlYXR1cmVzKHNvdXJjZTogb2xWZWN0b3JTb3VyY2U8YW55Piwgc3JjUHJvajogc3RyaW5nLCBkc3RQcm9qOiBzdHJpbmcpIHtcbiAgICBzb3VyY2UuZ2V0RmVhdHVyZXMoKS5mb3JFYWNoKGZlYXR1cmUgPT4ge1xuICAgICAgZmVhdHVyZS5nZXRHZW9tZXRyeSgpLnRyYW5zZm9ybShzcmNQcm9qLCBkc3RQcm9qKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiB2ZWN0b3IgbGF5ZXJzIHdpbGwgYmUgcmVwcm9qZWN0ZWQgYXV0b21hdGljYWxseVxuICAgKiB3bXMgbGF5ZXJzIHdpbGwgYmUgdXBkYXRlZCB3aXRoIGNvcnJlc3BvbmRpbmcgcHJvaiBkZWYgaW4gdGhlIHJlcXVlc3RzLlxuICAgKiBmb3Igb3RoZXIgcmFzdGVyIGxheWVycyBhbmQgZm9yIHRob3NlIHdtcyBsYXllcnMgd2hpY2ggYmFja2VuZCBkb2VzIG5vdCBzdXBwb3J0IHRhcmdldCBwcm9qZWN0aW9uLCBwbGVhc2VcbiAgICogZGVmaW5lIGluaXRpYWwoZGVmYXVsdCkgbGF5ZXIgcHJvamVjdGlvbiwgc28gb3BlbmxheWVycyB3aWxsIHJlcHJvamVjdCBvbiB0aGUgY2xpZW50IHNpZGVcbiAgICogcHJvamVjdGlvbiBpcyBwcm9qflByb2plY3Rpb25MaWtlXG4gICAqL1xuICBwdWJsaWMgc2V0UHJvamVjdGlvbihwcm9qZWN0aW9uOiBvbFByb2plY3Rpb24gfCBzdHJpbmcpIHtcbiAgICBpZiAocHJvamVjdGlvbikge1xuICAgICAgbGV0IHZpZXdPcHRpb25zOiBvbFZpZXdPcHRpb25zID0ge307XG4gICAgICBpZiAodGhpcy52aWV3T3B0aW9ucykge1xuICAgICAgICB2aWV3T3B0aW9ucyA9IHRoaXMudmlld09wdGlvbnM7XG4gICAgICAgIHZpZXdPcHRpb25zLm1pblJlc29sdXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHZpZXdPcHRpb25zLm1heFJlc29sdXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHZpZXdPcHRpb25zLnJlc29sdXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHZpZXdPcHRpb25zLnJlc29sdXRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKHByb2plY3Rpb24gaW5zdGFuY2VvZiBvbFByb2plY3Rpb24pIHtcbiAgICAgICAgdmlld09wdGlvbnMucHJvamVjdGlvbiA9IHByb2plY3Rpb247XG4gICAgICAgIGNvbnN0IG5ld0NlbnRlciA9IHRyYW5zZm9ybSh0aGlzLm1hcC5nZXRWaWV3KCkuZ2V0Q2VudGVyKCksIHRoaXMubWFwLmdldFZpZXcoKS5nZXRQcm9qZWN0aW9uKCksIHByb2plY3Rpb24pOyAvLyBnZXQgY2VudGVyIGNvb3JkaW5hdGVzIGluIHRoZSBuZXcgcHJvamVjdGlvblxuICAgICAgICB2aWV3T3B0aW9ucy5jZW50ZXIgPSBuZXdDZW50ZXI7IC8vIHRoaXMubWFwLmdldFZpZXcoKS5nZXRDZW50ZXIoKTtcbiAgICAgICAgLy8gX3ZpZXdPcHRpb25zLmV4dGVudCA9IHByb2plY3Rpb24uZ2V0RXh0ZW50KCk7Ly8gfHwgdW5kZWZpbmVkO1xuICAgICAgICB2aWV3T3B0aW9ucy56b29tID0gdGhpcy5tYXAuZ2V0VmlldygpLmdldFpvb20oKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb2plY3Rpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZpZXdPcHRpb25zLnByb2plY3Rpb24gPSBwcm9qZWN0aW9uO1xuICAgICAgICB2aWV3T3B0aW9ucy5jZW50ZXIgPSB0aGlzLm1hcC5nZXRWaWV3KCkuZ2V0Q2VudGVyKCk7XG4gICAgICAgIHZpZXdPcHRpb25zLnpvb20gPSB0aGlzLm1hcC5nZXRWaWV3KCkuZ2V0Wm9vbSgpO1xuICAgICAgfVxuICAgICAgY29uc3QgdmlldyA9IG5ldyBvbFZpZXcodmlld09wdGlvbnMpO1xuICAgICAgY29uc3Qgb2xkUHJvamVjdGlvbiA9IHRoaXMuRVBTRztcbiAgICAgIHRoaXMuRVBTRyA9IHZpZXcuZ2V0UHJvamVjdGlvbigpLmdldENvZGUoKTtcbiAgICAgIHRoaXMubWFwLnNldFZpZXcodmlldyk7XG4gICAgICB0aGlzLnZpZXcgPSB0aGlzLm1hcC5nZXRWaWV3KCk7XG5cbiAgICAgIC8vIHJlcHJvamVjdGluZyB2ZWN0b3IgbGF5ZXJzXG4gICAgICB0aGlzLm1hcC5nZXRMYXllcnMoKS5nZXRBcnJheSgpLmZvckVhY2goKGxheWVyR3JvdXA6IG9sTGF5ZXJHcm91cCkgPT4ge1xuICAgICAgICBsYXllckdyb3VwLmdldExheWVycygpLmdldEFycmF5KCkuZm9yRWFjaChsYXllciA9PiB7XG4gICAgICAgICAgaWYgKGxheWVyIGluc3RhbmNlb2Ygb2xMYXllcikge1xuICAgICAgICAgICAgbGV0IHNvdXJjZSA9IGxheWVyLmdldFNvdXJjZSgpO1xuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIG5lc3RlZCBzb3VyY2VzLCBlLmcuIGNsdXN0ZXIgb3IgY2x1c3RlciBvZiBjbHVzdGVycyBldGNcbiAgICAgICAgICAgIHdoaWxlIChzb3VyY2VbJ3NvdXJjZSddKSB7XG4gICAgICAgICAgICAgIHNvdXJjZSA9IHNvdXJjZVsnc291cmNlJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc291cmNlIGluc3RhbmNlb2Ygb2xWZWN0b3JTb3VyY2UpIHtcbiAgICAgICAgICAgICAgdGhpcy5yZXByb2plY3RGZWF0dXJlcyhzb3VyY2UsIG9sZFByb2plY3Rpb24sIHRoaXMuRVBTRyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5wcm9qZWN0aW9uQ2hhbmdlLm5leHQodGhpcy5nZXRQcm9qZWN0aW9uKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygncHJvamVjdGlvbiBjb2RlIGlzIHVuZGVmaW5lZCcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gcHJvakRlZi5jb2RlIC0gZS5nLjogXCJFUFNHOjQzMjZcIlxuICAgKiBAcGFyYW0gcHJvakRlZi5wcm9qNGpzIC0gZS5nLjogXCIrdGl0bGU9V0dTIDg0IChsb25nL2xhdCkgK3Byb2o9bG9uZ2xhdCArZWxscHM9V0dTODQgK2RhdHVtPVdHUzg0ICt1bml0cz1kZWdyZWVzXCJcbiAgICovXG4gIHB1YmxpYyByZWdpc3RlclByb2plY3Rpb24ocHJvakRlZjogeyBjb2RlOiBzdHJpbmcsIHByb2o0anM6IHN0cmluZyB9KSB7XG4gICAgcHJvajQuZGVmcyhwcm9qRGVmLmNvZGUsIHByb2pEZWYucHJvajRqcyk7XG4gICAgb2xSZWdpc3Rlcihwcm9qNCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIE9wZW5MYXllcnMgUHJvamVjdGlvbiBmcm9tIE9wdGlvbnNcbiAgICovXG4gIHB1YmxpYyBnZXRPbFByb2plY3Rpb24ocHJvakRlZjogb2xQcm9qZWN0aW9uT3B0aW9ucyk6IG9sUHJvamVjdGlvbiB7XG4gICAgcmV0dXJuIG5ldyBvbFByb2plY3Rpb24oe1xuICAgICAgY29kZTogcHJvakRlZi5jb2RlLFxuICAgICAgZXh0ZW50OiBwcm9qRGVmLmV4dGVudCA/IHByb2pEZWYuZXh0ZW50IDogdW5kZWZpbmVkLFxuICAgICAgd29ybGRFeHRlbnQ6IHByb2pEZWYud29ybGRFeHRlbnQgPyBwcm9qRGVmLndvcmxkRXh0ZW50IDogdW5kZWZpbmVkLFxuICAgICAgZ2xvYmFsOiBwcm9qRGVmLmdsb2JhbCA/IHByb2pEZWYuZ2xvYmFsIDogZmFsc2UsXG4gICAgICB1bml0czogcHJvakRlZi51bml0cyA/IHByb2pEZWYudW5pdHMgOiB1bmRlZmluZWRcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUga2V5c1RvVXBwZXJjYXNlPFQ+KG9iajogeyBbazogc3RyaW5nXTogYW55IH0pIHtcbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgY29uc3QgayA9IGtleS50b1VwcGVyQ2FzZSgpO1xuICAgICAgaWYgKGsgIT09IGtleSkge1xuICAgICAgICBvYmpba10gPSBvYmpba2V5XTtcbiAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvYmogYXMgVDtcbiAgfVxufVxuIl19