/**
 * WEBGL
 *
 * A rasterization engine that allows to draw points, line segments, or triangles.
 *
 * Vertex shaders take whatever coordinates you use and return a 3-d array with elements between -1 and 1.
 * Basically, this is a 3d-array, but WebGl does not use the z-axis for real perspective, but only to differentiate
 * what pixel lies in front of another.
 * This is not like looking in a 3d-box, but rather like looking on multiple stacked sheets on a projector.
 * Actually, this is a lie. WebGl uses 4 coordinates: x, y, z and w. The above only holds if you keep w at 1.
 * After applying the vertex shader, WebGl divides all coordinates by w, yielding (x/w, y/w, z/w, 1).
 * This can be used to calculate projections - google for 'homogeneous coordinates' to find out more.
 * Compare this [site](https://www.tomdalling.com/blog/modern-opengl/explaining-homogenous-coordinates-and-projective-geometry/)
 * and the shader `basic3d.vert.glsl`.
 *
 * WebGL knows two data structures:
 *  - buffers (generic byte arrays): usually positions, normals, texture-coordinates, vertex-colors etc.
 *    buffers are accessed in shaders as 'attributes'.
 *    note that buffers contain one entry for each vertex.
 *  - textures (bitmap images).
 *
 * Shaders use these data structures in two different ways.
 *  - Attributes are values, one per vertex.
 *    For the shader, attributes are read-only.
 *    Attributes default to [0, 0, 0, 1]
 *  - Uniforms are values, one per shader.
 *    For the shader, uniforms are read-only.
 *
 * Apart from this, shaders know about two more types of data:
 *  - Varyings are values that are passed from vertex-shader to fragment-shader.
 *    They are read-only only for the fragment-shader.
 *  - Const: a compile-time constant.
 *
 * A program is just a list of compiled and linked vertex- and fragment-shaders.
 *
 *
 * Drawing: there's drawArrays and drawElements.
 *  - drawArrays is the robust all-rounder.
 *  - drawElements can be more performant if you share vertices between objects.
 *
 *
 * Rendering data is fast, but uploading it into GPU memory is slow.
 * Optimizing WebGl performance mostly means: Avoiding having GPU and CPU wait for each other.
 * The more the GPU can do in bulk, the better. The more often you have to upload data from CPU to GPU, the worse.
 *  - So avoid switching programs, buffers and uniforms if you can.
 *    (You won't be able to avoid switching buffers, because every object is likely different. But sort your objects by their shaders, and you'll save a lot of time.)
 *  - Try to do translations, rotations and shears inside the vertex-shader instead of altering the object's buffer.
 *  - If appropriate, create über-shaders and über-buffers, that contain information for more than just one object.
 *
 * There is another thing that affects performance:
 * WebGL will only run fragment-shaders when the object's pixels aren't already obscured by a larger object in front of it.
 * That means it makes sense to first draw large objects that are close to the camera - all objects behind them won't need their fragment-shader executed.
 *
 * All `create*` functions unbind variables after setting their values. This is to avoid unwanted side-effects.
 *
 *
 *
 * WebGL components
 *    - global-state
 *        - ARRAY_BUFFER_BINDING: currently bound buffer
 *        - VERTEX_ARRAY_BINDING: currently bound vertex-array (in WebGL 1 this was always only the global vertex-array, in WebGL 2 you can now create your own ones)
 *        - ACTIVE_TEXTURE: currently bound texture
 *        - texture-units: a list of pointers to texture-buffers.
 *        - uniform-buffer-bindings (WebGL2 only): a list of pointers to uniform-buffers.
 *    - vertex-array: a list of pointers to attribute-buffers (+ metadata like datatype, stride, offset etc.).
 *        - all attributes must have the same number of elements (though one attribute's elements may be vec2's, while another one's may be vec3's)
 *        - drawArray: attributes repeat elements in groups of three for drawing triangles
 *        - drawElements: the indices for the triangles are defined in ELEMENT_ARRAY_BUFFER_BINDING
 *        - WebGL 2.0: allows you to create your own vertex-arrays, whereas 1.0 always only used one global vertex-array.
 */
import { flattenRecursive, isPowerOf } from './utils';
const shaderInputTextureBindPoint = 0;
const textureConstructionBindPoint = 7;
/**
 * Compile shader.
 */
export const compileShader = (gl, typeBit, shaderSource) => {
    const shader = gl.createShader(typeBit);
    if (!shader) {
        throw new Error('No shader was created');
    }
    gl.shaderSource(shader, shaderSource);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        gl.deleteShader(shader);
        throw new Error(`An error occurred compiling the shader: ${gl.getShaderInfoLog(shader)}.    \n\n Shader code: ${shaderSource}`);
    }
    return shader;
};
/**
 * Note that every program *must* have one and only one vertex-shader
 * and one and only one fragment shader.
 * That means you cannot add multiple fragment-shaders in one program. Instead, either load them in consecutively as part of different programs,
 * or generate an über-shader that contains both codes.
 */
export const createShaderProgram = (gl, vertexShaderSource, fragmentShaderSource) => {
    const program = gl.createProgram();
    if (!program) {
        throw new Error('No program was created');
    }
    const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    gl.detachShader(program, vertexShader);
    gl.detachShader(program, fragmentShader);
    gl.deleteShader(vertexShader);
    gl.deleteShader(fragmentShader);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        gl.deleteProgram(program);
        throw new Error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(program));
    }
    return program;
};
export const setup3dScene = (gl) => {
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);
    gl.cullFace(gl.BACK);
    clearBackground(gl, [0, 0, 0, 1]);
};
export const updateViewPort = (gl, x0, y0, x1, y1) => {
    gl.viewport(x0, y0, x1, y1);
};
export const bindProgram = (gl, program) => {
    gl.useProgram(program);
};
export const clearBackground = (gl, color) => {
    gl.clearColor(color[0], color[1], color[2], color[3]);
    gl.clearDepth(1.0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
};
/**
 * Create buffer. Creation is slow! Do *before* render loop.
 */
export const createFloatBuffer = (gl, data, drawingMode = gl.TRIANGLES) => {
    const dataFlattened = new Float32Array(flattenRecursive(data));
    const buffer = gl.createBuffer();
    if (!buffer) {
        throw new Error('No buffer was created');
    }
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, dataFlattened, gl.STATIC_DRAW);
    // STATIC_DRAW: tells WebGl that we are not likely to change this data much.
    gl.bindBuffer(gl.ARRAY_BUFFER, null); // unbinding
    const bufferObject = {
        buffer: buffer,
        vectorSize: data[0].length,
        vectorCount: data.length,
        type: gl.FLOAT,
        normalize: false,
        stride: 0,
        offset: 0,
        drawingMode: drawingMode
    };
    return bufferObject;
};
export const drawArray = (gl, bo) => {
    gl.drawArrays(bo.drawingMode, bo.offset, bo.vectorCount);
};
export const updateBufferData = (gl, bo, newData) => {
    const dataFlattened = new Float32Array(flattenRecursive(newData));
    gl.bindBuffer(gl.ARRAY_BUFFER, bo.buffer);
    gl.bufferData(gl.ARRAY_BUFFER, dataFlattened, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, null); // unbinding
    const newBufferObject = {
        buffer: bo.buffer,
        vectorSize: newData[0].length,
        vectorCount: newData.length,
        type: gl.FLOAT,
        normalize: false,
        stride: 0,
        offset: 0,
        drawingMode: bo.drawingMode,
    };
    return newBufferObject;
};
/**
 * Fetch attribute's location (attribute declared in some shader). Slow! Do *before* render loop.
 */
export const getAttributeLocation = (gl, program, attributeName) => {
    const loc = gl.getAttribLocation(program, attributeName);
    if (loc === -1) {
        throw new Error(`Couldn't find attribute ${attributeName} in program.`);
    }
    return loc;
};
/**
 * Attributes vary from vertex to vertex - that means that there are *many* of them.
 * So it makes sense for WebGl to store attribute values in a dedicated data structure - the buffer.
 */
export const bindBufferToAttribute = (gl, attributeLocation, bufferObject) => {
    // Bind buffer to global-state ARRAY_BUFFER
    gl.bindBuffer(gl.ARRAY_BUFFER, bufferObject.buffer);
    // Enable editing of vertex-array-location
    gl.enableVertexAttribArray(attributeLocation);
    // Bind the buffer currently at global-state ARRAY_BUFFER to a vertex-array-location.
    gl.vertexAttribPointer(attributeLocation, bufferObject.vectorSize, bufferObject.type, bufferObject.normalize, bufferObject.stride, bufferObject.offset);
    // gl.disableVertexAttribArray(attributeLocation); <-- must not do this!
};
export const createIndexBuffer = (gl, indices, drawingMode = gl.TRIANGLES) => {
    const indicesFlattened = new Uint16Array(flattenRecursive(indices));
    const buffer = gl.createBuffer();
    if (!buffer) {
        throw new Error('No buffer was created');
    }
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indicesFlattened, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    const bufferObject = {
        buffer: buffer,
        count: indicesFlattened.length,
        type: gl.UNSIGNED_SHORT,
        offset: 0,
        drawingMode: drawingMode
    };
    return bufferObject;
};
export const bindIndexBuffer = (gl, ibo) => {
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo.buffer);
};
export const drawElements = (gl, ibo) => {
    gl.drawElements(ibo.drawingMode, ibo.count, ibo.type, ibo.offset);
};
/**
 * A shader's attributes get their buffer-values from the VERTEX_ARRAY, but they are constructed in the ARRAY_BUFFER.
 * Textures analogously are served from the TEXTURE_UNITS, while for construction they are bound to ACTIVE_TEXTURE.
 *
 * There is a big difference, however. Contrary to buffers which receive their initial value while still outside the ARRAY_BUFFER,
 * a texture does already have to be bound into the TEXTURE_UNITS when it's being created.
 * Since it'll always be bound into the slot that ACTIVE_TEXTURE points to, you can inadvertently overwrite another texture that is
 * currently in this place. To avoid this, we provide a dedicated `textureConstructionBindPoint`.
 *
 * Buffers are easier in this, since with vertexAttribPointer we are guaranteed to get a slot in the VERTEX_ARRAY that is not
 * already occupied by another buffer.
 */
export const createTexture = (gl, image) => {
    const texture = gl.createTexture(); // analog to createBuffer
    if (!texture) {
        throw new Error('No texture was created');
    }
    gl.activeTexture(gl.TEXTURE0 + textureConstructionBindPoint); // so that we don't overwrite another texture in the next line.
    gl.bindTexture(gl.TEXTURE_2D, texture); // analog to bindBuffer. Binds texture to currently active texture-bindpoint (aka. texture unit).
    const level = 0;
    const internalFormat = gl.RGBA;
    const format = gl.RGBA;
    const type = gl.UNSIGNED_BYTE;
    gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, format, type, image); // analog to bufferData
    gl.generateMipmap(gl.TEXTURE_2D); // mipmaps are mini-versions of the texture.
    gl.bindTexture(gl.TEXTURE_2D, null); // unbinding
    let w, h;
    if (image instanceof HTMLImageElement) {
        w = image.naturalWidth;
        h = image.naturalHeight;
    }
    else {
        w = image.width;
        h = image.height;
    }
    const textureObj = {
        texture: texture,
        level: level,
        internalformat: internalFormat,
        format: format,
        type: type,
        width: w,
        height: h,
        border: 0
    };
    return textureObj;
};
/**
 * This is just another texture, but optimized for carrying data, not for display.
 *
 * Valid combinations of texture-data parameters:
 *
 * | Internal Format | Format          | Type                      | Source Bytes Per Pixel |
 * |-----------------|-----------------|---------------------------|------------------------|
 * | RGBA            | RGBA            | UNSIGNED_BYTE             | 4                      |
 * | RGB	         | RGB             | UNSIGNED_BYTE             | 3                      |
 * | RGBA            | RGBA            | UNSIGNED_SHORT_4_4_4_4    | 2                      |
 * | RGBA            | RGBA            | UNSIGNED_SHORT_5_5_5_1	   | 2                      |
 * | RGB             | RGB             | UNSIGNED_SHORT_5_6_5      | 2                      |
 * | LUMINANCE_ALPHA | LUMINANCE_ALPHA | UNSIGNED_BYTE	           | 2                      |
 * | LUMINANCE       | LUMINANCE       | UNSIGNED_BYTE             | 1                      |
 * | ALPHA           | ALPHA           | UNSIGNED_BYTE             | 1                      |
 * Plus many more in WebGL2.
 *
 */
export const createDataTexture = (gl, data) => {
    const height = data.length;
    const width = data[0].length;
    const channels = data[0][0].length;
    if (!isPowerOf(width, 2) || !isPowerOf(height, 2)) {
        throw new Error(`Texture-data-dimensions must be a power of two, but are ${width} x ${height}`);
    }
    if (channels !== 4) {
        // @todo: remove this when we implement non-rgba data-textures.
        throw new Error(`Expecting 4 channels, but ${channels} provided`);
    }
    const texture = gl.createTexture(); // analog to createBuffer
    if (!texture) {
        throw new Error('No texture was created');
    }
    gl.activeTexture(gl.TEXTURE0 + textureConstructionBindPoint); // so that we don't overwrite another texture in the next line.
    gl.bindTexture(gl.TEXTURE_2D, texture); // analog to bindBuffer. Binds texture to currently active texture-bindpoint (aka. texture unit).
    // to be used for data. we want no interpolation of data, so disallow mipmap and interpolation.
    const level = 0;
    const border = 0;
    const internalFormat = gl.RGBA;
    const format = gl.RGBA;
    const type = gl.UNSIGNED_BYTE;
    const binData = new Uint8Array(flattenRecursive(data));
    if (channels !== 4) {
        // have WebGL digest data one byte at a time.
        // (Per default tries 4 bytes at a time, which causes errors when our data is not a mulitple of 4).
        const alignment = 1; // valid values are 1, 2, 4, and 8.
        gl.pixelStorei(gl.UNPACK_ALIGNMENT, alignment);
    }
    gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, width, height, border, format, type, binData); // analog to bufferData
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.bindTexture(gl.TEXTURE_2D, null); // unbinding
    const textureObj = {
        texture: texture,
        level: level,
        internalformat: internalFormat,
        format: format,
        type: type,
        width: width,
        height: height,
        border: border
    };
    return textureObj;
};
export const createEmptyTexture = (gl, width, height) => {
    if (width <= 0 || height <= 0) {
        throw new Error('Width and height must be positive.');
    }
    const texture = gl.createTexture();
    if (!texture) {
        throw new Error('No texture was created');
    }
    gl.activeTexture(gl.TEXTURE0 + textureConstructionBindPoint); // so that we don't overwrite another texture in the next line.
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.bindTexture(gl.TEXTURE_2D, null);
    const textureObj = {
        texture: texture,
        level: 0,
        internalformat: gl.RGBA,
        format: gl.RGBA,
        type: gl.UNSIGNED_BYTE,
        width: width,
        height: height,
        border: 0
    };
    return textureObj;
};
/**
 * Even though we reference textures as uniforms in a fragment shader, assigning an actual texture-value to that uniform works differently from normal uniforms.
 * Normal uniforms have a concrete value.
 * Texture uniforms, on the other hand, are just an integer-index that points to a special slot in the GPU memory (the bindPoint) where the actual texture value lies.
 */
export const bindTextureToUniform = (gl, texture, bindPoint, uniformLocation) => {
    if (bindPoint > gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS)) {
        throw new Error(`There are only ${gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS)} texture bind points, but you tried to bind to point nr. ${bindPoint}.`);
    }
    if (bindPoint === textureConstructionBindPoint) {
        console.error(`You are about to bind to the dedicated texture-construction bind point (nr. ${bindPoint}).
        If after this call another texture is built, your shader will now use that new texture instead of this one!
        Consider using another bind point.`);
    }
    gl.activeTexture(gl.TEXTURE0 + bindPoint); // analog to enableVertexAttribArray
    gl.bindTexture(gl.TEXTURE_2D, texture); // analog to bindBuffer. Binds texture to currently active texture-bindpoint (aka. texture unit).
    gl.uniform1i(uniformLocation, bindPoint); // analog to vertexAttribPointer
};
export const updateTexture = (gl, to, newData) => {
    gl.activeTexture(gl.TEXTURE0 + textureConstructionBindPoint); // so that we don't overwrite another texture in the next line.
    gl.bindTexture(gl.TEXTURE_2D, to.texture); // analog to bindBuffer. Binds texture to currently active texture-bindpoint (aka. texture unit).
    if (newData instanceof HTMLImageElement || newData instanceof HTMLCanvasElement) {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, newData); // analog to bufferData
    }
    else {
        const width = newData[0].length;
        const height = newData.length;
        if (!isPowerOf(width, 2) || !isPowerOf(height, 2)) {
            throw new Error(`Texture-data-dimensions must be a power of two, but are ${height} x ${width}`);
        }
        const binData = new Uint8Array(flattenRecursive(newData)); // @todo: use another ArrayBufferView depending on to.format?
        gl.texImage2D(gl.TEXTURE_2D, to.level, to.internalformat, to.width, to.height, to.border, to.format, to.type, binData);
    }
    gl.generateMipmap(gl.TEXTURE_2D); // mipmaps are mini-versions of the texture.
    gl.bindTexture(gl.TEXTURE_2D, null); // unbinding
    if (newData instanceof HTMLImageElement) {
        to.width = newData.naturalWidth;
        to.height = newData.naturalHeight;
    }
    else if (newData instanceof HTMLCanvasElement) {
        to.width = newData.width;
        to.height = newData.height;
    }
    else {
        to.width = newData[0].length;
        to.height = newData.length;
    }
    return to;
};
export const createFramebuffer = (gl) => {
    const fb = gl.createFramebuffer(); // analog to createBuffer
    if (!fb) {
        throw new Error(`Error creating framebuffer`);
    }
    return fb;
};
/**
 * The operations `clear`, `drawArrays` and `drawElements` only affect the currently bound framebuffer.
 *
 * Note that binding the framebuffer does *not* mean binding its texture.
 * In fact, if there is a bound texture, it must be the *input* to a shader, not the output.
 * Therefore, a framebuffer's texture must not be bound when the framebuffer is.
 */
export const bindFramebuffer = (gl, fbo, manualViewport) => {
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer);
    // It's EXTREMELY IMPORTANT to remember to call gl.viewport and set it to the size of the thing your rendering to.
    // https://webglfundamentals.org/webgl/lessons/webgl-render-to-texture.html
    if (manualViewport) {
        if ((fbo.width / fbo.height) !== (manualViewport[2] / manualViewport[3])) {
            console.warn(`Your viewport-aspect is different from the framebuffer-aspect.`);
        }
        gl.viewport(...manualViewport);
    }
    else {
        gl.viewport(0, 0, fbo.width, fbo.height);
    }
};
/**
 * Webgl renders to the viewport, which is relative to canvas.width * canvas.height.
 * (To be more precise, only *polygons* are clipped to the viewport.
 * Operations like `clearColor()` et.al., will still draw to the *full* canvas.width * height!
 * If you want to also constrain clearColor, use `scissor` instead of viewport.)
 * That canvas.width * canvas.height then gets stretched to canvas.clientWidth * canvas.clientHeight.
 * (Note: the full canvas.width gets stretched to clientWidth, not just the viewport!)
 */
export const bindOutputCanvasToFramebuffer = (gl, manualViewport) => {
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    // It's EXTREMELY IMPORTANT to remember to call gl.viewport and set it to the size of the thing your rendering to.
    // https://webglfundamentals.org/webgl/lessons/webgl-render-to-texture.html
    if (manualViewport) {
        if ((gl.canvas.width / gl.canvas.height) !== (manualViewport[2] / manualViewport[3])) {
            console.warn(`Your viewport-aspect is different from the canvas-aspect.`);
        }
        gl.viewport(...manualViewport);
    }
    else {
        // Note: don't use clientWidth here.
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    }
};
/**
 * A framebuffer can have a texture - that is the bitmap that the shader-*out*put is drawn on.
 * Shaders may also have one or more *in*put texture(s), which must be provided to the shader as a uniform sampler2D.
 * Only the shader needs to know about any potential input texture, the framebuffer will always only know about it's output texture.
 */
export const bindTextureToFramebuffer = (gl, texture, fb) => {
    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture.texture, 0); // analog to bufferData
    if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {
        throw new Error(`Error creating framebuffer: framebuffer-status: ${gl.checkFramebufferStatus(gl.FRAMEBUFFER)} ; error-code: ${gl.getError()}`);
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    const fbo = {
        framebuffer: fb,
        texture: texture,
        width: texture.width,
        height: texture.height
    };
    return fbo;
};
/**
 * Fetch uniform's location (uniform declared in some shader). Slow! Do *before* render loop.
 */
export const getUniformLocation = (gl, program, uniformName) => {
    const loc = gl.getUniformLocation(program, uniformName);
    if (loc === null) {
        throw new Error(`Couldn't find uniform ${uniformName} in program.`);
    }
    return loc;
};
/**
 * Contrary to attributes, uniforms don't need to be stored in a buffer. (Note: in WebGL 2.0, however, there *are* uniform buffers!)
 *
 * 'v' is not about the shader, but how you provide data from the js-side.
 * uniform1fv(loc, [3.19]) === uniform1f(loc, 3.19)
 *
 * |js                                      |          shader                  |
 * |----------------------------------------|----------------------------------|
 * |uniform1f(loc, 3.19)                    |  uniform float u_pi;             |
 * |uniform2f(loc, 3.19, 2.72)              |  uniform vec2 u_constants;       |
 * |uniform2fv(loc, [3.19, 2.72])           |  uniform vec2 u_constants;       |
 * |uniform1fv(loc, [1, 2, 3, 4, 5, 6])     |  uniform float u_kernel[6];      |
 * |uniform2fv(loc, [1, 2, 3, 4, 5, 6])     |  uniform vec2 u_observations[3]; |
 * |uniformMatrix3fv(loc, [[...], [...]])   |  uniform mat3 u_matrix;          |
 *
 * A note about `structs`. A shader code like this:
 * ```glsl
 * struct LightInfo {
 *    vec4 Position;
 *    vec3 La;
 * };
 * uniform LightInfo Light;
 * ```
 * ... is accessed like that:
 * ```js
 * const lightPosLoc = gl.getUniformLocation(program, "Light.Position");
 * const lightLaLoc = gl.getUniformLocation(program, "Light.La");
 * gl.uniform4fv(lightPosLoc, [1, 2, 3, 4]);
 * gl.uniform3fv(lightLaLoc, [1, 2, 3]);
 * ```
 *
 */
export const bindValueToUniform = (gl, uniformLocation, type, values) => {
    switch (type) {
        case 'bool':
            gl.uniform1i(uniformLocation, values[0]);
            break;
        case 'bvec2':
            gl.uniform2i(uniformLocation, values[0], values[1]);
            break;
        case 'bvec3':
            gl.uniform3i(uniformLocation, values[0], values[1], values[2]);
            break;
        case 'bvec4':
            gl.uniform4i(uniformLocation, values[0], values[1], values[2], values[3]);
            break;
        case 'bool[]':
            gl.uniform1iv(uniformLocation, values);
            break;
        case 'bvec2[]':
            gl.uniform2iv(uniformLocation, values);
            break;
        case 'bvec3[]':
            gl.uniform3iv(uniformLocation, values);
            break;
        case 'bvec4[]':
            gl.uniform4iv(uniformLocation, values);
            break;
        case 'int':
            gl.uniform1i(uniformLocation, values[0]);
            break;
        case 'ivec2':
            gl.uniform2i(uniformLocation, values[0], values[1]);
            break;
        case 'ivec3':
            gl.uniform3i(uniformLocation, values[0], values[1], values[2]);
            break;
        case 'ivec4':
            gl.uniform4i(uniformLocation, values[0], values[1], values[2], values[3]);
            break;
        case 'int[]':
            gl.uniform1iv(uniformLocation, values);
            break;
        case 'ivec2[]':
            gl.uniform2iv(uniformLocation, values);
            break;
        case 'ivec3[]':
            gl.uniform3iv(uniformLocation, values);
            break;
        case 'ivec4[]':
            gl.uniform4iv(uniformLocation, values);
            break;
        case 'float':
            gl.uniform1f(uniformLocation, values[0]);
            break;
        case 'vec2':
            gl.uniform2f(uniformLocation, values[0], values[1]);
            break;
        case 'vec3':
            gl.uniform3f(uniformLocation, values[0], values[1], values[2]);
            break;
        case 'vec4':
            gl.uniform4f(uniformLocation, values[0], values[1], values[2], values[3]);
            break;
        case 'float[]':
            gl.uniform1fv(uniformLocation, values);
            break;
        case 'vec2[]':
            gl.uniform2fv(uniformLocation, values);
            break;
        case 'vec3[]':
            gl.uniform3fv(uniformLocation, values);
            break;
        case 'vec4[]':
            gl.uniform4fv(uniformLocation, values);
            break;
        // In the following *matrix* calls, the 'transpose' parameter must always be false.
        // Quoting the OpenGL ES 2.0 spec:
        // If the transpose parameter to any of the UniformMatrix* commands is
        // not FALSE, an INVALID_VALUE error is generated, and no uniform values are
        // changed.
        case 'mat2':
            gl.uniformMatrix2fv(uniformLocation, false, values);
            break;
        case 'mat3':
            gl.uniformMatrix3fv(uniformLocation, false, values);
            break;
        case 'mat4':
            gl.uniformMatrix4fv(uniformLocation, false, values);
            break;
        default:
            throw Error(`Type ${type} not implemented.`);
    }
};
/**
 * (From https://hacks.mozilla.org/2013/04/the-concepts-of-webgl/ and https://stackoverflow.com/questions/56303648/webgl-rendering-buffers:)
 * Ignoring handmade framebuffers, WebGl has two framebuffers that are always in use: the `frontbuffer/displaybuffer` and the `backbuffer/drawingbuffer`.
 * WebGl per default renders to the `drawingbuffer`, aka. the `backbuffer`.
 * There is also the currently displayed buffer, named the `frontbuffer` aka. the `displaybuffer`.
 * the WebGL programmer has no explicit access to the frontbuffer whatsoever.
 *
 * Once you called `clear`, `drawElements` or `drawArrays`, the browser marks the canvas as `needs to be composited`.
 * Assuming `preserveDrawingBuffer == false` (the default): Immediately before compositing, the browser
 *  - swaps the back- and frontbuffer
 *  - clears the new backbuffer.
 * If `preserveDrawingBuffer === true`: Immediately before compositing, the browser
 *  - copies the drawingbuffer to the frontbuffer.
 *
 * As a consequence, if you're going to use canvas.toDataURL or canvas.toBlob or gl.readPixels or any other way of getting data from a WebGL canvas,
 * unless you read it in the same event then it will likely be clear when you try to read it.
 *
 * In the past, old games always preserved the drawing buffer, so they'd only have to change those pixels that have actually changed. Nowadays preserveDrawingBuffer is false by default.
 *
 * A (almost brutal) workaround to get the canvas to preserve the drawingBuffer can be found here: https://stackoverflow.com/questions/26783586/canvas-todataurl-returns-blank-image
 */
export const getCurrentFramebuffersPixels = (canvas) => {
    const gl = canvas.getContext('webgl');
    if (!gl) {
        throw new Error('no context');
    }
    const format = gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_FORMAT);
    const type = gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_TYPE);
    let pixels;
    if (type === gl.UNSIGNED_BYTE) {
        pixels = new Uint8Array(gl.drawingBufferWidth * gl.drawingBufferHeight * 4);
    }
    else if (type === gl.UNSIGNED_SHORT_5_6_5 || type === gl.UNSIGNED_SHORT_4_4_4_4 || type === gl.UNSIGNED_SHORT_5_5_5_1) {
        pixels = new Uint16Array(gl.drawingBufferWidth * gl.drawingBufferHeight * 4);
    }
    else if (type === gl.FLOAT) {
        pixels = new Float32Array(gl.drawingBufferWidth * gl.drawingBufferHeight * 4);
    }
    else {
        throw new Error(`Did not understand pixel data type ${type} for format ${format}`);
    }
    // Just like `toDataURL` or `toBlob`, `readPixels` does not access the frontbuffer.
    // It accesses the backbuffer or any other currently active framebuffer.
    gl.readPixels(0, 0, canvas.width, canvas.height, format, type, pixels);
    return pixels;
};
export const getDebugInfo = (gl) => {
    const baseInfo = {
        renderer: gl.getParameter(gl.RENDERER),
        currentProgram: gl.getParameter(gl.CURRENT_PROGRAM),
        arrayBuffer: gl.getParameter(gl.ARRAY_BUFFER_BINDING),
        elementArrayBuffer: gl.getParameter(gl.ELEMENT_ARRAY_BUFFER_BINDING),
        frameBuffer: gl.getParameter(gl.FRAMEBUFFER_BINDING),
        renderBuffer: gl.getParameter(gl.RENDERBUFFER_BINDING),
        texture: gl.getParameter(gl.TEXTURE_BINDING_2D),
        viewPort: gl.getParameter(gl.VIEWPORT)
    };
    const programInfo = {
        infoLog: gl.getProgramInfoLog(baseInfo.currentProgram)
    };
    return {
        baseInfo, programInfo
    };
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2ViZ2wuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy91dGlscy1tYXBzL3NyYy9saWIvd2ViZ2wvd2ViZ2wudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXFFRztBQUVILE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxTQUFTLEVBQUUsTUFBTSxTQUFTLENBQUM7QUFJdEQsTUFBTSwyQkFBMkIsR0FBRyxDQUFDLENBQUM7QUFDdEMsTUFBTSw0QkFBNEIsR0FBRyxDQUFDLENBQUM7QUFLdkM7O0dBRUc7QUFDSCxNQUFNLENBQUMsTUFBTSxhQUFhLEdBQUcsQ0FBQyxFQUF5QixFQUFFLE9BQWUsRUFBRSxZQUFvQixFQUFlLEVBQUU7SUFDM0csTUFBTSxNQUFNLEdBQUcsRUFBRSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUN4QyxJQUFJLENBQUMsTUFBTSxFQUFFO1FBQ1QsTUFBTSxJQUFJLEtBQUssQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO0tBQzVDO0lBQ0QsRUFBRSxDQUFDLFlBQVksQ0FBQyxNQUFNLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFDdEMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUN6QixJQUFJLENBQUMsRUFBRSxDQUFDLGtCQUFrQixDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsY0FBYyxDQUFDLEVBQUU7UUFDbkQsRUFBRSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUN4QixNQUFNLElBQUksS0FBSyxDQUFDLDJDQUEyQyxFQUFFLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxDQUFDLDBCQUEwQixZQUFZLEVBQUUsQ0FBQyxDQUFDO0tBQ25JO0lBQ0QsT0FBTyxNQUFNLENBQUM7QUFDbEIsQ0FBQyxDQUFDO0FBR0Y7Ozs7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L0MsUUFBUSxFQUFFLEVBQUUsQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQztLQUN6QyxDQUFDO0lBQ0YsTUFBTSxXQUFXLEdBQUc7UUFDaEIsT0FBTyxFQUFFLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDO0tBQ3pELENBQUM7SUFDRixPQUFPO1FBQ0gsUUFBUSxFQUFFLFdBQVc7S0FDeEIsQ0FBQTtBQUNMLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogV0VCR0xcbiAqXG4gKiBBIHJhc3Rlcml6YXRpb24gZW5naW5lIHRoYXQgYWxsb3dzIHRvIGRyYXcgcG9pbnRzLCBsaW5lIHNlZ21lbnRzLCBvciB0cmlhbmdsZXMuXG4gKlxuICogVmVydGV4IHNoYWRlcnMgdGFrZSB3aGF0ZXZlciBjb29yZGluYXRlcyB5b3UgdXNlIGFuZCByZXR1cm4gYSAzLWQgYXJyYXkgd2l0aCBlbGVtZW50cyBiZXR3ZWVuIC0xIGFuZCAxLlxuICogQmFzaWNhbGx5LCB0aGlzIGlzIGEgM2QtYXJyYXksIGJ1dCBXZWJHbCBkb2VzIG5vdCB1c2UgdGhlIHotYXhpcyBmb3IgcmVhbCBwZXJzcGVjdGl2ZSwgYnV0IG9ubHkgdG8gZGlmZmVyZW50aWF0ZVxuICogd2hhdCBwaXhlbCBsaWVzIGluIGZyb250IG9mIGFub3RoZXIuXG4gKiBUaGlzIGlzIG5vdCBsaWtlIGxvb2tpbmcgaW4gYSAzZC1ib3gsIGJ1dCByYXRoZXIgbGlrZSBsb29raW5nIG9uIG11bHRpcGxlIHN0YWNrZWQgc2hlZXRzIG9uIGEgcHJvamVjdG9yLlxuICogQWN0dWFsbHksIHRoaXMgaXMgYSBsaWUuIFdlYkdsIHVzZXMgNCBjb29yZGluYXRlczogeCwgeSwgeiBhbmQgdy4gVGhlIGFib3ZlIG9ubHkgaG9sZHMgaWYgeW91IGtlZXAgdyBhdCAxLlxuICogQWZ0ZXIgYXBwbHlpbmcgdGhlIHZlcnRleCBzaGFkZXIsIFdlYkdsIGRpdmlkZXMgYWxsIGNvb3JkaW5hdGVzIGJ5IHcsIHlpZWxkaW5nICh4L3csIHkvdywgei93LCAxKS5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gY2FsY3VsYXRlIHByb2plY3Rpb25zIC0gZ29vZ2xlIGZvciAnaG9tb2dlbmVvdXMgY29vcmRpbmF0ZXMnIHRvIGZpbmQgb3V0IG1vcmUuXG4gKiBDb21wYXJlIHRoaXMgW3NpdGVdKGh0dHBzOi8vd3d3LnRvbWRhbGxpbmcuY29tL2Jsb2cvbW9kZXJuLW9wZW5nbC9leHBsYWluaW5nLWhvbW9nZW5vdXMtY29vcmRpbmF0ZXMtYW5kLXByb2plY3RpdmUtZ2VvbWV0cnkvKVxuICogYW5kIHRoZSBzaGFkZXIgYGJhc2ljM2QudmVydC5nbHNsYC5cbiAqXG4gKiBXZWJHTCBrbm93cyB0d28gZGF0YSBzdHJ1Y3R1cmVzOlxuICogIC0gYnVmZmVycyAoZ2VuZXJpYyBieXRlIGFycmF5cyk6IHVzdWFsbHkgcG9zaXRpb25zLCBub3JtYWxzLCB0ZXh0dXJlLWNvb3JkaW5hdGVzLCB2ZXJ0ZXgtY29sb3JzIGV0Yy5cbiAqICAgIGJ1ZmZlcnMgYXJlIGFjY2Vzc2VkIGluIHNoYWRlcnMgYXMgJ2F0dHJpYnV0ZXMnLlxuICogICAgbm90ZSB0aGF0IGJ1ZmZlcnMgY29udGFpbiBvbmUgZW50cnkgZm9yIGVhY2ggdmVydGV4LlxuICogIC0gdGV4dHVyZXMgKGJpdG1hcCBpbWFnZXMpLlxuICpcbiAqIFNoYWRlcnMgdXNlIHRoZXNlIGRhdGEgc3RydWN0dXJlcyBpbiB0d28gZGlmZmVyZW50IHdheXMuXG4gKiAgLSBBdHRyaWJ1dGVzIGFyZSB2YWx1ZXMsIG9uZSBwZXIgdmVydGV4LlxuICogICAgRm9yIHRoZSBzaGFkZXIsIGF0dHJpYnV0ZXMgYXJlIHJlYWQtb25seS5cbiAqICAgIEF0dHJpYnV0ZXMgZGVmYXVsdCB0byBbMCwgMCwgMCwgMV1cbiAqICAtIFVuaWZvcm1zIGFyZSB2YWx1ZXMsIG9uZSBwZXIgc2hhZGVyLlxuICogICAgRm9yIHRoZSBzaGFkZXIsIHVuaWZvcm1zIGFyZSByZWFkLW9ubHkuXG4gKlxuICogQXBhcnQgZnJvbSB0aGlzLCBzaGFkZXJzIGtub3cgYWJvdXQgdHdvIG1vcmUgdHlwZXMgb2YgZGF0YTpcbiAqICAtIFZhcnlpbmdzIGFyZSB2YWx1ZXMgdGhhdCBhcmUgcGFzc2VkIGZyb20gdmVydGV4LXNoYWRlciB0byBmcmFnbWVudC1zaGFkZXIuXG4gKiAgICBUaGV5IGFyZSByZWFkLW9ubHkgb25seSBmb3IgdGhlIGZyYWdtZW50LXNoYWRlci5cbiAqICAtIENvbnN0OiBhIGNvbXBpbGUtdGltZSBjb25zdGFudC5cbiAqXG4gKiBBIHByb2dyYW0gaXMganVzdCBhIGxpc3Qgb2YgY29tcGlsZWQgYW5kIGxpbmtlZCB2ZXJ0ZXgtIGFuZCBmcmFnbWVudC1zaGFkZXJzLlxuICpcbiAqXG4gKiBEcmF3aW5nOiB0aGVyZSdzIGRyYXdBcnJheXMgYW5kIGRyYXdFbGVtZW50cy5cbiAqICAtIGRyYXdBcnJheXMgaXMgdGhlIHJvYnVzdCBhbGwtcm91bmRlci5cbiAqICAtIGRyYXdFbGVtZW50cyBjYW4gYmUgbW9yZSBwZXJmb3JtYW50IGlmIHlvdSBzaGFyZSB2ZXJ0aWNlcyBiZXR3ZWVuIG9iamVjdHMuXG4gKlxuICpcbiAqIFJlbmRlcmluZyBkYXRhIGlzIGZhc3QsIGJ1dCB1cGxvYWRpbmcgaXQgaW50byBHUFUgbWVtb3J5IGlzIHNsb3cuXG4gKiBPcHRpbWl6aW5nIFdlYkdsIHBlcmZvcm1hbmNlIG1vc3RseSBtZWFuczogQXZvaWRpbmcgaGF2aW5nIEdQVSBhbmQgQ1BVIHdhaXQgZm9yIGVhY2ggb3RoZXIuXG4gKiBUaGUgbW9yZSB0aGUgR1BVIGNhbiBkbyBpbiBidWxrLCB0aGUgYmV0dGVyLiBUaGUgbW9yZSBvZnRlbiB5b3UgaGF2ZSB0byB1cGxvYWQgZGF0YSBmcm9tIENQVSB0byBHUFUsIHRoZSB3b3JzZS5cbiAqICAtIFNvIGF2b2lkIHN3aXRjaGluZyBwcm9ncmFtcywgYnVmZmVycyBhbmQgdW5pZm9ybXMgaWYgeW91IGNhbi5cbiAqICAgIChZb3Ugd29uJ3QgYmUgYWJsZSB0byBhdm9pZCBzd2l0Y2hpbmcgYnVmZmVycywgYmVjYXVzZSBldmVyeSBvYmplY3QgaXMgbGlrZWx5IGRpZmZlcmVudC4gQnV0IHNvcnQgeW91ciBvYmplY3RzIGJ5IHRoZWlyIHNoYWRlcnMsIGFuZCB5b3UnbGwgc2F2ZSBhIGxvdCBvZiB0aW1lLilcbiAqICAtIFRyeSB0byBkbyB0cmFuc2xhdGlvbnMsIHJvdGF0aW9ucyBhbmQgc2hlYXJzIGluc2lkZSB0aGUgdmVydGV4LXNoYWRlciBpbnN0ZWFkIG9mIGFsdGVyaW5nIHRoZSBvYmplY3QncyBidWZmZXIuXG4gKiAgLSBJZiBhcHByb3ByaWF0ZSwgY3JlYXRlIMO8YmVyLXNoYWRlcnMgYW5kIMO8YmVyLWJ1ZmZlcnMsIHRoYXQgY29udGFpbiBpbmZvcm1hdGlvbiBmb3IgbW9yZSB0aGFuIGp1c3Qgb25lIG9iamVjdC5cbiAqXG4gKiBUaGVyZSBpcyBhbm90aGVyIHRoaW5nIHRoYXQgYWZmZWN0cyBwZXJmb3JtYW5jZTpcbiAqIFdlYkdMIHdpbGwgb25seSBydW4gZnJhZ21lbnQtc2hhZGVycyB3aGVuIHRoZSBvYmplY3QncyBwaXhlbHMgYXJlbid0IGFscmVhZHkgb2JzY3VyZWQgYnkgYSBsYXJnZXIgb2JqZWN0IGluIGZyb250IG9mIGl0LlxuICogVGhhdCBtZWFucyBpdCBtYWtlcyBzZW5zZSB0byBmaXJzdCBkcmF3IGxhcmdlIG9iamVjdHMgdGhhdCBhcmUgY2xvc2UgdG8gdGhlIGNhbWVyYSAtIGFsbCBvYmplY3RzIGJlaGluZCB0aGVtIHdvbid0IG5lZWQgdGhlaXIgZnJhZ21lbnQtc2hhZGVyIGV4ZWN1dGVkLlxuICpcbiAqIEFsbCBgY3JlYXRlKmAgZnVuY3Rpb25zIHVuYmluZCB2YXJpYWJsZXMgYWZ0ZXIgc2V0dGluZyB0aGVpciB2YWx1ZXMuIFRoaXMgaXMgdG8gYXZvaWQgdW53YW50ZWQgc2lkZS1lZmZlY3RzLlxuICpcbiAqXG4gKlxuICogV2ViR0wgY29tcG9uZW50c1xuICogICAgLSBnbG9iYWwtc3RhdGVcbiAqICAgICAgICAtIEFSUkFZX0JVRkZFUl9CSU5ESU5HOiBjdXJyZW50bHkgYm91bmQgYnVmZmVyXG4gKiAgICAgICAgLSBWRVJURVhfQVJSQVlfQklORElORzogY3VycmVudGx5IGJvdW5kIHZlcnRleC1hcnJheSAoaW4gV2ViR0wgMSB0aGlzIHdhcyBhbHdheXMgb25seSB0aGUgZ2xvYmFsIHZlcnRleC1hcnJheSwgaW4gV2ViR0wgMiB5b3UgY2FuIG5vdyBjcmVhdGUgeW91ciBvd24gb25lcylcbiAqICAgICAgICAtIEFDVElWRV9URVhUVVJFOiBjdXJyZW50bHkgYm91bmQgdGV4dHVyZVxuICogICAgICAgIC0gdGV4dHVyZS11bml0czogYSBsaXN0IG9mIHBvaW50ZXJzIHRvIHRleHR1cmUtYnVmZmVycy5cbiAqICAgICAgICAtIHVuaWZvcm0tYnVmZmVyLWJpbmRpbmdzIChXZWJHTDIgb25seSk6IGEgbGlzdCBvZiBwb2ludGVycyB0byB1bmlmb3JtLWJ1ZmZlcnMuXG4gKiAgICAtIHZlcnRleC1hcnJheTogYSBsaXN0IG9mIHBvaW50ZXJzIHRvIGF0dHJpYnV0ZS1idWZmZXJzICgrIG1ldGFkYXRhIGxpa2UgZGF0YXR5cGUsIHN0cmlkZSwgb2Zmc2V0IGV0Yy4pLlxuICogICAgICAgIC0gYWxsIGF0dHJpYnV0ZXMgbXVzdCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cyAodGhvdWdoIG9uZSBhdHRyaWJ1dGUncyBlbGVtZW50cyBtYXkgYmUgdmVjMidzLCB3aGlsZSBhbm90aGVyIG9uZSdzIG1heSBiZSB2ZWMzJ3MpXG4gKiAgICAgICAgLSBkcmF3QXJyYXk6IGF0dHJpYnV0ZXMgcmVwZWF0IGVsZW1lbnRzIGluIGdyb3VwcyBvZiB0aHJlZSBmb3IgZHJhd2luZyB0cmlhbmdsZXNcbiAqICAgICAgICAtIGRyYXdFbGVtZW50czogdGhlIGluZGljZXMgZm9yIHRoZSB0cmlhbmdsZXMgYXJlIGRlZmluZWQgaW4gRUxFTUVOVF9BUlJBWV9CVUZGRVJfQklORElOR1xuICogICAgICAgIC0gV2ViR0wgMi4wOiBhbGxvd3MgeW91IHRvIGNyZWF0ZSB5b3VyIG93biB2ZXJ0ZXgtYXJyYXlzLCB3aGVyZWFzIDEuMCBhbHdheXMgb25seSB1c2VkIG9uZSBnbG9iYWwgdmVydGV4LWFycmF5LlxuICovXG5cbmltcG9ydCB7IGZsYXR0ZW5SZWN1cnNpdmUsIGlzUG93ZXJPZiB9IGZyb20gJy4vdXRpbHMnO1xuXG5cblxuY29uc3Qgc2hhZGVySW5wdXRUZXh0dXJlQmluZFBvaW50ID0gMDtcbmNvbnN0IHRleHR1cmVDb25zdHJ1Y3Rpb25CaW5kUG9pbnQgPSA3O1xuXG5cblxuXG4vKipcbiAqIENvbXBpbGUgc2hhZGVyLlxuICovXG5leHBvcnQgY29uc3QgY29tcGlsZVNoYWRlciA9IChnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCB0eXBlQml0OiBudW1iZXIsIHNoYWRlclNvdXJjZTogc3RyaW5nKTogV2ViR0xTaGFkZXIgPT4ge1xuICAgIGNvbnN0IHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcih0eXBlQml0KTtcbiAgICBpZiAoIXNoYWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNoYWRlciB3YXMgY3JlYXRlZCcpO1xuICAgIH1cbiAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzaGFkZXJTb3VyY2UpO1xuICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcbiAgICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgICAgICBnbC5kZWxldGVTaGFkZXIoc2hhZGVyKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbiBlcnJvciBvY2N1cnJlZCBjb21waWxpbmcgdGhlIHNoYWRlcjogJHtnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcil9LiAgICBcXG5cXG4gU2hhZGVyIGNvZGU6ICR7c2hhZGVyU291cmNlfWApO1xuICAgIH1cbiAgICByZXR1cm4gc2hhZGVyO1xufTtcblxuXG4vKipcbiAqIE5vdGUgdGhhdCBldmVyeSBwcm9ncmFtICptdXN0KiBoYXZlIG9uZSBhbmQgb25seSBvbmUgdmVydGV4LXNoYWRlclxuICogYW5kIG9uZSBhbmQgb25seSBvbmUgZnJhZ21lbnQgc2hhZGVyLlxuICogVGhhdCBtZWFucyB5b3UgY2Fubm90IGFkZCBtdWx0aXBsZSBmcmFnbWVudC1zaGFkZXJzIGluIG9uZSBwcm9ncmFtLiBJbnN0ZWFkLCBlaXRoZXIgbG9hZCB0aGVtIGluIGNvbnNlY3V0aXZlbHkgYXMgcGFydCBvZiBkaWZmZXJlbnQgcHJvZ3JhbXMsXG4gKiBvciBnZW5lcmF0ZSBhbiDDvGJlci1zaGFkZXIgdGhhdCBjb250YWlucyBib3RoIGNvZGVzLlxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlU2hhZGVyUHJvZ3JhbSA9IChnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCB2ZXJ0ZXhTaGFkZXJTb3VyY2U6IHN0cmluZywgZnJhZ21lbnRTaGFkZXJTb3VyY2U6IHN0cmluZyk6IFdlYkdMUHJvZ3JhbSA9PiB7XG5cbiAgICBjb25zdCBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICAgIGlmICghcHJvZ3JhbSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHByb2dyYW0gd2FzIGNyZWF0ZWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCB2ZXJ0ZXhTaGFkZXIgPSBjb21waWxlU2hhZGVyKGdsLCBnbC5WRVJURVhfU0hBREVSLCB2ZXJ0ZXhTaGFkZXJTb3VyY2UpO1xuICAgIGNvbnN0IGZyYWdtZW50U2hhZGVyID0gY29tcGlsZVNoYWRlcihnbCwgZ2wuRlJBR01FTlRfU0hBREVSLCBmcmFnbWVudFNoYWRlclNvdXJjZSk7XG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcblxuICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuXG4gICAgZ2wuZGV0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XG4gICAgZ2wuZGV0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcbiAgICBnbC5kZWxldGVTaGFkZXIodmVydGV4U2hhZGVyKTtcbiAgICBnbC5kZWxldGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xuXG4gICAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSkge1xuICAgICAgICBnbC5kZWxldGVQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBpbml0aWFsaXplIHRoZSBzaGFkZXIgcHJvZ3JhbTogJyArIGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvZ3JhbTtcbn07XG5cblxuZXhwb3J0IGNvbnN0IHNldHVwM2RTY2VuZSA9IChnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0KTogdm9pZCA9PiB7XG4gICAgZ2wudmlld3BvcnQoMCwgMCwgZ2wuY2FudmFzLndpZHRoLCBnbC5jYW52YXMuaGVpZ2h0KTtcbiAgICBnbC5lbmFibGUoZ2wuREVQVEhfVEVTVCk7XG4gICAgZ2wuZGVwdGhGdW5jKGdsLkxFUVVBTCk7XG4gICAgZ2wuY3VsbEZhY2UoZ2wuQkFDSyk7XG4gICAgY2xlYXJCYWNrZ3JvdW5kKGdsLCBbMCwgMCwgMCwgMV0pO1xufTtcblxuZXhwb3J0IGNvbnN0IHVwZGF0ZVZpZXdQb3J0ID0gKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIHgwOiBudW1iZXIsIHkwOiBudW1iZXIsIHgxOiBudW1iZXIsIHkxOiBudW1iZXIpOiB2b2lkID0+IHtcbiAgICBnbC52aWV3cG9ydCh4MCwgeTAsIHgxLCB5MSk7XG59O1xuXG5cbmV4cG9ydCBjb25zdCBiaW5kUHJvZ3JhbSA9IChnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBwcm9ncmFtOiBXZWJHTFByb2dyYW0pOiB2b2lkID0+IHtcbiAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xufTtcblxuXG5leHBvcnQgY29uc3QgY2xlYXJCYWNrZ3JvdW5kID0gKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIGNvbG9yOiBudW1iZXJbXSk6IHZvaWQgPT4ge1xuICAgIGdsLmNsZWFyQ29sb3IoY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSwgY29sb3JbM10pO1xuICAgIGdsLmNsZWFyRGVwdGgoMS4wKTtcbiAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUIHwgZ2wuREVQVEhfQlVGRkVSX0JJVCk7XG59O1xuXG5cbiAvKipcbiAgKiBBIGdlbmVyaWMgYnVmZmVyLCB0b2dldGhlciB3aXRoIGl0J3MgbWV0YWRhdGEuXG4gICovXG5leHBvcnQgaW50ZXJmYWNlIEJ1ZmZlck9iamVjdCB7XG4gICAgYnVmZmVyOiBXZWJHTEJ1ZmZlcjtcbiAgICB2ZWN0b3JTaXplOiBudW1iZXI7XG4gICAgdmVjdG9yQ291bnQ6IG51bWJlcjtcbiAgICB0eXBlOiBudW1iZXI7XG4gICAgbm9ybWFsaXplOiBib29sZWFuO1xuICAgIHN0cmlkZTogbnVtYmVyO1xuICAgIG9mZnNldDogbnVtYmVyO1xuICAgIGRyYXdpbmdNb2RlOiBudW1iZXI7IC8vIGdsLlRSSUFOR0xFUywgZ2wuUE9JTlRTLCBvciBnbC5MSU5FU1xufVxuXG5cbi8qKlxuICogQ3JlYXRlIGJ1ZmZlci4gQ3JlYXRpb24gaXMgc2xvdyEgRG8gKmJlZm9yZSogcmVuZGVyIGxvb3AuXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVGbG9hdEJ1ZmZlciA9IChnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBkYXRhOiBudW1iZXJbXVtdLCBkcmF3aW5nTW9kZTogbnVtYmVyID0gZ2wuVFJJQU5HTEVTKTogQnVmZmVyT2JqZWN0ID0+IHtcblxuICAgIGNvbnN0IGRhdGFGbGF0dGVuZWQgPSBuZXcgRmxvYXQzMkFycmF5KGZsYXR0ZW5SZWN1cnNpdmUoZGF0YSkpO1xuXG4gICAgY29uc3QgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgaWYgKCFidWZmZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBidWZmZXIgd2FzIGNyZWF0ZWQnKTtcbiAgICB9XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGRhdGFGbGF0dGVuZWQsIGdsLlNUQVRJQ19EUkFXKTtcbiAgICAvLyBTVEFUSUNfRFJBVzogdGVsbHMgV2ViR2wgdGhhdCB3ZSBhcmUgbm90IGxpa2VseSB0byBjaGFuZ2UgdGhpcyBkYXRhIG11Y2guXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIG51bGwpOyAgLy8gdW5iaW5kaW5nXG5cbiAgICBjb25zdCBidWZmZXJPYmplY3Q6IEJ1ZmZlck9iamVjdCA9IHtcbiAgICAgICAgYnVmZmVyOiBidWZmZXIsXG4gICAgICAgIHZlY3RvclNpemU6IGRhdGFbMF0ubGVuZ3RoLFxuICAgICAgICB2ZWN0b3JDb3VudDogZGF0YS5sZW5ndGgsXG4gICAgICAgIHR5cGU6IGdsLkZMT0FULCAgIC8vIHRoZSBkYXRhIGlzIDMyYml0IGZsb2F0c1xuICAgICAgICBub3JtYWxpemU6IGZhbHNlLCAvLyBkb24ndCBub3JtYWxpemUgdGhlIGRhdGFcbiAgICAgICAgc3RyaWRlOiAwLCAgICAgICAgLy8gMCA9IG1vdmUgZm9yd2FyZCBzaXplICogc2l6ZW9mKHR5cGUpIGVhY2ggaXRlcmF0aW9uIHRvIGdldCB0aGUgbmV4dCBwb3NpdGlvbi4gT25seSBjaGFuZ2UgdGhpcyBpbiB2ZXJ5LWhpZ2gtcGVyZm9ybWFuY2Ugam9icy5cbiAgICAgICAgb2Zmc2V0OiAwLCAgICAgICAgLy8gc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYnVmZmVyLiBPbmx5IGNoYW5nZSB0aGlzIGluIHZlcnktaGlnaC1wZXJmb3JtYW5jZSBqb2JzLlxuICAgICAgICBkcmF3aW5nTW9kZTogZHJhd2luZ01vZGVcbiAgICB9O1xuXG4gICAgcmV0dXJuIGJ1ZmZlck9iamVjdDtcbn07XG5cblxuZXhwb3J0IGNvbnN0IGRyYXdBcnJheSA9IChnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBibzogQnVmZmVyT2JqZWN0KTogdm9pZCA9PiB7XG4gICAgZ2wuZHJhd0FycmF5cyhiby5kcmF3aW5nTW9kZSwgYm8ub2Zmc2V0LCBiby52ZWN0b3JDb3VudCk7XG59O1xuXG5cblxuZXhwb3J0IGNvbnN0IHVwZGF0ZUJ1ZmZlckRhdGEgPSAoZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgYm86IEJ1ZmZlck9iamVjdCwgbmV3RGF0YTogbnVtYmVyW11bXSk6IEJ1ZmZlck9iamVjdCA9PiB7XG5cbiAgICBjb25zdCBkYXRhRmxhdHRlbmVkID0gbmV3IEZsb2F0MzJBcnJheShmbGF0dGVuUmVjdXJzaXZlKG5ld0RhdGEpKTtcblxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBiby5idWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBkYXRhRmxhdHRlbmVkLCBnbC5TVEFUSUNfRFJBVyk7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIG51bGwpOyAgLy8gdW5iaW5kaW5nXG5cbiAgICBjb25zdCBuZXdCdWZmZXJPYmplY3Q6IEJ1ZmZlck9iamVjdCA9IHtcbiAgICAgICAgYnVmZmVyOiBiby5idWZmZXIsXG4gICAgICAgIHZlY3RvclNpemU6IG5ld0RhdGFbMF0ubGVuZ3RoLFxuICAgICAgICB2ZWN0b3JDb3VudDogbmV3RGF0YS5sZW5ndGgsXG4gICAgICAgIHR5cGU6IGdsLkZMT0FULCAgIC8vIHRoZSBkYXRhIGlzIDMyYml0IGZsb2F0c1xuICAgICAgICBub3JtYWxpemU6IGZhbHNlLCAvLyBkb24ndCBub3JtYWxpemUgdGhlIGRhdGFcbiAgICAgICAgc3RyaWRlOiAwLCAgICAgICAgLy8gMCA9IG1vdmUgZm9yd2FyZCBzaXplICogc2l6ZW9mKHR5cGUpIGVhY2ggaXRlcmF0aW9uIHRvIGdldCB0aGUgbmV4dCBwb3NpdGlvbi4gT25seSBjaGFuZ2UgdGhpcyBpbiB2ZXJ5LWhpZ2gtcGVyZm9ybWFuY2Ugam9icy5cbiAgICAgICAgb2Zmc2V0OiAwLCAgICAgICAgLy8gc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYnVmZmVyLiBPbmx5IGNoYW5nZSB0aGlzIGluIHZlcnktaGlnaC1wZXJmb3JtYW5jZSBqb2JzLlxuICAgICAgICBkcmF3aW5nTW9kZTogYm8uZHJhd2luZ01vZGUsXG4gICAgfTtcblxuICAgIHJldHVybiBuZXdCdWZmZXJPYmplY3Q7XG59O1xuXG5cblxuXG4vKipcbiAqIEZldGNoIGF0dHJpYnV0ZSdzIGxvY2F0aW9uIChhdHRyaWJ1dGUgZGVjbGFyZWQgaW4gc29tZSBzaGFkZXIpLiBTbG93ISBEbyAqYmVmb3JlKiByZW5kZXIgbG9vcC5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldEF0dHJpYnV0ZUxvY2F0aW9uID0gKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIHByb2dyYW06IFdlYkdMUHJvZ3JhbSwgYXR0cmlidXRlTmFtZTogc3RyaW5nKTogbnVtYmVyID0+IHtcbiAgICBjb25zdCBsb2MgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICBpZiAobG9jID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkbid0IGZpbmQgYXR0cmlidXRlICR7YXR0cmlidXRlTmFtZX0gaW4gcHJvZ3JhbS5gKTtcbiAgICB9XG4gICAgcmV0dXJuIGxvYztcbn07XG5cblxuXG4vKipcbiAqIEF0dHJpYnV0ZXMgdmFyeSBmcm9tIHZlcnRleCB0byB2ZXJ0ZXggLSB0aGF0IG1lYW5zIHRoYXQgdGhlcmUgYXJlICptYW55KiBvZiB0aGVtLlxuICogU28gaXQgbWFrZXMgc2Vuc2UgZm9yIFdlYkdsIHRvIHN0b3JlIGF0dHJpYnV0ZSB2YWx1ZXMgaW4gYSBkZWRpY2F0ZWQgZGF0YSBzdHJ1Y3R1cmUgLSB0aGUgYnVmZmVyLlxuICovXG5leHBvcnQgY29uc3QgYmluZEJ1ZmZlclRvQXR0cmlidXRlID0gKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIGF0dHJpYnV0ZUxvY2F0aW9uOiBudW1iZXIsIGJ1ZmZlck9iamVjdDogQnVmZmVyT2JqZWN0KTogdm9pZCA9PiB7XG4gICAgLy8gQmluZCBidWZmZXIgdG8gZ2xvYmFsLXN0YXRlIEFSUkFZX0JVRkZFUlxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJPYmplY3QuYnVmZmVyKTtcbiAgICAvLyBFbmFibGUgZWRpdGluZyBvZiB2ZXJ0ZXgtYXJyYXktbG9jYXRpb25cbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhdHRyaWJ1dGVMb2NhdGlvbik7XG4gICAgLy8gQmluZCB0aGUgYnVmZmVyIGN1cnJlbnRseSBhdCBnbG9iYWwtc3RhdGUgQVJSQVlfQlVGRkVSIHRvIGEgdmVydGV4LWFycmF5LWxvY2F0aW9uLlxuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoXG4gICAgICAgIGF0dHJpYnV0ZUxvY2F0aW9uLFxuICAgICAgICBidWZmZXJPYmplY3QudmVjdG9yU2l6ZSwgYnVmZmVyT2JqZWN0LnR5cGUsIGJ1ZmZlck9iamVjdC5ub3JtYWxpemUsIGJ1ZmZlck9iamVjdC5zdHJpZGUsIGJ1ZmZlck9iamVjdC5vZmZzZXQpO1xuICAgIC8vIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShhdHRyaWJ1dGVMb2NhdGlvbik7IDwtLSBtdXN0IG5vdCBkbyB0aGlzIVxufTtcblxuXG5leHBvcnQgaW50ZXJmYWNlIEluZGV4QnVmZmVyT2JqZWN0IHtcbiAgICBidWZmZXI6IFdlYkdMQnVmZmVyO1xuICAgIGNvdW50OiBudW1iZXI7XG4gICAgdHlwZTogbnVtYmVyOyAvLyBtdXN0IGJlIGdsLlVOU0lHTkVEX1NIT1JUXG4gICAgb2Zmc2V0OiBudW1iZXI7XG4gICAgZHJhd2luZ01vZGU6IG51bWJlcjsgLy8gZ2wuVFJJQU5HTEVTLCBnbC5QT0lOVFMsIG9yIGdsLkxJTkVTXG59XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVJbmRleEJ1ZmZlciA9IChnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBpbmRpY2VzOiBudW1iZXJbXVtdLCBkcmF3aW5nTW9kZTogbnVtYmVyID0gZ2wuVFJJQU5HTEVTKTogSW5kZXhCdWZmZXJPYmplY3QgPT4ge1xuXG4gICAgY29uc3QgaW5kaWNlc0ZsYXR0ZW5lZCA9IG5ldyBVaW50MTZBcnJheShmbGF0dGVuUmVjdXJzaXZlKGluZGljZXMpKTtcblxuICAgIGNvbnN0IGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGlmICghYnVmZmVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYnVmZmVyIHdhcyBjcmVhdGVkJyk7XG4gICAgfVxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgaW5kaWNlc0ZsYXR0ZW5lZCwgZ2wuU1RBVElDX0RSQVcpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIG51bGwpO1xuXG4gICAgY29uc3QgYnVmZmVyT2JqZWN0OiBJbmRleEJ1ZmZlck9iamVjdCA9IHtcbiAgICAgICAgYnVmZmVyOiBidWZmZXIsXG4gICAgICAgIGNvdW50OiBpbmRpY2VzRmxhdHRlbmVkLmxlbmd0aCxcbiAgICAgICAgdHlwZTogZ2wuVU5TSUdORURfU0hPUlQsXG4gICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgZHJhd2luZ01vZGU6IGRyYXdpbmdNb2RlXG4gICAgfTtcblxuICAgIHJldHVybiBidWZmZXJPYmplY3Q7XG59O1xuXG5leHBvcnQgY29uc3QgYmluZEluZGV4QnVmZmVyID0gKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIGlibzogSW5kZXhCdWZmZXJPYmplY3QpID0+IHtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBpYm8uYnVmZmVyKTtcbn07XG5cbmV4cG9ydCBjb25zdCBkcmF3RWxlbWVudHMgPSAoZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgaWJvOiBJbmRleEJ1ZmZlck9iamVjdCk6IHZvaWQgPT4ge1xuICAgIGdsLmRyYXdFbGVtZW50cyhpYm8uZHJhd2luZ01vZGUsIGliby5jb3VudCwgaWJvLnR5cGUsIGliby5vZmZzZXQpO1xufTtcblxuXG5cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVGV4dHVyZU9iamVjdCB7XG4gICAgdGV4dHVyZTogV2ViR0xUZXh0dXJlO1xuICAgIHdpZHRoOiBudW1iZXI7XG4gICAgaGVpZ2h0OiBudW1iZXI7XG4gICAgbGV2ZWw6IG51bWJlcjtcbiAgICBpbnRlcm5hbGZvcm1hdDogbnVtYmVyO1xuICAgIGZvcm1hdDogbnVtYmVyO1xuICAgIHR5cGU6IG51bWJlcjtcbiAgICBib3JkZXI6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBBIHNoYWRlcidzIGF0dHJpYnV0ZXMgZ2V0IHRoZWlyIGJ1ZmZlci12YWx1ZXMgZnJvbSB0aGUgVkVSVEVYX0FSUkFZLCBidXQgdGhleSBhcmUgY29uc3RydWN0ZWQgaW4gdGhlIEFSUkFZX0JVRkZFUi5cbiAqIFRleHR1cmVzIGFuYWxvZ291c2x5IGFyZSBzZXJ2ZWQgZnJvbSB0aGUgVEVYVFVSRV9VTklUUywgd2hpbGUgZm9yIGNvbnN0cnVjdGlvbiB0aGV5IGFyZSBib3VuZCB0byBBQ1RJVkVfVEVYVFVSRS5cbiAqXG4gKiBUaGVyZSBpcyBhIGJpZyBkaWZmZXJlbmNlLCBob3dldmVyLiBDb250cmFyeSB0byBidWZmZXJzIHdoaWNoIHJlY2VpdmUgdGhlaXIgaW5pdGlhbCB2YWx1ZSB3aGlsZSBzdGlsbCBvdXRzaWRlIHRoZSBBUlJBWV9CVUZGRVIsXG4gKiBhIHRleHR1cmUgZG9lcyBhbHJlYWR5IGhhdmUgdG8gYmUgYm91bmQgaW50byB0aGUgVEVYVFVSRV9VTklUUyB3aGVuIGl0J3MgYmVpbmcgY3JlYXRlZC5cbiAqIFNpbmNlIGl0J2xsIGFsd2F5cyBiZSBib3VuZCBpbnRvIHRoZSBzbG90IHRoYXQgQUNUSVZFX1RFWFRVUkUgcG9pbnRzIHRvLCB5b3UgY2FuIGluYWR2ZXJ0ZW50bHkgb3ZlcndyaXRlIGFub3RoZXIgdGV4dHVyZSB0aGF0IGlzXG4gKiBjdXJyZW50bHkgaW4gdGhpcyBwbGFjZS4gVG8gYXZvaWQgdGhpcywgd2UgcHJvdmlkZSBhIGRlZGljYXRlZCBgdGV4dHVyZUNvbnN0cnVjdGlvbkJpbmRQb2ludGAuXG4gKlxuICogQnVmZmVycyBhcmUgZWFzaWVyIGluIHRoaXMsIHNpbmNlIHdpdGggdmVydGV4QXR0cmliUG9pbnRlciB3ZSBhcmUgZ3VhcmFudGVlZCB0byBnZXQgYSBzbG90IGluIHRoZSBWRVJURVhfQVJSQVkgdGhhdCBpcyBub3RcbiAqIGFscmVhZHkgb2NjdXBpZWQgYnkgYW5vdGhlciBidWZmZXIuXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVUZXh0dXJlID0gKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIGltYWdlOiBIVE1MSW1hZ2VFbGVtZW50IHwgSFRNTENhbnZhc0VsZW1lbnQpOiBUZXh0dXJlT2JqZWN0ID0+IHtcblxuICAgIGNvbnN0IHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7ICAvLyBhbmFsb2cgdG8gY3JlYXRlQnVmZmVyXG4gICAgaWYgKCF0ZXh0dXJlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdGV4dHVyZSB3YXMgY3JlYXRlZCcpO1xuICAgIH1cbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGV4dHVyZUNvbnN0cnVjdGlvbkJpbmRQb2ludCk7IC8vIHNvIHRoYXQgd2UgZG9uJ3Qgb3ZlcndyaXRlIGFub3RoZXIgdGV4dHVyZSBpbiB0aGUgbmV4dCBsaW5lLlxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpOyAgLy8gYW5hbG9nIHRvIGJpbmRCdWZmZXIuIEJpbmRzIHRleHR1cmUgdG8gY3VycmVudGx5IGFjdGl2ZSB0ZXh0dXJlLWJpbmRwb2ludCAoYWthLiB0ZXh0dXJlIHVuaXQpLlxuXG4gICAgY29uc3QgbGV2ZWwgPSAwO1xuICAgIGNvbnN0IGludGVybmFsRm9ybWF0ID0gZ2wuUkdCQTtcbiAgICBjb25zdCBmb3JtYXQgPSBnbC5SR0JBO1xuICAgIGNvbnN0IHR5cGUgPSBnbC5VTlNJR05FRF9CWVRFO1xuXG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCBsZXZlbCwgaW50ZXJuYWxGb3JtYXQsIGZvcm1hdCwgdHlwZSwgaW1hZ2UpOyAgLy8gYW5hbG9nIHRvIGJ1ZmZlckRhdGFcbiAgICBnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKTsgLy8gbWlwbWFwcyBhcmUgbWluaS12ZXJzaW9ucyBvZiB0aGUgdGV4dHVyZS5cbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTsgIC8vIHVuYmluZGluZ1xuXG4gICAgbGV0IHcsIGg6IG51bWJlcjtcbiAgICBpZiAoaW1hZ2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB7XG4gICAgICAgIHcgPSBpbWFnZS5uYXR1cmFsV2lkdGg7XG4gICAgICAgIGggPSBpbWFnZS5uYXR1cmFsSGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHcgPSBpbWFnZS53aWR0aDtcbiAgICAgICAgaCA9IGltYWdlLmhlaWdodDtcbiAgICB9XG5cbiAgICBjb25zdCB0ZXh0dXJlT2JqOiBUZXh0dXJlT2JqZWN0ID0ge1xuICAgICAgICB0ZXh0dXJlOiB0ZXh0dXJlLFxuICAgICAgICBsZXZlbDogbGV2ZWwsXG4gICAgICAgIGludGVybmFsZm9ybWF0OiBpbnRlcm5hbEZvcm1hdCxcbiAgICAgICAgZm9ybWF0OiBmb3JtYXQsXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIHdpZHRoOiB3LFxuICAgICAgICBoZWlnaHQ6IGgsXG4gICAgICAgIGJvcmRlcjogMFxuICAgIH07XG5cbiAgICByZXR1cm4gdGV4dHVyZU9iajtcbn07XG5cblxuZXhwb3J0IHR5cGUgdGV4dHVyZURhdGFUeXBlID0gJyc7XG5cbi8qKlxuICogVGhpcyBpcyBqdXN0IGFub3RoZXIgdGV4dHVyZSwgYnV0IG9wdGltaXplZCBmb3IgY2FycnlpbmcgZGF0YSwgbm90IGZvciBkaXNwbGF5LlxuICpcbiAqIFZhbGlkIGNvbWJpbmF0aW9ucyBvZiB0ZXh0dXJlLWRhdGEgcGFyYW1ldGVyczpcbiAqXG4gKiB8IEludGVybmFsIEZvcm1hdCB8IEZvcm1hdCAgICAgICAgICB8IFR5cGUgICAgICAgICAgICAgICAgICAgICAgfCBTb3VyY2UgQnl0ZXMgUGVyIFBpeGVsIHxcbiAqIHwtLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICogfCBSR0JBICAgICAgICAgICAgfCBSR0JBICAgICAgICAgICAgfCBVTlNJR05FRF9CWVRFICAgICAgICAgICAgIHwgNCAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IFJHQlx0ICAgICAgICAgfCBSR0IgICAgICAgICAgICAgfCBVTlNJR05FRF9CWVRFICAgICAgICAgICAgIHwgMyAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IFJHQkEgICAgICAgICAgICB8IFJHQkEgICAgICAgICAgICB8IFVOU0lHTkVEX1NIT1JUXzRfNF80XzQgICAgfCAyICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgUkdCQSAgICAgICAgICAgIHwgUkdCQSAgICAgICAgICAgIHwgVU5TSUdORURfU0hPUlRfNV81XzVfMVx0ICAgfCAyICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgUkdCICAgICAgICAgICAgIHwgUkdCICAgICAgICAgICAgIHwgVU5TSUdORURfU0hPUlRfNV82XzUgICAgICB8IDIgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCBMVU1JTkFOQ0VfQUxQSEEgfCBMVU1JTkFOQ0VfQUxQSEEgfCBVTlNJR05FRF9CWVRFXHQgICAgICAgICAgIHwgMiAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IExVTUlOQU5DRSAgICAgICB8IExVTUlOQU5DRSAgICAgICB8IFVOU0lHTkVEX0JZVEUgICAgICAgICAgICAgfCAxICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgQUxQSEEgICAgICAgICAgIHwgQUxQSEEgICAgICAgICAgIHwgVU5TSUdORURfQllURSAgICAgICAgICAgICB8IDEgICAgICAgICAgICAgICAgICAgICAgfFxuICogUGx1cyBtYW55IG1vcmUgaW4gV2ViR0wyLlxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZURhdGFUZXh0dXJlID0gKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIGRhdGE6IG51bWJlcltdW11bXSk6IFRleHR1cmVPYmplY3QgPT4ge1xuICAgIGNvbnN0IGhlaWdodCA9IGRhdGEubGVuZ3RoO1xuICAgIGNvbnN0IHdpZHRoID0gZGF0YVswXS5sZW5ndGg7XG4gICAgY29uc3QgY2hhbm5lbHMgPSBkYXRhWzBdWzBdLmxlbmd0aDtcbiAgICBpZiAoICFpc1Bvd2VyT2Yod2lkdGgsIDIpIHx8ICFpc1Bvd2VyT2YoaGVpZ2h0LCAyKSApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUZXh0dXJlLWRhdGEtZGltZW5zaW9ucyBtdXN0IGJlIGEgcG93ZXIgb2YgdHdvLCBidXQgYXJlICR7d2lkdGh9IHggJHtoZWlnaHR9YCk7XG4gICAgfVxuICAgIGlmICggY2hhbm5lbHMgIT09IDQpIHtcbiAgICAgICAgLy8gQHRvZG86IHJlbW92ZSB0aGlzIHdoZW4gd2UgaW1wbGVtZW50IG5vbi1yZ2JhIGRhdGEtdGV4dHVyZXMuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0aW5nIDQgY2hhbm5lbHMsIGJ1dCAke2NoYW5uZWxzfSBwcm92aWRlZGApO1xuICAgIH1cblxuICAgIGNvbnN0IHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7ICAvLyBhbmFsb2cgdG8gY3JlYXRlQnVmZmVyXG4gICAgaWYgKCF0ZXh0dXJlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdGV4dHVyZSB3YXMgY3JlYXRlZCcpO1xuICAgIH1cbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGV4dHVyZUNvbnN0cnVjdGlvbkJpbmRQb2ludCk7IC8vIHNvIHRoYXQgd2UgZG9uJ3Qgb3ZlcndyaXRlIGFub3RoZXIgdGV4dHVyZSBpbiB0aGUgbmV4dCBsaW5lLlxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpOyAgLy8gYW5hbG9nIHRvIGJpbmRCdWZmZXIuIEJpbmRzIHRleHR1cmUgdG8gY3VycmVudGx5IGFjdGl2ZSB0ZXh0dXJlLWJpbmRwb2ludCAoYWthLiB0ZXh0dXJlIHVuaXQpLlxuXG4gICAgLy8gdG8gYmUgdXNlZCBmb3IgZGF0YS4gd2Ugd2FudCBubyBpbnRlcnBvbGF0aW9uIG9mIGRhdGEsIHNvIGRpc2FsbG93IG1pcG1hcCBhbmQgaW50ZXJwb2xhdGlvbi5cbiAgICBjb25zdCBsZXZlbCA9IDA7XG4gICAgY29uc3QgYm9yZGVyID0gMDtcbiAgICBjb25zdCBpbnRlcm5hbEZvcm1hdCA9IGdsLlJHQkE7XG4gICAgY29uc3QgZm9ybWF0ID0gZ2wuUkdCQTtcbiAgICBjb25zdCB0eXBlID0gZ2wuVU5TSUdORURfQllURTtcblxuICAgIGNvbnN0IGJpbkRhdGEgPSBuZXcgVWludDhBcnJheShmbGF0dGVuUmVjdXJzaXZlKGRhdGEpKTtcblxuICAgIGlmIChjaGFubmVscyAhPT0gNCkge1xuICAgICAgICAvLyBoYXZlIFdlYkdMIGRpZ2VzdCBkYXRhIG9uZSBieXRlIGF0IGEgdGltZS5cbiAgICAgICAgLy8gKFBlciBkZWZhdWx0IHRyaWVzIDQgYnl0ZXMgYXQgYSB0aW1lLCB3aGljaCBjYXVzZXMgZXJyb3JzIHdoZW4gb3VyIGRhdGEgaXMgbm90IGEgbXVsaXRwbGUgb2YgNCkuXG4gICAgICAgIGNvbnN0IGFsaWdubWVudCA9IDE7IC8vIHZhbGlkIHZhbHVlcyBhcmUgMSwgMiwgNCwgYW5kIDguXG4gICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19BTElHTk1FTlQsIGFsaWdubWVudCk7XG4gICAgfVxuXG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCBsZXZlbCwgaW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQsIGJvcmRlciwgZm9ybWF0LCB0eXBlLCBiaW5EYXRhKTsgLy8gYW5hbG9nIHRvIGJ1ZmZlckRhdGFcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpOyAgLy8gdW5iaW5kaW5nXG5cblxuICAgIGNvbnN0IHRleHR1cmVPYmo6IFRleHR1cmVPYmplY3QgPSB7XG4gICAgICAgIHRleHR1cmU6IHRleHR1cmUsXG4gICAgICAgIGxldmVsOiBsZXZlbCxcbiAgICAgICAgaW50ZXJuYWxmb3JtYXQ6IGludGVybmFsRm9ybWF0LFxuICAgICAgICBmb3JtYXQ6IGZvcm1hdCxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgYm9yZGVyOiBib3JkZXJcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRleHR1cmVPYmo7XG59O1xuXG5cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUVtcHR5VGV4dHVyZSA9IChnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IFRleHR1cmVPYmplY3QgPT4ge1xuICAgIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV2lkdGggYW5kIGhlaWdodCBtdXN0IGJlIHBvc2l0aXZlLicpO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgIGlmICghdGV4dHVyZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHRleHR1cmUgd2FzIGNyZWF0ZWQnKTtcbiAgICB9XG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRleHR1cmVDb25zdHJ1Y3Rpb25CaW5kUG9pbnQpOyAvLyBzbyB0aGF0IHdlIGRvbid0IG92ZXJ3cml0ZSBhbm90aGVyIHRleHR1cmUgaW4gdGhlIG5leHQgbGluZS5cbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHdpZHRoLCBoZWlnaHQsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG5cbiAgICBjb25zdCB0ZXh0dXJlT2JqOiBUZXh0dXJlT2JqZWN0ID0ge1xuICAgICAgICB0ZXh0dXJlOiB0ZXh0dXJlLFxuICAgICAgICBsZXZlbDogMCxcbiAgICAgICAgaW50ZXJuYWxmb3JtYXQ6IGdsLlJHQkEsXG4gICAgICAgIGZvcm1hdDogZ2wuUkdCQSxcbiAgICAgICAgdHlwZTogZ2wuVU5TSUdORURfQllURSxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgYm9yZGVyOiAwXG4gICAgfTtcblxuICAgIHJldHVybiB0ZXh0dXJlT2JqO1xufTtcblxuXG4vKipcbiAqIEV2ZW4gdGhvdWdoIHdlIHJlZmVyZW5jZSB0ZXh0dXJlcyBhcyB1bmlmb3JtcyBpbiBhIGZyYWdtZW50IHNoYWRlciwgYXNzaWduaW5nIGFuIGFjdHVhbCB0ZXh0dXJlLXZhbHVlIHRvIHRoYXQgdW5pZm9ybSB3b3JrcyBkaWZmZXJlbnRseSBmcm9tIG5vcm1hbCB1bmlmb3Jtcy5cbiAqIE5vcm1hbCB1bmlmb3JtcyBoYXZlIGEgY29uY3JldGUgdmFsdWUuXG4gKiBUZXh0dXJlIHVuaWZvcm1zLCBvbiB0aGUgb3RoZXIgaGFuZCwgYXJlIGp1c3QgYW4gaW50ZWdlci1pbmRleCB0aGF0IHBvaW50cyB0byBhIHNwZWNpYWwgc2xvdCBpbiB0aGUgR1BVIG1lbW9yeSAodGhlIGJpbmRQb2ludCkgd2hlcmUgdGhlIGFjdHVhbCB0ZXh0dXJlIHZhbHVlIGxpZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBiaW5kVGV4dHVyZVRvVW5pZm9ybSA9IChnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCB0ZXh0dXJlOiBXZWJHTFRleHR1cmUsIGJpbmRQb2ludDogbnVtYmVyLCB1bmlmb3JtTG9jYXRpb246IFdlYkdMVW5pZm9ybUxvY2F0aW9uKTogdm9pZCA9PiAge1xuICAgIGlmIChiaW5kUG9pbnQgPiBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlcmUgYXJlIG9ubHkgJHtnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMpfSB0ZXh0dXJlIGJpbmQgcG9pbnRzLCBidXQgeW91IHRyaWVkIHRvIGJpbmQgdG8gcG9pbnQgbnIuICR7YmluZFBvaW50fS5gKTtcbiAgICB9XG4gICAgaWYgKGJpbmRQb2ludCA9PT0gdGV4dHVyZUNvbnN0cnVjdGlvbkJpbmRQb2ludCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBZb3UgYXJlIGFib3V0IHRvIGJpbmQgdG8gdGhlIGRlZGljYXRlZCB0ZXh0dXJlLWNvbnN0cnVjdGlvbiBiaW5kIHBvaW50IChuci4gJHtiaW5kUG9pbnR9KS5cbiAgICAgICAgSWYgYWZ0ZXIgdGhpcyBjYWxsIGFub3RoZXIgdGV4dHVyZSBpcyBidWlsdCwgeW91ciBzaGFkZXIgd2lsbCBub3cgdXNlIHRoYXQgbmV3IHRleHR1cmUgaW5zdGVhZCBvZiB0aGlzIG9uZSFcbiAgICAgICAgQ29uc2lkZXIgdXNpbmcgYW5vdGhlciBiaW5kIHBvaW50LmApO1xuICAgIH1cbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgYmluZFBvaW50KTsgIC8vIGFuYWxvZyB0byBlbmFibGVWZXJ0ZXhBdHRyaWJBcnJheVxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpOyAgLy8gYW5hbG9nIHRvIGJpbmRCdWZmZXIuIEJpbmRzIHRleHR1cmUgdG8gY3VycmVudGx5IGFjdGl2ZSB0ZXh0dXJlLWJpbmRwb2ludCAoYWthLiB0ZXh0dXJlIHVuaXQpLlxuICAgIGdsLnVuaWZvcm0xaSh1bmlmb3JtTG9jYXRpb24sIGJpbmRQb2ludCk7IC8vIGFuYWxvZyB0byB2ZXJ0ZXhBdHRyaWJQb2ludGVyXG59O1xuXG5cblxuZXhwb3J0IGNvbnN0IHVwZGF0ZVRleHR1cmUgPSAoZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgdG86IFRleHR1cmVPYmplY3QsIG5ld0RhdGE6IEhUTUxJbWFnZUVsZW1lbnQgfCBIVE1MQ2FudmFzRWxlbWVudCB8IG51bWJlcltdW11bXSk6IFRleHR1cmVPYmplY3QgPT4ge1xuXG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRleHR1cmVDb25zdHJ1Y3Rpb25CaW5kUG9pbnQpOyAvLyBzbyB0aGF0IHdlIGRvbid0IG92ZXJ3cml0ZSBhbm90aGVyIHRleHR1cmUgaW4gdGhlIG5leHQgbGluZS5cbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0by50ZXh0dXJlKTsgIC8vIGFuYWxvZyB0byBiaW5kQnVmZmVyLiBCaW5kcyB0ZXh0dXJlIHRvIGN1cnJlbnRseSBhY3RpdmUgdGV4dHVyZS1iaW5kcG9pbnQgKGFrYS4gdGV4dHVyZSB1bml0KS5cbiAgICBpZiAobmV3RGF0YSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgfHwgbmV3RGF0YSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KSB7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbmV3RGF0YSk7ICAvLyBhbmFsb2cgdG8gYnVmZmVyRGF0YVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gbmV3RGF0YVswXS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IG5ld0RhdGEubGVuZ3RoO1xuICAgICAgICBpZiAoICFpc1Bvd2VyT2Yod2lkdGgsIDIpIHx8ICFpc1Bvd2VyT2YoaGVpZ2h0LCAyKSApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGV4dHVyZS1kYXRhLWRpbWVuc2lvbnMgbXVzdCBiZSBhIHBvd2VyIG9mIHR3bywgYnV0IGFyZSAke2hlaWdodH0geCAke3dpZHRofWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJpbkRhdGEgPSBuZXcgVWludDhBcnJheShmbGF0dGVuUmVjdXJzaXZlKG5ld0RhdGEpKTsgIC8vIEB0b2RvOiB1c2UgYW5vdGhlciBBcnJheUJ1ZmZlclZpZXcgZGVwZW5kaW5nIG9uIHRvLmZvcm1hdD9cbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCB0by5sZXZlbCwgdG8uaW50ZXJuYWxmb3JtYXQsIHRvLndpZHRoLCB0by5oZWlnaHQsIHRvLmJvcmRlciwgdG8uZm9ybWF0LCB0by50eXBlLCBiaW5EYXRhKTtcbiAgICB9XG4gICAgZ2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRCk7IC8vIG1pcG1hcHMgYXJlIG1pbmktdmVyc2lvbnMgb2YgdGhlIHRleHR1cmUuXG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7ICAvLyB1bmJpbmRpbmdcblxuICAgIGlmIChuZXdEYXRhIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkge1xuICAgICAgICB0by53aWR0aCA9IG5ld0RhdGEubmF0dXJhbFdpZHRoO1xuICAgICAgICB0by5oZWlnaHQgPSBuZXdEYXRhLm5hdHVyYWxIZWlnaHQ7XG4gICAgfSBlbHNlIGlmIChuZXdEYXRhIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpIHtcbiAgICAgICAgdG8ud2lkdGggPSBuZXdEYXRhLndpZHRoO1xuICAgICAgICB0by5oZWlnaHQgPSBuZXdEYXRhLmhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0by53aWR0aCA9IG5ld0RhdGFbMF0ubGVuZ3RoO1xuICAgICAgICB0by5oZWlnaHQgPSBuZXdEYXRhLmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gdG87XG59O1xuXG5cbmV4cG9ydCBpbnRlcmZhY2UgRnJhbWVidWZmZXJPYmplY3Qge1xuICAgIGZyYW1lYnVmZmVyOiBXZWJHTEZyYW1lYnVmZmVyO1xuICAgIHRleHR1cmU6IFRleHR1cmVPYmplY3Q7XG4gICAgd2lkdGg6IG51bWJlcjtcbiAgICBoZWlnaHQ6IG51bWJlcjtcbn1cblxuXG5leHBvcnQgY29uc3QgY3JlYXRlRnJhbWVidWZmZXIgPSAoZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCk6IFdlYkdMRnJhbWVidWZmZXIgPT4ge1xuICAgIGNvbnN0IGZiID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTsgIC8vIGFuYWxvZyB0byBjcmVhdGVCdWZmZXJcbiAgICBpZiAoIWZiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgY3JlYXRpbmcgZnJhbWVidWZmZXJgKTtcbiAgICB9XG4gICAgcmV0dXJuIGZiO1xufTtcblxuXG4vKipcbiAqIFRoZSBvcGVyYXRpb25zIGBjbGVhcmAsIGBkcmF3QXJyYXlzYCBhbmQgYGRyYXdFbGVtZW50c2Agb25seSBhZmZlY3QgdGhlIGN1cnJlbnRseSBib3VuZCBmcmFtZWJ1ZmZlci5cbiAqXG4gKiBOb3RlIHRoYXQgYmluZGluZyB0aGUgZnJhbWVidWZmZXIgZG9lcyAqbm90KiBtZWFuIGJpbmRpbmcgaXRzIHRleHR1cmUuXG4gKiBJbiBmYWN0LCBpZiB0aGVyZSBpcyBhIGJvdW5kIHRleHR1cmUsIGl0IG11c3QgYmUgdGhlICppbnB1dCogdG8gYSBzaGFkZXIsIG5vdCB0aGUgb3V0cHV0LlxuICogVGhlcmVmb3JlLCBhIGZyYW1lYnVmZmVyJ3MgdGV4dHVyZSBtdXN0IG5vdCBiZSBib3VuZCB3aGVuIHRoZSBmcmFtZWJ1ZmZlciBpcy5cbiAqL1xuZXhwb3J0IGNvbnN0IGJpbmRGcmFtZWJ1ZmZlciA9IChnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBmYm86IEZyYW1lYnVmZmVyT2JqZWN0LCBtYW51YWxWaWV3cG9ydD86IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdKSA9PiB7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmYm8uZnJhbWVidWZmZXIpO1xuICAgIC8vIEl0J3MgRVhUUkVNRUxZIElNUE9SVEFOVCB0byByZW1lbWJlciB0byBjYWxsIGdsLnZpZXdwb3J0IGFuZCBzZXQgaXQgdG8gdGhlIHNpemUgb2YgdGhlIHRoaW5nIHlvdXIgcmVuZGVyaW5nIHRvLlxuICAgIC8vIGh0dHBzOi8vd2ViZ2xmdW5kYW1lbnRhbHMub3JnL3dlYmdsL2xlc3NvbnMvd2ViZ2wtcmVuZGVyLXRvLXRleHR1cmUuaHRtbFxuICAgIGlmIChtYW51YWxWaWV3cG9ydCkge1xuICAgICAgICBpZiAoKGZiby53aWR0aCAvIGZiby5oZWlnaHQpICE9PSAobWFudWFsVmlld3BvcnRbMl0gLyBtYW51YWxWaWV3cG9ydFszXSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgWW91ciB2aWV3cG9ydC1hc3BlY3QgaXMgZGlmZmVyZW50IGZyb20gdGhlIGZyYW1lYnVmZmVyLWFzcGVjdC5gKTtcbiAgICAgICAgfVxuICAgICAgICBnbC52aWV3cG9ydCguLi5tYW51YWxWaWV3cG9ydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2wudmlld3BvcnQoMCwgMCwgZmJvLndpZHRoLCBmYm8uaGVpZ2h0KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFdlYmdsIHJlbmRlcnMgdG8gdGhlIHZpZXdwb3J0LCB3aGljaCBpcyByZWxhdGl2ZSB0byBjYW52YXMud2lkdGggKiBjYW52YXMuaGVpZ2h0LlxuICogKFRvIGJlIG1vcmUgcHJlY2lzZSwgb25seSAqcG9seWdvbnMqIGFyZSBjbGlwcGVkIHRvIHRoZSB2aWV3cG9ydC5cbiAqIE9wZXJhdGlvbnMgbGlrZSBgY2xlYXJDb2xvcigpYCBldC5hbC4sIHdpbGwgc3RpbGwgZHJhdyB0byB0aGUgKmZ1bGwqIGNhbnZhcy53aWR0aCAqIGhlaWdodCFcbiAqIElmIHlvdSB3YW50IHRvIGFsc28gY29uc3RyYWluIGNsZWFyQ29sb3IsIHVzZSBgc2Npc3NvcmAgaW5zdGVhZCBvZiB2aWV3cG9ydC4pXG4gKiBUaGF0IGNhbnZhcy53aWR0aCAqIGNhbnZhcy5oZWlnaHQgdGhlbiBnZXRzIHN0cmV0Y2hlZCB0byBjYW52YXMuY2xpZW50V2lkdGggKiBjYW52YXMuY2xpZW50SGVpZ2h0LlxuICogKE5vdGU6IHRoZSBmdWxsIGNhbnZhcy53aWR0aCBnZXRzIHN0cmV0Y2hlZCB0byBjbGllbnRXaWR0aCwgbm90IGp1c3QgdGhlIHZpZXdwb3J0ISlcbiAqL1xuZXhwb3J0IGNvbnN0IGJpbmRPdXRwdXRDYW52YXNUb0ZyYW1lYnVmZmVyID0gKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIG1hbnVhbFZpZXdwb3J0PzogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0pID0+IHtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgIC8vIEl0J3MgRVhUUkVNRUxZIElNUE9SVEFOVCB0byByZW1lbWJlciB0byBjYWxsIGdsLnZpZXdwb3J0IGFuZCBzZXQgaXQgdG8gdGhlIHNpemUgb2YgdGhlIHRoaW5nIHlvdXIgcmVuZGVyaW5nIHRvLlxuICAgIC8vIGh0dHBzOi8vd2ViZ2xmdW5kYW1lbnRhbHMub3JnL3dlYmdsL2xlc3NvbnMvd2ViZ2wtcmVuZGVyLXRvLXRleHR1cmUuaHRtbFxuICAgIGlmIChtYW51YWxWaWV3cG9ydCkge1xuICAgICAgICBpZiAoKGdsLmNhbnZhcy53aWR0aCAvIGdsLmNhbnZhcy5oZWlnaHQpICE9PSAobWFudWFsVmlld3BvcnRbMl0gLyBtYW51YWxWaWV3cG9ydFszXSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgWW91ciB2aWV3cG9ydC1hc3BlY3QgaXMgZGlmZmVyZW50IGZyb20gdGhlIGNhbnZhcy1hc3BlY3QuYCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2wudmlld3BvcnQoLi4ubWFudWFsVmlld3BvcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vdGU6IGRvbid0IHVzZSBjbGllbnRXaWR0aCBoZXJlLlxuICAgICAgICBnbC52aWV3cG9ydCgwLCAwLCBnbC5jYW52YXMud2lkdGgsIGdsLmNhbnZhcy5oZWlnaHQpO1xuICAgIH1cbn07XG5cblxuLyoqXG4gKiBBIGZyYW1lYnVmZmVyIGNhbiBoYXZlIGEgdGV4dHVyZSAtIHRoYXQgaXMgdGhlIGJpdG1hcCB0aGF0IHRoZSBzaGFkZXItKm91dCpwdXQgaXMgZHJhd24gb24uXG4gKiBTaGFkZXJzIG1heSBhbHNvIGhhdmUgb25lIG9yIG1vcmUgKmluKnB1dCB0ZXh0dXJlKHMpLCB3aGljaCBtdXN0IGJlIHByb3ZpZGVkIHRvIHRoZSBzaGFkZXIgYXMgYSB1bmlmb3JtIHNhbXBsZXIyRC5cbiAqIE9ubHkgdGhlIHNoYWRlciBuZWVkcyB0byBrbm93IGFib3V0IGFueSBwb3RlbnRpYWwgaW5wdXQgdGV4dHVyZSwgdGhlIGZyYW1lYnVmZmVyIHdpbGwgYWx3YXlzIG9ubHkga25vdyBhYm91dCBpdCdzIG91dHB1dCB0ZXh0dXJlLlxuICovXG5leHBvcnQgY29uc3QgYmluZFRleHR1cmVUb0ZyYW1lYnVmZmVyID0gKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIHRleHR1cmU6IFRleHR1cmVPYmplY3QsIGZiOiBXZWJHTEZyYW1lYnVmZmVyKTogRnJhbWVidWZmZXJPYmplY3QgPT4ge1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZmIpO1xuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZS50ZXh0dXJlLCAwKTsgLy8gYW5hbG9nIHRvIGJ1ZmZlckRhdGFcblxuICAgIGlmIChnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKGdsLkZSQU1FQlVGRkVSKSAhPT0gZ2wuRlJBTUVCVUZGRVJfQ09NUExFVEUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBjcmVhdGluZyBmcmFtZWJ1ZmZlcjogZnJhbWVidWZmZXItc3RhdHVzOiAke2dsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoZ2wuRlJBTUVCVUZGRVIpfSA7IGVycm9yLWNvZGU6ICR7Z2wuZ2V0RXJyb3IoKX1gKTtcbiAgICB9XG5cbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuXG4gICAgY29uc3QgZmJvOiBGcmFtZWJ1ZmZlck9iamVjdCA9IHtcbiAgICAgICAgZnJhbWVidWZmZXI6IGZiLFxuICAgICAgICB0ZXh0dXJlOiB0ZXh0dXJlLFxuICAgICAgICB3aWR0aDogdGV4dHVyZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0ZXh0dXJlLmhlaWdodFxuICAgIH07XG5cbiAgICByZXR1cm4gZmJvO1xufTtcblxuXG5cblxuXG5cblxuXG5cblxuLyoqXG4gKiBGZXRjaCB1bmlmb3JtJ3MgbG9jYXRpb24gKHVuaWZvcm0gZGVjbGFyZWQgaW4gc29tZSBzaGFkZXIpLiBTbG93ISBEbyAqYmVmb3JlKiByZW5kZXIgbG9vcC5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldFVuaWZvcm1Mb2NhdGlvbiA9IChnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBwcm9ncmFtOiBXZWJHTFByb2dyYW0sIHVuaWZvcm1OYW1lOiBzdHJpbmcpOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiA9PiB7XG4gICAgY29uc3QgbG9jID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIHVuaWZvcm1OYW1lKTtcbiAgICBpZiAobG9jID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGRuJ3QgZmluZCB1bmlmb3JtICR7dW5pZm9ybU5hbWV9IGluIHByb2dyYW0uYCk7XG4gICAgfVxuICAgIHJldHVybiBsb2M7XG59O1xuXG5cblxuXG5leHBvcnQgdHlwZSBXZWJHTFZhcmlhYmxlVHlwZSA9ICdib29sJyAgfCAnYnZlYzInIHwgJ2J2ZWMzJyB8ICdidmVjNCd8ICdib29sW10nICB8ICdidmVjMltdJyB8ICdidmVjM1tdJyB8ICdidmVjNFtdJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAnaW50JyAgIHwgJ2l2ZWMyJyB8ICdpdmVjMycgfCAnaXZlYzQnfCAnaW50W10nICAgfCAnaXZlYzJbXScgfCAnaXZlYzNbXScgfCAnaXZlYzRbXSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgJ2Zsb2F0JyB8ICd2ZWMyJyAgfCAndmVjMycgIHwgJ3ZlYzQnIHwgJ2Zsb2F0W10nIHwgJ3ZlYzJbXScgIHwgJ3ZlYzNbXScgIHwgJ3ZlYzRbXSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICdtYXQyJyAgfCAnbWF0MycgIHwgJ21hdDQnO1xuXG5cbi8qKlxuICogQ29udHJhcnkgdG8gYXR0cmlidXRlcywgdW5pZm9ybXMgZG9uJ3QgbmVlZCB0byBiZSBzdG9yZWQgaW4gYSBidWZmZXIuIChOb3RlOiBpbiBXZWJHTCAyLjAsIGhvd2V2ZXIsIHRoZXJlICphcmUqIHVuaWZvcm0gYnVmZmVycyEpXG4gKlxuICogJ3YnIGlzIG5vdCBhYm91dCB0aGUgc2hhZGVyLCBidXQgaG93IHlvdSBwcm92aWRlIGRhdGEgZnJvbSB0aGUganMtc2lkZS5cbiAqIHVuaWZvcm0xZnYobG9jLCBbMy4xOV0pID09PSB1bmlmb3JtMWYobG9jLCAzLjE5KVxuICpcbiAqIHxqcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICBzaGFkZXIgICAgICAgICAgICAgICAgICB8XG4gKiB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICogfHVuaWZvcm0xZihsb2MsIDMuMTkpICAgICAgICAgICAgICAgICAgICB8ICB1bmlmb3JtIGZsb2F0IHVfcGk7ICAgICAgICAgICAgIHxcbiAqIHx1bmlmb3JtMmYobG9jLCAzLjE5LCAyLjcyKSAgICAgICAgICAgICAgfCAgdW5pZm9ybSB2ZWMyIHVfY29uc3RhbnRzOyAgICAgICB8XG4gKiB8dW5pZm9ybTJmdihsb2MsIFszLjE5LCAyLjcyXSkgICAgICAgICAgIHwgIHVuaWZvcm0gdmVjMiB1X2NvbnN0YW50czsgICAgICAgfFxuICogfHVuaWZvcm0xZnYobG9jLCBbMSwgMiwgMywgNCwgNSwgNl0pICAgICB8ICB1bmlmb3JtIGZsb2F0IHVfa2VybmVsWzZdOyAgICAgIHxcbiAqIHx1bmlmb3JtMmZ2KGxvYywgWzEsIDIsIDMsIDQsIDUsIDZdKSAgICAgfCAgdW5pZm9ybSB2ZWMyIHVfb2JzZXJ2YXRpb25zWzNdOyB8XG4gKiB8dW5pZm9ybU1hdHJpeDNmdihsb2MsIFtbLi4uXSwgWy4uLl1dKSAgIHwgIHVuaWZvcm0gbWF0MyB1X21hdHJpeDsgICAgICAgICAgfFxuICpcbiAqIEEgbm90ZSBhYm91dCBgc3RydWN0c2AuIEEgc2hhZGVyIGNvZGUgbGlrZSB0aGlzOlxuICogYGBgZ2xzbFxuICogc3RydWN0IExpZ2h0SW5mbyB7XG4gKiAgICB2ZWM0IFBvc2l0aW9uO1xuICogICAgdmVjMyBMYTtcbiAqIH07XG4gKiB1bmlmb3JtIExpZ2h0SW5mbyBMaWdodDtcbiAqIGBgYFxuICogLi4uIGlzIGFjY2Vzc2VkIGxpa2UgdGhhdDpcbiAqIGBgYGpzXG4gKiBjb25zdCBsaWdodFBvc0xvYyA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcIkxpZ2h0LlBvc2l0aW9uXCIpO1xuICogY29uc3QgbGlnaHRMYUxvYyA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcIkxpZ2h0LkxhXCIpO1xuICogZ2wudW5pZm9ybTRmdihsaWdodFBvc0xvYywgWzEsIDIsIDMsIDRdKTtcbiAqIGdsLnVuaWZvcm0zZnYobGlnaHRMYUxvYywgWzEsIDIsIDNdKTtcbiAqIGBgYFxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IGJpbmRWYWx1ZVRvVW5pZm9ybSA9IChnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCB1bmlmb3JtTG9jYXRpb246IFdlYkdMVW5pZm9ybUxvY2F0aW9uLCB0eXBlOiBXZWJHTFZhcmlhYmxlVHlwZSwgdmFsdWVzOiBudW1iZXJbXSk6IHZvaWQgPT4ge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdib29sJzpcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xaSh1bmlmb3JtTG9jYXRpb24sIHZhbHVlc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYnZlYzInOlxuICAgICAgICAgICAgZ2wudW5pZm9ybTJpKHVuaWZvcm1Mb2NhdGlvbiwgdmFsdWVzWzBdLCB2YWx1ZXNbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2J2ZWMzJzpcbiAgICAgICAgICAgIGdsLnVuaWZvcm0zaSh1bmlmb3JtTG9jYXRpb24sIHZhbHVlc1swXSwgdmFsdWVzWzFdLCB2YWx1ZXNbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2J2ZWM0JzpcbiAgICAgICAgICAgIGdsLnVuaWZvcm00aSh1bmlmb3JtTG9jYXRpb24sIHZhbHVlc1swXSwgdmFsdWVzWzFdLCB2YWx1ZXNbMl0sIHZhbHVlc1szXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYm9vbFtdJzpcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xaXYodW5pZm9ybUxvY2F0aW9uLCB2YWx1ZXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2J2ZWMyW10nOlxuICAgICAgICAgICAgZ2wudW5pZm9ybTJpdih1bmlmb3JtTG9jYXRpb24sIHZhbHVlcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYnZlYzNbXSc6XG4gICAgICAgICAgICBnbC51bmlmb3JtM2l2KHVuaWZvcm1Mb2NhdGlvbiwgdmFsdWVzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdidmVjNFtdJzpcbiAgICAgICAgICAgIGdsLnVuaWZvcm00aXYodW5pZm9ybUxvY2F0aW9uLCB2YWx1ZXMpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnaW50JzpcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xaSh1bmlmb3JtTG9jYXRpb24sIHZhbHVlc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaXZlYzInOlxuICAgICAgICAgICAgZ2wudW5pZm9ybTJpKHVuaWZvcm1Mb2NhdGlvbiwgdmFsdWVzWzBdLCB2YWx1ZXNbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2l2ZWMzJzpcbiAgICAgICAgICAgIGdsLnVuaWZvcm0zaSh1bmlmb3JtTG9jYXRpb24sIHZhbHVlc1swXSwgdmFsdWVzWzFdLCB2YWx1ZXNbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2l2ZWM0JzpcbiAgICAgICAgICAgIGdsLnVuaWZvcm00aSh1bmlmb3JtTG9jYXRpb24sIHZhbHVlc1swXSwgdmFsdWVzWzFdLCB2YWx1ZXNbMl0sIHZhbHVlc1szXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaW50W10nOlxuICAgICAgICAgICAgZ2wudW5pZm9ybTFpdih1bmlmb3JtTG9jYXRpb24sIHZhbHVlcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaXZlYzJbXSc6XG4gICAgICAgICAgICBnbC51bmlmb3JtMml2KHVuaWZvcm1Mb2NhdGlvbiwgdmFsdWVzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdpdmVjM1tdJzpcbiAgICAgICAgICAgIGdsLnVuaWZvcm0zaXYodW5pZm9ybUxvY2F0aW9uLCB2YWx1ZXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2l2ZWM0W10nOlxuICAgICAgICAgICAgZ2wudW5pZm9ybTRpdih1bmlmb3JtTG9jYXRpb24sIHZhbHVlcyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmbG9hdCc6XG4gICAgICAgICAgICBnbC51bmlmb3JtMWYodW5pZm9ybUxvY2F0aW9uLCB2YWx1ZXNbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3ZlYzInOlxuICAgICAgICAgICAgZ2wudW5pZm9ybTJmKHVuaWZvcm1Mb2NhdGlvbiwgdmFsdWVzWzBdLCB2YWx1ZXNbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3ZlYzMnOlxuICAgICAgICAgICAgZ2wudW5pZm9ybTNmKHVuaWZvcm1Mb2NhdGlvbiwgdmFsdWVzWzBdLCB2YWx1ZXNbMV0sIHZhbHVlc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndmVjNCc6XG4gICAgICAgICAgICBnbC51bmlmb3JtNGYodW5pZm9ybUxvY2F0aW9uLCB2YWx1ZXNbMF0sIHZhbHVlc1sxXSwgdmFsdWVzWzJdLCB2YWx1ZXNbM10pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Zsb2F0W10nOlxuICAgICAgICAgICAgZ2wudW5pZm9ybTFmdih1bmlmb3JtTG9jYXRpb24sIHZhbHVlcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndmVjMltdJzpcbiAgICAgICAgICAgIGdsLnVuaWZvcm0yZnYodW5pZm9ybUxvY2F0aW9uLCB2YWx1ZXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3ZlYzNbXSc6XG4gICAgICAgICAgICBnbC51bmlmb3JtM2Z2KHVuaWZvcm1Mb2NhdGlvbiwgdmFsdWVzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd2ZWM0W10nOlxuICAgICAgICAgICAgZ2wudW5pZm9ybTRmdih1bmlmb3JtTG9jYXRpb24sIHZhbHVlcyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAvLyBJbiB0aGUgZm9sbG93aW5nICptYXRyaXgqIGNhbGxzLCB0aGUgJ3RyYW5zcG9zZScgcGFyYW1ldGVyIG11c3QgYWx3YXlzIGJlIGZhbHNlLlxuICAgICAgICAvLyBRdW90aW5nIHRoZSBPcGVuR0wgRVMgMi4wIHNwZWM6XG4gICAgICAgIC8vIElmIHRoZSB0cmFuc3Bvc2UgcGFyYW1ldGVyIHRvIGFueSBvZiB0aGUgVW5pZm9ybU1hdHJpeCogY29tbWFuZHMgaXNcbiAgICAgICAgLy8gbm90IEZBTFNFLCBhbiBJTlZBTElEX1ZBTFVFIGVycm9yIGlzIGdlbmVyYXRlZCwgYW5kIG5vIHVuaWZvcm0gdmFsdWVzIGFyZVxuICAgICAgICAvLyBjaGFuZ2VkLlxuICAgICAgICBjYXNlICdtYXQyJzpcbiAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXgyZnYodW5pZm9ybUxvY2F0aW9uLCBmYWxzZSwgdmFsdWVzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ21hdDMnOlxuICAgICAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdih1bmlmb3JtTG9jYXRpb24sIGZhbHNlLCB2YWx1ZXMpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbWF0NCc6XG4gICAgICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHVuaWZvcm1Mb2NhdGlvbiwgZmFsc2UsIHZhbHVlcyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFR5cGUgJHt0eXBlfSBub3QgaW1wbGVtZW50ZWQuYCk7XG4gICAgfVxufTtcblxuXG4vKipcbiAqIChGcm9tIGh0dHBzOi8vaGFja3MubW96aWxsYS5vcmcvMjAxMy8wNC90aGUtY29uY2VwdHMtb2Ytd2ViZ2wvIGFuZCBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81NjMwMzY0OC93ZWJnbC1yZW5kZXJpbmctYnVmZmVyczopXG4gKiBJZ25vcmluZyBoYW5kbWFkZSBmcmFtZWJ1ZmZlcnMsIFdlYkdsIGhhcyB0d28gZnJhbWVidWZmZXJzIHRoYXQgYXJlIGFsd2F5cyBpbiB1c2U6IHRoZSBgZnJvbnRidWZmZXIvZGlzcGxheWJ1ZmZlcmAgYW5kIHRoZSBgYmFja2J1ZmZlci9kcmF3aW5nYnVmZmVyYC5cbiAqIFdlYkdsIHBlciBkZWZhdWx0IHJlbmRlcnMgdG8gdGhlIGBkcmF3aW5nYnVmZmVyYCwgYWthLiB0aGUgYGJhY2tidWZmZXJgLlxuICogVGhlcmUgaXMgYWxzbyB0aGUgY3VycmVudGx5IGRpc3BsYXllZCBidWZmZXIsIG5hbWVkIHRoZSBgZnJvbnRidWZmZXJgIGFrYS4gdGhlIGBkaXNwbGF5YnVmZmVyYC5cbiAqIHRoZSBXZWJHTCBwcm9ncmFtbWVyIGhhcyBubyBleHBsaWNpdCBhY2Nlc3MgdG8gdGhlIGZyb250YnVmZmVyIHdoYXRzb2V2ZXIuXG4gKlxuICogT25jZSB5b3UgY2FsbGVkIGBjbGVhcmAsIGBkcmF3RWxlbWVudHNgIG9yIGBkcmF3QXJyYXlzYCwgdGhlIGJyb3dzZXIgbWFya3MgdGhlIGNhbnZhcyBhcyBgbmVlZHMgdG8gYmUgY29tcG9zaXRlZGAuXG4gKiBBc3N1bWluZyBgcHJlc2VydmVEcmF3aW5nQnVmZmVyID09IGZhbHNlYCAodGhlIGRlZmF1bHQpOiBJbW1lZGlhdGVseSBiZWZvcmUgY29tcG9zaXRpbmcsIHRoZSBicm93c2VyXG4gKiAgLSBzd2FwcyB0aGUgYmFjay0gYW5kIGZyb250YnVmZmVyXG4gKiAgLSBjbGVhcnMgdGhlIG5ldyBiYWNrYnVmZmVyLlxuICogSWYgYHByZXNlcnZlRHJhd2luZ0J1ZmZlciA9PT0gdHJ1ZWA6IEltbWVkaWF0ZWx5IGJlZm9yZSBjb21wb3NpdGluZywgdGhlIGJyb3dzZXJcbiAqICAtIGNvcGllcyB0aGUgZHJhd2luZ2J1ZmZlciB0byB0aGUgZnJvbnRidWZmZXIuXG4gKlxuICogQXMgYSBjb25zZXF1ZW5jZSwgaWYgeW91J3JlIGdvaW5nIHRvIHVzZSBjYW52YXMudG9EYXRhVVJMIG9yIGNhbnZhcy50b0Jsb2Igb3IgZ2wucmVhZFBpeGVscyBvciBhbnkgb3RoZXIgd2F5IG9mIGdldHRpbmcgZGF0YSBmcm9tIGEgV2ViR0wgY2FudmFzLFxuICogdW5sZXNzIHlvdSByZWFkIGl0IGluIHRoZSBzYW1lIGV2ZW50IHRoZW4gaXQgd2lsbCBsaWtlbHkgYmUgY2xlYXIgd2hlbiB5b3UgdHJ5IHRvIHJlYWQgaXQuXG4gKlxuICogSW4gdGhlIHBhc3QsIG9sZCBnYW1lcyBhbHdheXMgcHJlc2VydmVkIHRoZSBkcmF3aW5nIGJ1ZmZlciwgc28gdGhleSdkIG9ubHkgaGF2ZSB0byBjaGFuZ2UgdGhvc2UgcGl4ZWxzIHRoYXQgaGF2ZSBhY3R1YWxseSBjaGFuZ2VkLiBOb3dhZGF5cyBwcmVzZXJ2ZURyYXdpbmdCdWZmZXIgaXMgZmFsc2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBBIChhbG1vc3QgYnJ1dGFsKSB3b3JrYXJvdW5kIHRvIGdldCB0aGUgY2FudmFzIHRvIHByZXNlcnZlIHRoZSBkcmF3aW5nQnVmZmVyIGNhbiBiZSBmb3VuZCBoZXJlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNjc4MzU4Ni9jYW52YXMtdG9kYXRhdXJsLXJldHVybnMtYmxhbmstaW1hZ2VcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEN1cnJlbnRGcmFtZWJ1ZmZlcnNQaXhlbHMgPSAoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCk6IEFycmF5QnVmZmVyICA9PiB7XG4gICAgY29uc3QgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnKTtcbiAgICBpZiAoIWdsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gY29udGV4dCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGZvcm1hdCA9IGdsLmdldFBhcmFtZXRlcihnbC5JTVBMRU1FTlRBVElPTl9DT0xPUl9SRUFEX0ZPUk1BVCk7XG4gICAgY29uc3QgdHlwZSA9IGdsLmdldFBhcmFtZXRlcihnbC5JTVBMRU1FTlRBVElPTl9DT0xPUl9SRUFEX1RZUEUpO1xuXG4gICAgbGV0IHBpeGVscztcbiAgICBpZiAodHlwZSA9PT0gZ2wuVU5TSUdORURfQllURSkge1xuICAgICAgICBwaXhlbHMgPSBuZXcgVWludDhBcnJheShnbC5kcmF3aW5nQnVmZmVyV2lkdGggKiBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0ICogNCk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBnbC5VTlNJR05FRF9TSE9SVF81XzZfNSB8fCB0eXBlID09PSBnbC5VTlNJR05FRF9TSE9SVF80XzRfNF80IHx8IHR5cGUgPT09IGdsLlVOU0lHTkVEX1NIT1JUXzVfNV81XzEpIHtcbiAgICAgICAgcGl4ZWxzID0gbmV3IFVpbnQxNkFycmF5KGdsLmRyYXdpbmdCdWZmZXJXaWR0aCAqIGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQgKiA0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IGdsLkZMT0FUKSB7XG4gICAgICAgIHBpeGVscyA9IG5ldyBGbG9hdDMyQXJyYXkoZ2wuZHJhd2luZ0J1ZmZlcldpZHRoICogZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCAqIDQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRGlkIG5vdCB1bmRlcnN0YW5kIHBpeGVsIGRhdGEgdHlwZSAke3R5cGV9IGZvciBmb3JtYXQgJHtmb3JtYXR9YCk7XG4gICAgfVxuXG4gICAgLy8gSnVzdCBsaWtlIGB0b0RhdGFVUkxgIG9yIGB0b0Jsb2JgLCBgcmVhZFBpeGVsc2AgZG9lcyBub3QgYWNjZXNzIHRoZSBmcm9udGJ1ZmZlci5cbiAgICAvLyBJdCBhY2Nlc3NlcyB0aGUgYmFja2J1ZmZlciBvciBhbnkgb3RoZXIgY3VycmVudGx5IGFjdGl2ZSBmcmFtZWJ1ZmZlci5cbiAgICBnbC5yZWFkUGl4ZWxzKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCwgZm9ybWF0LCB0eXBlLCBwaXhlbHMpO1xuXG4gICAgcmV0dXJuIHBpeGVscztcbn07XG5cbmV4cG9ydCBjb25zdCBnZXREZWJ1Z0luZm8gPSAoZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCk6IG9iamVjdCA9PiB7XG4gICAgY29uc3QgYmFzZUluZm8gPSB7XG4gICAgICAgIHJlbmRlcmVyOiBnbC5nZXRQYXJhbWV0ZXIoZ2wuUkVOREVSRVIpLFxuICAgICAgICBjdXJyZW50UHJvZ3JhbTogZ2wuZ2V0UGFyYW1ldGVyKGdsLkNVUlJFTlRfUFJPR1JBTSksXG4gICAgICAgIGFycmF5QnVmZmVyOiBnbC5nZXRQYXJhbWV0ZXIoZ2wuQVJSQVlfQlVGRkVSX0JJTkRJTkcpLFxuICAgICAgICBlbGVtZW50QXJyYXlCdWZmZXI6IGdsLmdldFBhcmFtZXRlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUl9CSU5ESU5HKSxcbiAgICAgICAgZnJhbWVCdWZmZXI6IGdsLmdldFBhcmFtZXRlcihnbC5GUkFNRUJVRkZFUl9CSU5ESU5HKSxcbiAgICAgICAgcmVuZGVyQnVmZmVyOiBnbC5nZXRQYXJhbWV0ZXIoZ2wuUkVOREVSQlVGRkVSX0JJTkRJTkcpLFxuICAgICAgICB0ZXh0dXJlOiBnbC5nZXRQYXJhbWV0ZXIoZ2wuVEVYVFVSRV9CSU5ESU5HXzJEKSxcbiAgICAgICAgdmlld1BvcnQ6IGdsLmdldFBhcmFtZXRlcihnbC5WSUVXUE9SVClcbiAgICB9O1xuICAgIGNvbnN0IHByb2dyYW1JbmZvID0ge1xuICAgICAgICBpbmZvTG9nOiBnbC5nZXRQcm9ncmFtSW5mb0xvZyhiYXNlSW5mby5jdXJyZW50UHJvZ3JhbSlcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGJhc2VJbmZvLCBwcm9ncmFtSW5mb1xuICAgIH1cbn07XG4iXX0=